<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_regexdev/rte_regexdev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_6ecd98fc82417913001865d72dc75dac.html">librte_regexdev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_regexdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;rte_config.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__dev_8h_source.html">rte_dev.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__errno_8h_source.html">rte_errno.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__regexdev__core_8h_source.html">rte_regexdev_core.h</a>&quot;</code><br />
</div>
<p><a href="rte__regexdev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__regexdev__info.html">rte_regexdev_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__regexdev__config.html">rte_regexdev_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__regexdev__qp__conf.html">rte_regexdev_qp_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__regexdev__rule.html">rte_regexdev_rule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__regexdev__xstats__map.html">rte_regexdev_xstats_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__regexdev__match.html">rte_regexdev_match</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__regex__ops.html">rte_regex_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a95cabf0e76a2b8b2e93fdc4cee44fc97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a95cabf0e76a2b8b2e93fdc4cee44fc97">RTE_REGEXDEV_CAPA_RUNTIME_COMPILATION_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:a95cabf0e76a2b8b2e93fdc4cee44fc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3552ccca6c6cb2c996c9ca30ad8ba6d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a3552ccca6c6cb2c996c9ca30ad8ba6d6">RTE_REGEXDEV_CAPA_SUPP_PCRE_START_ANCHOR_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:a3552ccca6c6cb2c996c9ca30ad8ba6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2ab524ea04a5611cacbbb5f17e1837"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#adc2ab524ea04a5611cacbbb5f17e1837">RTE_REGEXDEV_CAPA_SUPP_PCRE_ATOMIC_GROUPING_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td></tr>
<tr class="separator:adc2ab524ea04a5611cacbbb5f17e1837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a664dc9ead5993c04f902247c67f6ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a9a664dc9ead5993c04f902247c67f6ed">RTE_REGEXDEV_SUPP_PCRE_BACKTRACKING_CTRL_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td></tr>
<tr class="separator:a9a664dc9ead5993c04f902247c67f6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402c6b5b515ce58ee9461094de071e58"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a402c6b5b515ce58ee9461094de071e58">RTE_REGEXDEV_SUPP_PCRE_CALLOUTS_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td></tr>
<tr class="separator:a402c6b5b515ce58ee9461094de071e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25a7f4d669475bf9a103689a4c6ce00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#af25a7f4d669475bf9a103689a4c6ce00">RTE_REGEXDEV_SUPP_PCRE_BACKREFERENCE_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 5)</td></tr>
<tr class="separator:af25a7f4d669475bf9a103689a4c6ce00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7332544e033cfd3a31898fd0cae8f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a6b7332544e033cfd3a31898fd0cae8f7">RTE_REGEXDEV_SUPP_PCRE_GREEDY_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 6)</td></tr>
<tr class="separator:a6b7332544e033cfd3a31898fd0cae8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67759e5654e9ebaa42330244acf660dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a67759e5654e9ebaa42330244acf660dc">RTE_REGEXDEV_SUPP_PCRE_MATCH_ALL_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 7)</td></tr>
<tr class="separator:a67759e5654e9ebaa42330244acf660dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6247651f8e6fca542037968d36e98e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#aca6247651f8e6fca542037968d36e98e">RTE_REGEXDEV_SUPP_PCRE_LOOKAROUND_ASRT_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 8)</td></tr>
<tr class="separator:aca6247651f8e6fca542037968d36e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd707d2bafbee6acab214044335f33a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a3fd707d2bafbee6acab214044335f33a">RTE_REGEXDEV_SUPP_PCRE_MATCH_POINT_RST_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 9)</td></tr>
<tr class="separator:a3fd707d2bafbee6acab214044335f33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6563dfc782fab948e3f1951c3ef7ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#adc6563dfc782fab948e3f1951c3ef7ce">RTE_REGEXDEV_SUPP_NEWLINE_CONVENTIONS_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 10)</td></tr>
<tr class="separator:adc6563dfc782fab948e3f1951c3ef7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb0018df95cce8b2eef459b545cc159"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a3cb0018df95cce8b2eef459b545cc159">RTE_REGEXDEV_SUPP_PCRE_NEWLINE_SEQ_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 11)</td></tr>
<tr class="separator:a3cb0018df95cce8b2eef459b545cc159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af760d04c907324501a6c87519cac3885"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#af760d04c907324501a6c87519cac3885">RTE_REGEXDEV_SUPP_PCRE_POSSESSIVE_QUALIFIERS_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 12)</td></tr>
<tr class="separator:af760d04c907324501a6c87519cac3885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a8a7ea3cb7745ab2aa22f2d274e74b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a06a8a7ea3cb7745ab2aa22f2d274e74b">RTE_REGEXDEV_SUPP_PCRE_SUBROUTINE_REFERENCES_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 13)</td></tr>
<tr class="separator:a06a8a7ea3cb7745ab2aa22f2d274e74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad134d9d21b4621a0e26132b20a2cc411"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#ad134d9d21b4621a0e26132b20a2cc411">RTE_REGEXDEV_SUPP_PCRE_UTF_8_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 14)</td></tr>
<tr class="separator:ad134d9d21b4621a0e26132b20a2cc411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeccc52b39be29a616699c654d79640d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#adeccc52b39be29a616699c654d79640d">RTE_REGEXDEV_SUPP_PCRE_UTF_16_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 15)</td></tr>
<tr class="separator:adeccc52b39be29a616699c654d79640d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b9b80b713093e969505e2b1a304cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a616b9b80b713093e969505e2b1a304cc">RTE_REGEXDEV_SUPP_PCRE_UTF_32_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 16)</td></tr>
<tr class="separator:a616b9b80b713093e969505e2b1a304cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcfff4eba009556f5fa14a0d0850f4b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a7fcfff4eba009556f5fa14a0d0850f4b">RTE_REGEXDEV_SUPP_PCRE_WORD_BOUNDARY_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 17)</td></tr>
<tr class="separator:a7fcfff4eba009556f5fa14a0d0850f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135890fff52d343155562f3da5f2de76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a135890fff52d343155562f3da5f2de76">RTE_REGEXDEV_SUPP_PCRE_FORWARD_REFERENCES_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 18)</td></tr>
<tr class="separator:a135890fff52d343155562f3da5f2de76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0842995aa689557eb7a1be5668c4f6be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a0842995aa689557eb7a1be5668c4f6be">RTE_REGEXDEV_SUPP_MATCH_AS_END_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 19)</td></tr>
<tr class="separator:a0842995aa689557eb7a1be5668c4f6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6b58e135c2a4c5960ae684cda0c227"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a7c6b58e135c2a4c5960ae684cda0c227">RTE_REGEXDEV_SUPP_CROSS_BUFFER_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 20)</td></tr>
<tr class="separator:a7c6b58e135c2a4c5960ae684cda0c227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1203323b55c2302e245322cc7fadd8e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#aa1203323b55c2302e245322cc7fadd8e">RTE_REGEXDEV_SUPP_MATCH_ALL_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 21)</td></tr>
<tr class="separator:aa1203323b55c2302e245322cc7fadd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5655b7482f78592dac636c34151c56c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a5655b7482f78592dac636c34151c56c5">RTE_REGEXDEV_CAPA_QUEUE_PAIR_OOS_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 22)</td></tr>
<tr class="separator:a5655b7482f78592dac636c34151c56c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385848182e0037043eddace45991cd3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a385848182e0037043eddace45991cd3c">RTE_REGEX_PCRE_RULE_ALLOW_EMPTY_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:a385848182e0037043eddace45991cd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09c1d7a0003403c8556c29a699cabdf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#ac09c1d7a0003403c8556c29a699cabdf">RTE_REGEX_PCRE_RULE_ANCHORED_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:ac09c1d7a0003403c8556c29a699cabdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523eb523e324e78c5ff577921fa07890"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a523eb523e324e78c5ff577921fa07890">RTE_REGEX_PCRE_RULE_CASELESS_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td></tr>
<tr class="separator:a523eb523e324e78c5ff577921fa07890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64e70a7505c6c3372df52cf81ba6eee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#aa64e70a7505c6c3372df52cf81ba6eee">RTE_REGEX_PCRE_RULE_DOTALL_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td></tr>
<tr class="separator:aa64e70a7505c6c3372df52cf81ba6eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a31e33303103fd366ee8614580d8e0a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a0a31e33303103fd366ee8614580d8e0a">RTE_REGEX_PCRE_RULE_DUPNAMES_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td></tr>
<tr class="separator:a0a31e33303103fd366ee8614580d8e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d497d59728f924d4def11abd4b2e523"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a0d497d59728f924d4def11abd4b2e523">RTE_REGEX_PCRE_RULE_EXTENDED_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 5)</td></tr>
<tr class="separator:a0d497d59728f924d4def11abd4b2e523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254b4f34b2fa3a3401e40fe2df7bf7b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a254b4f34b2fa3a3401e40fe2df7bf7b4">RTE_REGEX_PCRE_RULE_MATCH_UNSET_BACKREF_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 6)</td></tr>
<tr class="separator:a254b4f34b2fa3a3401e40fe2df7bf7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ddaac7b6f1d07da9ffd635cd88e8ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a64ddaac7b6f1d07da9ffd635cd88e8ba">RTE_REGEX_PCRE_RULE_MULTILINE_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 7)</td></tr>
<tr class="separator:a64ddaac7b6f1d07da9ffd635cd88e8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695b65feeebf402f06a24aae07077743"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a695b65feeebf402f06a24aae07077743">RTE_REGEX_PCRE_RULE_NO_AUTO_CAPTURE_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 8)</td></tr>
<tr class="separator:a695b65feeebf402f06a24aae07077743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2077510bc486e17d3008b47845b18ac5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a2077510bc486e17d3008b47845b18ac5">RTE_REGEX_PCRE_RULE_UCP_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 9)</td></tr>
<tr class="separator:a2077510bc486e17d3008b47845b18ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93336f9b543a2b1b3b78dac2e275e448"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a93336f9b543a2b1b3b78dac2e275e448">RTE_REGEX_PCRE_RULE_UNGREEDY_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 10)</td></tr>
<tr class="separator:a93336f9b543a2b1b3b78dac2e275e448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef9f14f41cfdfe2b8bb05ceae8ca67d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a3ef9f14f41cfdfe2b8bb05ceae8ca67d">RTE_REGEX_PCRE_RULE_UTF_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 11)</td></tr>
<tr class="separator:a3ef9f14f41cfdfe2b8bb05ceae8ca67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a18d0d7996eef178fbc479c8ededefb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a4a18d0d7996eef178fbc479c8ededefb">RTE_REGEX_PCRE_RULE_NEVER_BACKSLASH_C_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 12)</td></tr>
<tr class="separator:a4a18d0d7996eef178fbc479c8ededefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf9301fb23e72f89547274512de358b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#abaf9301fb23e72f89547274512de358b">RTE_REGEXDEV_CFG_CROSS_BUFFER_SCAN_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:abaf9301fb23e72f89547274512de358b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f78abc0552edb1fc45fb0c8dea42950"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a1f78abc0552edb1fc45fb0c8dea42950">RTE_REGEXDEV_CFG_MATCH_AS_END_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:a1f78abc0552edb1fc45fb0c8dea42950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad8fc943e3ba539cdf8a62166d80c88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a7ad8fc943e3ba539cdf8a62166d80c88">RTE_REGEXDEV_CFG_MATCH_ALL_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td></tr>
<tr class="separator:a7ad8fc943e3ba539cdf8a62166d80c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242825bfbf30eab32f19539930a2b992"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a242825bfbf30eab32f19539930a2b992">RTE_REGEX_QUEUE_PAIR_CFG_OOS_F</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:a242825bfbf30eab32f19539930a2b992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af728fe411ff5ebffb5a5d848db180628"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#af728fe411ff5ebffb5a5d848db180628">RTE_REGEXDEV_XSTATS_NAME_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:af728fe411ff5ebffb5a5d848db180628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c47197f179ead4451e0715fe671eae0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a7c47197f179ead4451e0715fe671eae0">RTE_REGEX_OPS_REQ_GROUP_ID0_VALID_F</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:a7c47197f179ead4451e0715fe671eae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf588ab914c9fd0011158c4e21f75d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a96cf588ab914c9fd0011158c4e21f75d">RTE_REGEX_OPS_REQ_GROUP_ID1_VALID_F</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:a96cf588ab914c9fd0011158c4e21f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0095e6381cf1cbba6c570df3fbad580b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a0095e6381cf1cbba6c570df3fbad580b">RTE_REGEX_OPS_REQ_GROUP_ID2_VALID_F</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="separator:a0095e6381cf1cbba6c570df3fbad580b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7959bdf87696c1d22b40a9d6a1070890"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a7959bdf87696c1d22b40a9d6a1070890">RTE_REGEX_OPS_REQ_GROUP_ID3_VALID_F</a>&#160;&#160;&#160;(1 &lt;&lt; 3)</td></tr>
<tr class="separator:a7959bdf87696c1d22b40a9d6a1070890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724d4257e4ca795f34ae9d62463bb80c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a724d4257e4ca795f34ae9d62463bb80c">RTE_REGEX_OPS_REQ_STOP_ON_MATCH_F</a>&#160;&#160;&#160;(1 &lt;&lt; 4)</td></tr>
<tr class="separator:a724d4257e4ca795f34ae9d62463bb80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6993ab82b135442e61c198a30f8f127"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#af6993ab82b135442e61c198a30f8f127">RTE_REGEX_OPS_REQ_MATCH_HIGH_PRIORITY_F</a>&#160;&#160;&#160;(1 &lt;&lt; 5)</td></tr>
<tr class="separator:af6993ab82b135442e61c198a30f8f127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bd7c37118a55ec625bc7796bd8bcdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a94bd7c37118a55ec625bc7796bd8bcdc">RTE_REGEX_OPS_RSP_PMI_SOJ_F</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:a94bd7c37118a55ec625bc7796bd8bcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6010f7020140913b49841fd72ad06255"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a6010f7020140913b49841fd72ad06255">RTE_REGEX_OPS_RSP_PMI_EOJ_F</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:a6010f7020140913b49841fd72ad06255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa905525ca43d735a786137f84e9f49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a3fa905525ca43d735a786137f84e9f49">RTE_REGEX_OPS_RSP_MAX_SCAN_TIMEOUT_F</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="separator:a3fa905525ca43d735a786137f84e9f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd10c1b60ba64e2b058de4c8c3cc9931"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#afd10c1b60ba64e2b058de4c8c3cc9931">RTE_REGEX_OPS_RSP_MAX_MATCH_F</a>&#160;&#160;&#160;(1 &lt;&lt; 3)</td></tr>
<tr class="separator:afd10c1b60ba64e2b058de4c8c3cc9931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85268bf7cbf316dce075a9cca6b21542"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a85268bf7cbf316dce075a9cca6b21542">RTE_REGEX_OPS_RSP_MAX_PREFIX_F</a>&#160;&#160;&#160;(1 &lt;&lt; 4)</td></tr>
<tr class="separator:a85268bf7cbf316dce075a9cca6b21542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab3d0c8a12442ce2008f72dd7d541efe9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#ab3d0c8a12442ce2008f72dd7d541efe9">regexdev_stop_flush_t</a>) (uint8_t dev_id, uint16_t qp_id, struct <a class="el" href="structrte__regex__ops.html">rte_regex_ops</a> *op)</td></tr>
<tr class="separator:ab3d0c8a12442ce2008f72dd7d541efe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a67232fe9fd9dac49eb93b6acf9432461"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461">rte_regexdev_attr_id</a> { <a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461a99cd36d2f600f62d49f37bd89f0ec604">RTE_REGEXDEV_ATTR_SOCKET_ID</a>, 
<a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461aaca5501cfa9c0c7fe2b3ab14ab42762e">RTE_REGEXDEV_ATTR_MAX_MATCHES</a>, 
<a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461aa5d6060fa57310db2f0c7266866b58fc">RTE_REGEXDEV_ATTR_MAX_SCAN_TIMEOUT</a>, 
<a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461a04aaf59bad169e1aadf3996a546584d3">RTE_REGEXDEV_ATTR_MAX_PREFIX</a>
 }</td></tr>
<tr class="separator:a67232fe9fd9dac49eb93b6acf9432461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca03004a398d840d510f14af95ba7093"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#aca03004a398d840d510f14af95ba7093">rte_regexdev_rule_op</a> { <a class="el" href="rte__regexdev_8h.html#aca03004a398d840d510f14af95ba7093a329521e2395655de7d52f1382a88b025">RTE_REGEX_RULE_OP_ADD</a>, 
<a class="el" href="rte__regexdev_8h.html#aca03004a398d840d510f14af95ba7093a6f4c872be26b168de15d479ca021096a">RTE_REGEX_RULE_OP_REMOVE</a>
 }</td></tr>
<tr class="separator:aca03004a398d840d510f14af95ba7093"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af42fd6408904af61e84693f9554450fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#af42fd6408904af61e84693f9554450fe">rte_regexdev_is_valid_dev</a> (uint16_t dev_id)</td></tr>
<tr class="separator:af42fd6408904af61e84693f9554450fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2481ae53ce4f22bcc0cc285df376d39a"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a2481ae53ce4f22bcc0cc285df376d39a">rte_regexdev_count</a> (void)</td></tr>
<tr class="separator:a2481ae53ce4f22bcc0cc285df376d39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342280d1e909d81b93a9559d370c9373"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a342280d1e909d81b93a9559d370c9373">rte_regexdev_get_dev_id</a> (const char *name)</td></tr>
<tr class="separator:a342280d1e909d81b93a9559d370c9373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3679aa5c2e6bdb87749d7b1398a5f4f7"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a3679aa5c2e6bdb87749d7b1398a5f4f7">rte_regexdev_info_get</a> (uint8_t dev_id, struct <a class="el" href="structrte__regexdev__info.html">rte_regexdev_info</a> *dev_info)</td></tr>
<tr class="separator:a3679aa5c2e6bdb87749d7b1398a5f4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45418b9292bfb06c9e519a47acb18d3"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure</a> (uint8_t dev_id, const struct <a class="el" href="structrte__regexdev__config.html">rte_regexdev_config</a> *cfg)</td></tr>
<tr class="separator:ad45418b9292bfb06c9e519a47acb18d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c572edf58657370348881043bd64e3f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a5c572edf58657370348881043bd64e3f">rte_regexdev_queue_pair_setup</a> (uint8_t dev_id, uint16_t queue_pair_id, const struct <a class="el" href="structrte__regexdev__qp__conf.html">rte_regexdev_qp_conf</a> *qp_conf)</td></tr>
<tr class="separator:a5c572edf58657370348881043bd64e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a69925157b2995b170759f2d6c9a29"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#af5a69925157b2995b170759f2d6c9a29">rte_regexdev_start</a> (uint8_t dev_id)</td></tr>
<tr class="separator:af5a69925157b2995b170759f2d6c9a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bbcc1b0f4be720ae9cc048c4518089"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a51bbcc1b0f4be720ae9cc048c4518089">rte_regexdev_stop</a> (uint8_t dev_id)</td></tr>
<tr class="separator:a51bbcc1b0f4be720ae9cc048c4518089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19639c998e2df623edb92b664297ff6f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a19639c998e2df623edb92b664297ff6f">rte_regexdev_close</a> (uint8_t dev_id)</td></tr>
<tr class="separator:a19639c998e2df623edb92b664297ff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43cb9763ff40d5947dafd1c3798750b"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#ab43cb9763ff40d5947dafd1c3798750b">rte_regexdev_attr_get</a> (uint8_t dev_id, enum <a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461">rte_regexdev_attr_id</a> attr_id, void *attr_value)</td></tr>
<tr class="separator:ab43cb9763ff40d5947dafd1c3798750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbbd3146564c9db61a4d20c81792a31"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#aefbbd3146564c9db61a4d20c81792a31">rte_regexdev_attr_set</a> (uint8_t dev_id, enum <a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461">rte_regexdev_attr_id</a> attr_id, const void *attr_value)</td></tr>
<tr class="separator:aefbbd3146564c9db61a4d20c81792a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d95cbad76491dba0f42d2131c03de5"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#ab6d95cbad76491dba0f42d2131c03de5">rte_regexdev_rule_db_update</a> (uint8_t dev_id, const struct <a class="el" href="structrte__regexdev__rule.html">rte_regexdev_rule</a> *rules, uint32_t nb_rules)</td></tr>
<tr class="separator:ab6d95cbad76491dba0f42d2131c03de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081569d15e802854eebd83aadbabb52f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a081569d15e802854eebd83aadbabb52f">rte_regexdev_rule_db_compile_activate</a> (uint8_t dev_id)</td></tr>
<tr class="separator:a081569d15e802854eebd83aadbabb52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34a302ed3976da3aa37b7f8e0dffc62"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#ab34a302ed3976da3aa37b7f8e0dffc62">rte_regexdev_rule_db_import</a> (uint8_t dev_id, const char *rule_db, uint32_t rule_db_len)</td></tr>
<tr class="separator:ab34a302ed3976da3aa37b7f8e0dffc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bad8169dea5813efd1470bf0f275109"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a9bad8169dea5813efd1470bf0f275109">rte_regexdev_rule_db_export</a> (uint8_t dev_id, char *rule_db)</td></tr>
<tr class="separator:a9bad8169dea5813efd1470bf0f275109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95207d3edcdf2bc2bf4a15ee68eeb751"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a95207d3edcdf2bc2bf4a15ee68eeb751">rte_regexdev_xstats_names_get</a> (uint8_t dev_id, struct <a class="el" href="structrte__regexdev__xstats__map.html">rte_regexdev_xstats_map</a> *xstats_map)</td></tr>
<tr class="separator:a95207d3edcdf2bc2bf4a15ee68eeb751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9569af148a1c7fd29d6f039f3fca3525"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a9569af148a1c7fd29d6f039f3fca3525">rte_regexdev_xstats_get</a> (uint8_t dev_id, const uint16_t *ids, uint64_t *values, uint16_t nb_values)</td></tr>
<tr class="separator:a9569af148a1c7fd29d6f039f3fca3525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f64543b4468024b893eb341d34c7c9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a97f64543b4468024b893eb341d34c7c9">rte_regexdev_xstats_by_name_get</a> (uint8_t dev_id, const char *name, uint16_t *id, uint64_t *value)</td></tr>
<tr class="separator:a97f64543b4468024b893eb341d34c7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81051b7125d27b67188e12ce7acc1882"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a81051b7125d27b67188e12ce7acc1882">rte_regexdev_xstats_reset</a> (uint8_t dev_id, const uint16_t *ids, uint16_t nb_ids)</td></tr>
<tr class="separator:a81051b7125d27b67188e12ce7acc1882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675332565a0036c53372823a96ae456e"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a675332565a0036c53372823a96ae456e">rte_regexdev_selftest</a> (uint8_t dev_id)</td></tr>
<tr class="separator:a675332565a0036c53372823a96ae456e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42684f89bc5a8f69d6b73f3dd95796fc"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a42684f89bc5a8f69d6b73f3dd95796fc">rte_regexdev_dump</a> (uint8_t dev_id, FILE *f)</td></tr>
<tr class="separator:a42684f89bc5a8f69d6b73f3dd95796fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ac4fed72c5d23e90fef9a9bcff994e"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#a64ac4fed72c5d23e90fef9a9bcff994e">rte_regexdev_enqueue_burst</a> (uint8_t dev_id, uint16_t qp_id, struct <a class="el" href="structrte__regex__ops.html">rte_regex_ops</a> **ops, uint16_t nb_ops)</td></tr>
<tr class="separator:a64ac4fed72c5d23e90fef9a9bcff994e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf55cac92e6e1f3355243d6fd58e51c"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__regexdev_8h.html#acbf55cac92e6e1f3355243d6fd58e51c">rte_regexdev_dequeue_burst</a> (uint8_t dev_id, uint16_t qp_id, struct <a class="el" href="structrte__regex__ops.html">rte_regex_ops</a> **ops, uint16_t nb_ops)</td></tr>
<tr class="separator:acbf55cac92e6e1f3355243d6fd58e51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE RegEx Device API</p>
<p>Defines RTE RegEx Device APIs for RegEx operations and its provisioning.</p>
<p>The RegEx Device API is composed of two parts:</p>
<ul>
<li>The application-oriented RegEx API that includes functions to setup a RegEx device (configure it, setup its queue pairs and start it), update the rule database and so on.</li>
<li>The driver-oriented RegEx API that exports a function allowing a RegEx poll Mode Driver (PMD) to simultaneously register itself as a RegEx device driver.</li>
</ul>
<p>RegEx device components and definitions: </p><pre class="fragment">+-----------------+
|                 |
|                 o---------+    rte_regexdev_[en|de]queue_burst()
|   PCRE based    o------+  |               |
|  RegEx pattern  |      |  |  +--------+   |
| matching engine o------+--+--o        |   |    +------+
|                 |      |  |  | queue  |&lt;==o===&gt;|Core 0|
|                 o----+ |  |  | pair 0 |        |      |
|                 |    | |  |  +--------+        +------+
+-----------------+    | |  |
       ^               | |  |  +--------+
       |               | |  |  |        |        +------+
       |               | +--+--o queue  |&lt;======&gt;|Core 1|
   Rule|Database       |    |  | pair 1 |        |      |
+------+----------+    |    |  +--------+        +------+
|     Group 0     |    |    |
| +-------------+ |    |    |  +--------+        +------+
| | Rules 0..n  | |    |    |  |        |        |Core 2|
| +-------------+ |    |    +--o queue  |&lt;======&gt;|      |
|     Group 1     |    |       | pair 2 |        +------+
| +-------------+ |    |       +--------+
| | Rules 0..n  | |    |
| +-------------+ |    |       +--------+
|     Group 2     |    |       |        |        +------+
| +-------------+ |    |       | queue  |&lt;======&gt;|Core n|
| | Rules 0..n  | |    +-------o pair n |        |      |
| +-------------+ |            +--------+        +------+
|     Group n     |
| +-------------+ |&lt;-------rte_regexdev_rule_db_update()
| |             | |&lt;-------rte_regexdev_rule_db_compile_activate()
| | Rules 0..n  | |&lt;-------rte_regexdev_rule_db_import()
| +-------------+ |-------&gt;rte_regexdev_rule_db_export()
+-----------------+
</pre><p>RegEx: A regular expression is a concise and flexible means for matching strings of text, such as particular characters, words, or patterns of characters. A common abbreviation for this is “RegEx”.</p>
<p>RegEx device: A hardware or software-based implementation of RegEx device API for PCRE based pattern matching syntax and semantics.</p>
<p>PCRE RegEx syntax and semantics specification: <a href="http://regexkit.sourceforge.net/Documentation/pcre/pcrepattern.html">http://regexkit.sourceforge.net/Documentation/pcre/pcrepattern.html</a></p>
<p>RegEx queue pair: Each RegEx device should have one or more queue pair to transmit a burst of pattern matching request and receive a burst of receive the pattern matching response. The pattern matching request/response embedded in <em><a class="el" href="structrte__regex__ops.html">rte_regex_ops</a></em> structure.</p>
<p>Rule: A pattern matching rule expressed in PCRE RegEx syntax along with Match ID and Group ID to identify the rule upon the match.</p>
<p>Rule database: The RegEx device accepts regular expressions and converts them into a compiled rule database that can then be used to scan data. Compilation allows the device to analyze the given pattern(s) and pre-determine how to scan for these patterns in an optimized fashion that would be far too expensive to compute at run-time. A rule database contains a set of rules that compiled in device specific binary form.</p>
<p>Match ID or Rule ID: A unique identifier provided at the time of rule creation for the application to identify the rule upon match.</p>
<p>Group ID: Group of rules can be grouped under one group ID to enable rule isolation and effective pattern matching. A unique group identifier provided at the time of rule creation for the application to identify the rule upon match.</p>
<p>Scan: A pattern matching request through <em>enqueue</em> API.</p>
<p>It may possible that a given RegEx device may not support all the features of PCRE. The application may probe unsupported features through struct rte_regexdev_info::pcre_unsup_flags</p>
<p>By default, all the functions of the RegEx Device API exported by a PMD are lock-free functions which assume to not be invoked in parallel on different logical cores to work on the same target object. For instance, the dequeue function of a PMD cannot be invoked in parallel on two logical cores to operates on same RegEx queue pair. Of course, this function can be invoked in parallel by different logical core on different queue pair. It is the responsibility of the upper level application to enforce this rule.</p>
<p>In all functions of the RegEx API, the RegEx device is designated by an integer &gt;= 0 named the device identifier <em>dev_id</em></p>
<p>At the RegEx driver level, RegEx devices are represented by a generic data structure of type <em>rte_regexdev</em>.</p>
<p>RegEx devices are dynamically registered during the PCI/SoC device probing phase performed at EAL initialization time. When a RegEx device is being probed, a <em>rte_regexdev</em> structure and a new device identifier are allocated for that device. Then, the regexdev_init() function supplied by the RegEx driver matching the probed device is invoked to properly initialize the device.</p>
<p>The role of the device init function consists of resetting the hardware or software RegEx driver implementations.</p>
<p>If the device init operation is successful, the correspondence between the device identifier assigned to the new device and its associated <em>rte_regexdev</em> structure is effectively registered. Otherwise, both the <em>rte_regexdev</em> structure and the device identifier are freed.</p>
<p>The functions exported by the application RegEx API to setup a device designated by its device identifier must be invoked in the following order:</p><ul>
<li><a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a></li>
<li><a class="el" href="rte__regexdev_8h.html#a5c572edf58657370348881043bd64e3f">rte_regexdev_queue_pair_setup()</a></li>
<li><a class="el" href="rte__regexdev_8h.html#af5a69925157b2995b170759f2d6c9a29">rte_regexdev_start()</a></li>
</ul>
<p>Then, the application can invoke, in any order, the functions exported by the RegEx API to enqueue pattern matching job, dequeue pattern matching response, get the stats, update the rule database, get/set device attributes and so on</p>
<p>If the application wants to change the configuration (i.e. call <a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a> or <a class="el" href="rte__regexdev_8h.html#a5c572edf58657370348881043bd64e3f">rte_regexdev_queue_pair_setup()</a>), it must call <a class="el" href="rte__regexdev_8h.html#a51bbcc1b0f4be720ae9cc048c4518089">rte_regexdev_stop()</a> first to stop the device and then do the reconfiguration before calling <a class="el" href="rte__regexdev_8h.html#af5a69925157b2995b170759f2d6c9a29">rte_regexdev_start()</a> again. The enqueue and dequeue functions should not be invoked when the device is stopped.</p>
<p>Finally, an application can close a RegEx device by invoking the <a class="el" href="rte__regexdev_8h.html#a19639c998e2df623edb92b664297ff6f">rte_regexdev_close()</a> function.</p>
<p>Each function of the application RegEx API invokes a specific function of the PMD that controls the target device designated by its device identifier.</p>
<p>For this purpose, all device-specific functions of a RegEx driver are supplied through a set of pointers contained in a generic structure of type <em>regexdev_ops</em>. The address of the <em>regexdev_ops</em> structure is stored in the <em>rte_regexdev</em> structure by the device init function of the RegEx driver, which is invoked during the PCI/SoC device probing phase, as explained earlier.</p>
<p>In other words, each function of the RegEx API simply retrieves the <em>rte_regexdev</em> structure associated with the device identifier and performs an indirect invocation of the corresponding driver function supplied in the <em>regexdev_ops</em> structure of the <em>rte_regexdev</em> structure.</p>
<p>For performance reasons, the address of the fast-path functions of the RegEx driver is not contained in the <em>regexdev_ops</em> structure. Instead, they are directly stored at the beginning of the <em>rte_regexdev</em> structure to avoid an extra indirect memory access during their invocation.</p>
<p>RTE RegEx device drivers do not use interrupts for enqueue or dequeue operation. Instead, RegEx drivers export Poll-Mode enqueue and dequeue functions to applications.</p>
<p>The <em>enqueue</em> operation submits a burst of RegEx pattern matching request to the RegEx device and the <em>dequeue</em> operation gets a burst of pattern matching response for the ones submitted through <em>enqueue</em> operation.</p>
<p>Typical application utilisation of the RegEx device API will follow the following programming flow.</p>
<ul>
<li><a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a></li>
<li><a class="el" href="rte__regexdev_8h.html#a5c572edf58657370348881043bd64e3f">rte_regexdev_queue_pair_setup()</a></li>
<li><a class="el" href="rte__regexdev_8h.html#ab6d95cbad76491dba0f42d2131c03de5">rte_regexdev_rule_db_update()</a> Needs to invoke if precompiled rule database not provided in <a class="el" href="structrte__regexdev__config.html#a435e6efee66f679914216055cb537676">rte_regexdev_config::rule_db</a> for <a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a> and/or application needs to update rule database.</li>
<li><a class="el" href="rte__regexdev_8h.html#a081569d15e802854eebd83aadbabb52f">rte_regexdev_rule_db_compile_activate()</a> Needs to invoke if rte_regexdev_rule_db_update function was used.</li>
<li>Create or reuse exiting mempool for <em><a class="el" href="structrte__regex__ops.html">rte_regex_ops</a></em> objects.</li>
<li><a class="el" href="rte__regexdev_8h.html#af5a69925157b2995b170759f2d6c9a29">rte_regexdev_start()</a></li>
<li><a class="el" href="rte__regexdev_8h.html#a64ac4fed72c5d23e90fef9a9bcff994e">rte_regexdev_enqueue_burst()</a></li>
<li><a class="el" href="rte__regexdev_8h.html#acbf55cac92e6e1f3355243d6fd58e51c">rte_regexdev_dequeue_burst()</a> </li>
</ul>

<p class="definition">Definition in file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a95cabf0e76a2b8b2e93fdc4cee44fc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cabf0e76a2b8b2e93fdc4cee44fc97">&#9670;&nbsp;</a></span>RTE_REGEXDEV_CAPA_RUNTIME_COMPILATION_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_CAPA_RUNTIME_COMPILATION_F&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device does support compiling the rules at runtime unlike loading only the pre-built rule database using struct <a class="el" href="structrte__regexdev__config.html#a435e6efee66f679914216055cb537676">rte_regexdev_config::rule_db</a> in <a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a></p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__config.html#a435e6efee66f679914216055cb537676">rte_regexdev_config::rule_db</a>, <a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a> </dd>
<dd>
struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00281">281</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a3552ccca6c6cb2c996c9ca30ad8ba6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3552ccca6c6cb2c996c9ca30ad8ba6d6">&#9670;&nbsp;</a></span>RTE_REGEXDEV_CAPA_SUPP_PCRE_START_ANCHOR_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_CAPA_SUPP_PCRE_START_ANCHOR_F&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE Anchor to start of match flag. Example RegEx is <code>/\Gfoo\d/</code>. Here <code>\G</code> asserts position at the end of the previous match or the start of the string for the first match. This position will change each time the RegEx is applied to the subject string. If the RegEx is applied to <code>foo1foo2Zfoo3</code> the first two matches will be successful for <code>foo1foo2</code> and fail for <code>Zfoo3</code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00292">292</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="adc2ab524ea04a5611cacbbb5f17e1837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2ab524ea04a5611cacbbb5f17e1837">&#9670;&nbsp;</a></span>RTE_REGEXDEV_CAPA_SUPP_PCRE_ATOMIC_GROUPING_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_CAPA_SUPP_PCRE_ATOMIC_GROUPING_F&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE Atomic grouping. Atomic groups are represented by <code>(?&gt;)</code>. An atomic group is a group that, when the RegEx engine exits from it, automatically throws away all backtracking positions remembered by any tokens inside the group. Example RegEx is <code>a(?&gt;bc|b)c</code> if the given patterns are <code>abc</code> and <code>abcc</code> then <code>a(bc|b)c</code> matches both where as <code>a(?&gt;bc|b)c</code> matches only abcc because atomic groups don't allow backtracing back to <code>b</code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00304">304</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a9a664dc9ead5993c04f902247c67f6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a664dc9ead5993c04f902247c67f6ed">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_BACKTRACKING_CTRL_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_BACKTRACKING_CTRL_F&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE backtracking control verbs. Some examples of backtracing verbs are (*COMMIT), (*ACCEPT), (*FAIL), (*SKIP), (*PRUNE).</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00312">312</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a402c6b5b515ce58ee9461094de071e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402c6b5b515ce58ee9461094de071e58">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_CALLOUTS_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_CALLOUTS_F&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE callouts. PCRE supports calling external function in between matches by using <code>(?C)</code>. Example RegEx <code>ABC(?C)D</code> if a given patter is <code>ABCD</code> then the RegEx engine will parse ABC perform a userdefined callout and return a successful match at D.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00322">322</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="af25a7f4d669475bf9a103689a4c6ce00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25a7f4d669475bf9a103689a4c6ce00">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_BACKREFERENCE_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_BACKREFERENCE_F&#160;&#160;&#160;(1ULL &lt;&lt; 5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE backreference. Example RegEx is <code>(\2ABC|(GHI))+</code> <code>\2</code> matches the same text as most recently matched by the 2nd capturing group i.e. <code>GHI</code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00330">330</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a6b7332544e033cfd3a31898fd0cae8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7332544e033cfd3a31898fd0cae8f7">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_GREEDY_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_GREEDY_F&#160;&#160;&#160;(1ULL &lt;&lt; 6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE Greedy mode. For example if the RegEx is <code>AB\d*?</code> then <code>*?</code> represents zero or unlimited matches. In greedy mode the pattern <code>AB12345</code> will be matched completely where as the ungreedy mode <code>AB</code> will be returned as the match.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00339">339</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a67759e5654e9ebaa42330244acf660dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67759e5654e9ebaa42330244acf660dc">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_MATCH_ALL_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_MATCH_ALL_F&#160;&#160;&#160;(1ULL &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support match all mode. For example if the RegEx is <code>AB\d*?</code> then <code>*?</code> represents zero or unlimited matches. In match all mode the pattern <code>AB12345</code> will return 6 matches. AB, AB1, AB12, AB123, AB1234, AB12345.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00348">348</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="aca6247651f8e6fca542037968d36e98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6247651f8e6fca542037968d36e98e">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_LOOKAROUND_ASRT_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_LOOKAROUND_ASRT_F&#160;&#160;&#160;(1ULL &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE Lookaround assertions (Zero-width assertions). Example RegEx is <code>[a-z]+\d+(?=!{3,})</code> if the given pattern is <code>dwad1234!</code> the RegEx engine doesn't report any matches because the assert <code>(?=!{3,})</code> fails. The pattern <code>dwad123!!!</code> would return a successful match.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00358">358</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a3fd707d2bafbee6acab214044335f33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd707d2bafbee6acab214044335f33a">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_MATCH_POINT_RST_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_MATCH_POINT_RST_F&#160;&#160;&#160;(1ULL &lt;&lt; 9)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device doesn't support PCRE match point reset directive. Example RegEx is <code>[a-z]+\K\d+</code> if the pattern is <code>dwad123</code> then even though the entire pattern matches only <code>123</code> is reported as a match.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00367">367</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="adc6563dfc782fab948e3f1951c3ef7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6563dfc782fab948e3f1951c3ef7ce">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_NEWLINE_CONVENTIONS_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_NEWLINE_CONVENTIONS_F&#160;&#160;&#160;(1ULL &lt;&lt; 10)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx support PCRE newline convention. Newline conventions are represented as follows: (*CR) carriage return (*LF) linefeed (*CRLF) carriage return, followed by linefeed (*ANYCRLF) any of the three above (*ANY) all Unicode newline sequences</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00379">379</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a3cb0018df95cce8b2eef459b545cc159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb0018df95cce8b2eef459b545cc159">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_NEWLINE_SEQ_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_NEWLINE_SEQ_F&#160;&#160;&#160;(1ULL &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE newline sequence. The escape sequence <code>\R</code> will match any newline sequence. It is equivalent to: <code>(?&gt;\r\n|\n|\x0b|\f|\r|\x85)</code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00387">387</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="af760d04c907324501a6c87519cac3885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af760d04c907324501a6c87519cac3885">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_POSSESSIVE_QUALIFIERS_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_POSSESSIVE_QUALIFIERS_F&#160;&#160;&#160;(1ULL &lt;&lt; 12)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE possessive qualifiers. Example RegEx possessive qualifiers <code>*+</code>, <code>++</code>, <code>?+</code>, <code>{m,n}+</code>. Possessive quantifier repeats the token as many times as possible and it does not give up matches as the engine backtracks. With a possessive quantifier, the deal is all or nothing.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00397">397</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a06a8a7ea3cb7745ab2aa22f2d274e74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a8a7ea3cb7745ab2aa22f2d274e74b">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_SUBROUTINE_REFERENCES_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_SUBROUTINE_REFERENCES_F&#160;&#160;&#160;(1ULL &lt;&lt; 13)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support PCRE Subroutine references. PCRE Subroutine references allow for sub patterns to be assessed as part of the RegEx. Example RegEx is <code>(foo|fuzz)\g&lt;1&gt;+bar</code> matches the pattern <code>foofoofuzzfoofuzzbar</code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00406">406</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="ad134d9d21b4621a0e26132b20a2cc411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad134d9d21b4621a0e26132b20a2cc411">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_UTF_8_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_UTF_8_F&#160;&#160;&#160;(1ULL &lt;&lt; 14)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support UTF-8 character encoding.</p>
<dl class="section see"><dt>See also</dt><dd>struct rte_regexdev_info::pcre_unsup_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00412">412</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="adeccc52b39be29a616699c654d79640d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeccc52b39be29a616699c654d79640d">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_UTF_16_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_UTF_16_F&#160;&#160;&#160;(1ULL &lt;&lt; 15)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support UTF-16 character encoding.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00418">418</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a616b9b80b713093e969505e2b1a304cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616b9b80b713093e969505e2b1a304cc">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_UTF_32_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_UTF_32_F&#160;&#160;&#160;(1ULL &lt;&lt; 16)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support UTF-32 character encoding.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00424">424</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a7fcfff4eba009556f5fa14a0d0850f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcfff4eba009556f5fa14a0d0850f4b">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_WORD_BOUNDARY_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_WORD_BOUNDARY_F&#160;&#160;&#160;(1ULL &lt;&lt; 17)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support word boundaries. The meta character <code>\b</code> represents word boundary anchor.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00431">431</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a135890fff52d343155562f3da5f2de76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135890fff52d343155562f3da5f2de76">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_PCRE_FORWARD_REFERENCES_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_PCRE_FORWARD_REFERENCES_F&#160;&#160;&#160;(1ULL &lt;&lt; 18)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support Forward references. Forward references allow you to use a back reference to a group that appears later in the RegEx. Example RegEx is <code>(\3ABC|(DEF|(GHI)))+</code> matches the following string <code>GHIGHIABCDEF</code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00440">440</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a0842995aa689557eb7a1be5668c4f6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0842995aa689557eb7a1be5668c4f6be">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_MATCH_AS_END_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_MATCH_AS_END_F&#160;&#160;&#160;(1ULL &lt;&lt; 19)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support match as end. Match as end means that the match result holds the end offset of the detected match. No len value is set. If the device doesn't support this feature it means the match result holds the starting position of match and the length of the match.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00450">450</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a7c6b58e135c2a4c5960ae684cda0c227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6b58e135c2a4c5960ae684cda0c227">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_CROSS_BUFFER_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_CROSS_BUFFER_F&#160;&#160;&#160;(1ULL &lt;&lt; 20)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support cross buffer match. Cross buffer matching means that the match can be detected even if the string was started in previous buffer. In case the device is configured as RTE_REGEXDEV_CFG_MATCH_AS_END the end offset will be relative for the first packet. For example RegEx is ABC the first buffer is xxxx second buffer yyyA and the last buffer BCzz. In case the match as end is configured the end offset will be 10.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a1f78abc0552edb1fc45fb0c8dea42950">RTE_REGEXDEV_CFG_MATCH_AS_END_F</a> </dd>
<dd>
<a class="el" href="rte__regexdev_8h.html#abaf9301fb23e72f89547274512de358b">RTE_REGEXDEV_CFG_CROSS_BUFFER_SCAN_F</a> </dd>
<dd>
<a class="el" href="rte__regexdev_8h.html#a94bd7c37118a55ec625bc7796bd8bcdc">RTE_REGEX_OPS_RSP_PMI_SOJ_F</a> </dd>
<dd>
<a class="el" href="rte__regexdev_8h.html#a6010f7020140913b49841fd72ad06255">RTE_REGEX_OPS_RSP_PMI_EOJ_F</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00466">466</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="aa1203323b55c2302e245322cc7fadd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1203323b55c2302e245322cc7fadd8e">&#9670;&nbsp;</a></span>RTE_REGEXDEV_SUPP_MATCH_ALL_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_SUPP_MATCH_ALL_F&#160;&#160;&#160;(1ULL &lt;&lt; 21)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device support match all. Match all means that the RegEx engine will return all possible matches. For example, assume the RegEx is <code>A+b</code>, given the input AAAb the returned matches will be: Ab, AAb and AAAb.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a7ad8fc943e3ba539cdf8a62166d80c88">RTE_REGEXDEV_CFG_MATCH_ALL_F</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00475">475</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a5655b7482f78592dac636c34151c56c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5655b7482f78592dac636c34151c56c5">&#9670;&nbsp;</a></span>RTE_REGEXDEV_CAPA_QUEUE_PAIR_OOS_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_CAPA_QUEUE_PAIR_OOS_F&#160;&#160;&#160;(1ULL &lt;&lt; 22)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RegEx device supports out of order scan. Out of order scan means the response of a specific job can be returned as soon as it is ready even if previous jobs on the same queue didn't complete.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a242825bfbf30eab32f19539930a2b992">RTE_REGEX_QUEUE_PAIR_CFG_OOS_F</a> </dd>
<dd>
struct <a class="el" href="structrte__regexdev__info.html#a0eaeb5201f4b29a1876415c99cde6d87">rte_regexdev_info::regexdev_capa</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00484">484</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a385848182e0037043eddace45991cd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385848182e0037043eddace45991cd3c">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_ALLOW_EMPTY_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_ALLOW_EMPTY_F&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, the pattern that can match against an empty string, such as <code>.*</code> are allowed.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00493">493</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="ac09c1d7a0003403c8556c29a699cabdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09c1d7a0003403c8556c29a699cabdf">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_ANCHORED_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_ANCHORED_F&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, the pattern is forced to be "anchored", that is, it is constrained to match only at the first matching point in the string that is being searched. Similar to <code>^</code> and represented by <code>\A</code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00502">502</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a523eb523e324e78c5ff577921fa07890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523eb523e324e78c5ff577921fa07890">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_CASELESS_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_CASELESS_F&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, letters in the pattern match both upper and lower case letters in the subject.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00510">510</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="aa64e70a7505c6c3372df52cf81ba6eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64e70a7505c6c3372df52cf81ba6eee">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_DOTALL_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_DOTALL_F&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, a dot metacharacter in the pattern matches any character, including one that indicates a newline.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00518">518</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a0a31e33303103fd366ee8614580d8e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a31e33303103fd366ee8614580d8e0a">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_DUPNAMES_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_DUPNAMES_F&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, names used to identify capture groups need not be unique.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00526">526</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a0d497d59728f924d4def11abd4b2e523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d497d59728f924d4def11abd4b2e523">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_EXTENDED_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_EXTENDED_F&#160;&#160;&#160;(1ULL &lt;&lt; 5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00534">534</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a254b4f34b2fa3a3401e40fe2df7bf7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254b4f34b2fa3a3401e40fe2df7bf7b4">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_MATCH_UNSET_BACKREF_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_MATCH_UNSET_BACKREF_F&#160;&#160;&#160;(1ULL &lt;&lt; 6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, a backreference to an unset capture group matches an empty string.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00542">542</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a64ddaac7b6f1d07da9ffd635cd88e8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ddaac7b6f1d07da9ffd635cd88e8ba">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_MULTILINE_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_MULTILINE_F&#160;&#160;&#160;(1ULL &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, the <code>^</code> and <code>$</code> constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00551">551</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a695b65feeebf402f06a24aae07077743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695b65feeebf402f06a24aae07077743">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_NO_AUTO_CAPTURE_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_NO_AUTO_CAPTURE_F&#160;&#160;&#160;(1ULL &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this Flag is set, it disables the use of numbered capturing parentheses in the pattern. References to capture groups (backreferences or recursion/subroutine calls) may only refer to named groups, though the reference can be by name or by number.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00561">561</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a2077510bc486e17d3008b47845b18ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2077510bc486e17d3008b47845b18ac5">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_UCP_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_UCP_F&#160;&#160;&#160;(1ULL &lt;&lt; 9)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, only ASCII characters are recognized, When this flag is set, Unicode properties are used instead to classify characters.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00569">569</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a93336f9b543a2b1b3b78dac2e275e448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93336f9b543a2b1b3b78dac2e275e448">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_UNGREEDY_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_UNGREEDY_F&#160;&#160;&#160;(1ULL &lt;&lt; 10)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, the "greediness" of the quantifiers is inverted so that they are not greedy by default, but become greedy if followed by <code>?</code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00578">578</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a3ef9f14f41cfdfe2b8bb05ceae8ca67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef9f14f41cfdfe2b8bb05ceae8ca67d">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_UTF_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_UTF_F&#160;&#160;&#160;(1ULL &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When this flag is set, RegEx engine has to regard both the pattern and the subject strings that are subsequently processed as strings of UTF characters instead of single-code-unit strings.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00587">587</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a4a18d0d7996eef178fbc479c8ededefb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a18d0d7996eef178fbc479c8ededefb">&#9670;&nbsp;</a></span>RTE_REGEX_PCRE_RULE_NEVER_BACKSLASH_C_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_PCRE_RULE_NEVER_BACKSLASH_C_F&#160;&#160;&#160;(1ULL &lt;&lt; 12)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag locks out the use of <code>\C</code> in the pattern that is being compiled. This escape matches one data unit, even in UTF mode which can cause unpredictable behavior in UTF-8 or UTF-16 modes, because it may leave the current matching point in the mi:set hlsearchddle of a multi-code-unit character.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a3a4cc7383a941ba04a21e0cda4719536">rte_regexdev_info::rule_flags</a> </dd>
<dd>
struct rte_regexdev_rule::rule_flags </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00598">598</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="abaf9301fb23e72f89547274512de358b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf9301fb23e72f89547274512de358b">&#9670;&nbsp;</a></span>RTE_REGEXDEV_CFG_CROSS_BUFFER_SCAN_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_CFG_CROSS_BUFFER_SCAN_F&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross buffer scan refers to the ability to be able to detect matches that occur across buffer boundaries, where the buffers are related to each other in some way. Enable this flag when to scan payload size greater than struct <a class="el" href="structrte__regexdev__info.html#a8a92221435032fed25999f98ab3ce66f">rte_regexdev_info::max_payload_size</a> and/or matches can present across scan buffer boundaries.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__info.html#a8a92221435032fed25999f98ab3ce66f">rte_regexdev_info::max_payload_size</a> </dd>
<dd>
struct <a class="el" href="structrte__regexdev__config.html#afd9bca2aea83f80c2d1403a73b02f540">rte_regexdev_config::dev_cfg_flags</a>, <a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a> </dd>
<dd>
<a class="el" href="rte__regexdev_8h.html#a94bd7c37118a55ec625bc7796bd8bcdc">RTE_REGEX_OPS_RSP_PMI_SOJ_F</a> </dd>
<dd>
<a class="el" href="rte__regexdev_8h.html#a6010f7020140913b49841fd72ad06255">RTE_REGEX_OPS_RSP_PMI_EOJ_F</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00659">659</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a1f78abc0552edb1fc45fb0c8dea42950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f78abc0552edb1fc45fb0c8dea42950">&#9670;&nbsp;</a></span>RTE_REGEXDEV_CFG_MATCH_AS_END_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_CFG_MATCH_AS_END_F&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Match as end is the ability to return the result as ending offset. When this flag is set, the result for each match will hold the ending offset of the match in end_offset. If this flag is not set, then the match result will hold the starting offset in start_offset, and the length of the match in len.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a0842995aa689557eb7a1be5668c4f6be">RTE_REGEXDEV_SUPP_MATCH_AS_END_F</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00669">669</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a7ad8fc943e3ba539cdf8a62166d80c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad8fc943e3ba539cdf8a62166d80c88">&#9670;&nbsp;</a></span>RTE_REGEXDEV_CFG_MATCH_ALL_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_CFG_MATCH_ALL_F&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Match all is the ability to return all possible results.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#aa1203323b55c2302e245322cc7fadd8e">RTE_REGEXDEV_SUPP_MATCH_ALL_F</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00675">675</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a242825bfbf30eab32f19539930a2b992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242825bfbf30eab32f19539930a2b992">&#9670;&nbsp;</a></span>RTE_REGEX_QUEUE_PAIR_CFG_OOS_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_QUEUE_PAIR_CFG_OOS_F&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of order scan, If not set, a scan must retire after previously issued in-order scans to this queue pair. If set, this scan can be retired as soon as device returns completion. Application should not set out of order scan flag if it needs to maintain the ingress order of scan request.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regexdev__qp__conf.html#ab09d36997c5dbe2a73e442c1853555d8">rte_regexdev_qp_conf::qp_conf_flags</a> </dd>
<dd>
<a class="el" href="rte__regexdev_8h.html#a5c572edf58657370348881043bd64e3f">rte_regexdev_queue_pair_setup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00755">755</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="af728fe411ff5ebffb5a5d848db180628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af728fe411ff5ebffb5a5d848db180628">&#9670;&nbsp;</a></span>RTE_REGEXDEV_XSTATS_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEXDEV_XSTATS_NAME_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum name length for extended statistics counters </p>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01085">1085</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a7c47197f179ead4451e0715fe671eae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c47197f179ead4451e0715fe671eae0">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_REQ_GROUP_ID0_VALID_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_REQ_GROUP_ID0_VALID_F&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set when struct rte_regexdev_rule::group_id0 is valid. </p>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01275">1275</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a96cf588ab914c9fd0011158c4e21f75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cf588ab914c9fd0011158c4e21f75d">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_REQ_GROUP_ID1_VALID_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_REQ_GROUP_ID1_VALID_F&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set when struct rte_regexdev_rule::group_id1 is valid. </p>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01278">1278</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a0095e6381cf1cbba6c570df3fbad580b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0095e6381cf1cbba6c570df3fbad580b">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_REQ_GROUP_ID2_VALID_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_REQ_GROUP_ID2_VALID_F&#160;&#160;&#160;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set when struct rte_regexdev_rule::group_id2 is valid. </p>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01281">1281</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a7959bdf87696c1d22b40a9d6a1070890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7959bdf87696c1d22b40a9d6a1070890">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_REQ_GROUP_ID3_VALID_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_REQ_GROUP_ID3_VALID_F&#160;&#160;&#160;(1 &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set when struct rte_regexdev_rule::group_id3 is valid. </p>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01284">1284</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a724d4257e4ca795f34ae9d62463bb80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724d4257e4ca795f34ae9d62463bb80c">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_REQ_STOP_ON_MATCH_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_REQ_STOP_ON_MATCH_F&#160;&#160;&#160;(1 &lt;&lt; 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The RegEx engine will stop scanning and return the first match. </p>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01287">1287</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="af6993ab82b135442e61c198a30f8f127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6993ab82b135442e61c198a30f8f127">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_REQ_MATCH_HIGH_PRIORITY_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_REQ_MATCH_HIGH_PRIORITY_F&#160;&#160;&#160;(1 &lt;&lt; 5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In High Priority mode a maximum of one match will be returned per scan to reduce the post-processing required by the application. The match with the lowest Rule id, lowest start pointer and lowest match length will be returned.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__regex__ops.html#a43a1dc5ab061f100da4e15ce1be63753">rte_regex_ops::nb_actual_matches</a> </dd>
<dd>
struct <a class="el" href="structrte__regex__ops.html#a1389b277a00cb4c2fdc877d2739b0e65">rte_regex_ops::nb_matches</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01297">1297</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a94bd7c37118a55ec625bc7796bd8bcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bd7c37118a55ec625bc7796bd8bcdc">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_RSP_PMI_SOJ_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_RSP_PMI_SOJ_F&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the RegEx device has encountered a partial match at the start of scan in the given buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#abaf9301fb23e72f89547274512de358b">RTE_REGEXDEV_CFG_CROSS_BUFFER_SCAN_F</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01306">1306</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a6010f7020140913b49841fd72ad06255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6010f7020140913b49841fd72ad06255">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_RSP_PMI_EOJ_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_RSP_PMI_EOJ_F&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the RegEx device has encountered a partial match at the end of scan in the given buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#abaf9301fb23e72f89547274512de358b">RTE_REGEXDEV_CFG_CROSS_BUFFER_SCAN_F</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01313">1313</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a3fa905525ca43d735a786137f84e9f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa905525ca43d735a786137f84e9f49">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_RSP_MAX_SCAN_TIMEOUT_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_RSP_MAX_SCAN_TIMEOUT_F&#160;&#160;&#160;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the RegEx device has exceeded the max timeout while scanning the given buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461aa5d6060fa57310db2f0c7266866b58fc">RTE_REGEXDEV_ATTR_MAX_SCAN_TIMEOUT</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01320">1320</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="afd10c1b60ba64e2b058de4c8c3cc9931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd10c1b60ba64e2b058de4c8c3cc9931">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_RSP_MAX_MATCH_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_RSP_MAX_MATCH_F&#160;&#160;&#160;(1 &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the RegEx device has exceeded the max matches while scanning the given buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461aaca5501cfa9c0c7fe2b3ab14ab42762e">RTE_REGEXDEV_ATTR_MAX_MATCHES</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01327">1327</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="a85268bf7cbf316dce075a9cca6b21542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85268bf7cbf316dce075a9cca6b21542">&#9670;&nbsp;</a></span>RTE_REGEX_OPS_RSP_MAX_PREFIX_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_REGEX_OPS_RSP_MAX_PREFIX_F&#160;&#160;&#160;(1 &lt;&lt; 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the RegEx device has reached the max allowed prefix length while scanning the given buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461a04aaf59bad169e1aadf3996a546584d3">RTE_REGEXDEV_ATTR_MAX_PREFIX</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01334">1334</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab3d0c8a12442ce2008f72dd7d541efe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d0c8a12442ce2008f72dd7d541efe9">&#9670;&nbsp;</a></span>regexdev_stop_flush_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* regexdev_stop_flush_t) (uint8_t dev_id, uint16_t qp_id, struct <a class="el" href="structrte__regex__ops.html">rte_regex_ops</a> *op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function called during <a class="el" href="rte__regexdev_8h.html#a51bbcc1b0f4be720ae9cc048c4518089">rte_regexdev_stop()</a>, invoked once per flushed RegEx op. </p>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00758">758</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a67232fe9fd9dac49eb93b6acf9432461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67232fe9fd9dac49eb93b6acf9432461">&#9670;&nbsp;</a></span>rte_regexdev_attr_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461">rte_regexdev_attr_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates RegEx device attribute identifier </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a67232fe9fd9dac49eb93b6acf9432461a99cd36d2f600f62d49f37bd89f0ec604"></a>RTE_REGEXDEV_ATTR_SOCKET_ID&#160;</td><td class="fielddoc"><p>The NUMA socket id to which the device is connected or a default of zero if the socket could not be determined. datatype: <em>int</em> operation: <em>get</em> </p>
</td></tr>
<tr><td class="fieldname"><a id="a67232fe9fd9dac49eb93b6acf9432461aaca5501cfa9c0c7fe2b3ab14ab42762e"></a>RTE_REGEXDEV_ATTR_MAX_MATCHES&#160;</td><td class="fielddoc"><p>Maximum number of matches per scan. datatype: <em>uint8_t</em> operation: <em>get</em> and <em>set</em> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#afd10c1b60ba64e2b058de4c8c3cc9931">RTE_REGEX_OPS_RSP_MAX_MATCH_F</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a67232fe9fd9dac49eb93b6acf9432461aa5d6060fa57310db2f0c7266866b58fc"></a>RTE_REGEXDEV_ATTR_MAX_SCAN_TIMEOUT&#160;</td><td class="fielddoc"><p>Upper bound scan time in ns. datatype: <em>uint16_t</em> operation: <em>get</em> and <em>set</em> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a3fa905525ca43d735a786137f84e9f49">RTE_REGEX_OPS_RSP_MAX_SCAN_TIMEOUT_F</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a67232fe9fd9dac49eb93b6acf9432461a04aaf59bad169e1aadf3996a546584d3"></a>RTE_REGEXDEV_ATTR_MAX_PREFIX&#160;</td><td class="fielddoc"><p>Maximum number of prefix detected per scan. This would be useful for denial of service detection. datatype: <em>uint16_t</em> operation: <em>get</em> and <em>set</em> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#a85268bf7cbf316dce075a9cca6b21542">RTE_REGEX_OPS_RSP_MAX_PREFIX_F</a> </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00867">867</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="aca03004a398d840d510f14af95ba7093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca03004a398d840d510f14af95ba7093">&#9670;&nbsp;</a></span>rte_regexdev_rule_op</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__regexdev_8h.html#aca03004a398d840d510f14af95ba7093">rte_regexdev_rule_op</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates RegEx rule operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aca03004a398d840d510f14af95ba7093a329521e2395655de7d52f1382a88b025"></a>RTE_REGEX_RULE_OP_ADD&#160;</td><td class="fielddoc"><p>Add RegEx rule to rule database. </p>
</td></tr>
<tr><td class="fieldname"><a id="aca03004a398d840d510f14af95ba7093a6f4c872be26b168de15d479ca021096a"></a>RTE_REGEX_RULE_OP_REMOVE&#160;</td><td class="fielddoc"><p>Remove RegEx rule from rule database. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l00945">945</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af42fd6408904af61e84693f9554450fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42fd6408904af61e84693f9554450fe">&#9670;&nbsp;</a></span>rte_regexdev_is_valid_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_regexdev_is_valid_dev </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if dev_id is ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The dev identifier of the RegEx device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if device state is not in ready state.</li>
<li>1 if device state is ready state. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2481ae53ce4f22bcc0cc285df376d39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2481ae53ce4f22bcc0cc285df376d39a">&#9670;&nbsp;</a></span>rte_regexdev_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint8_t rte_regexdev_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Get the total number of RegEx devices that have been successfully initialised.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of usable RegEx devices. </dd></dl>

</div>
</div>
<a id="a342280d1e909d81b93a9559d370c9373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342280d1e909d81b93a9559d370c9373">&#9670;&nbsp;</a></span>rte_regexdev_get_dev_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_get_dev_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Get the device identifier for the named RegEx device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>RegEx device name to select the RegEx device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns RegEx device identifier on success.<ul>
<li>&lt;0: Failure to find named RegEx device. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3679aa5c2e6bdb87749d7b1398a5f4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3679aa5c2e6bdb87749d7b1398a5f4f7">&#9670;&nbsp;</a></span>rte_regexdev_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_info_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__regexdev__info.html">rte_regexdev_info</a> *&#160;</td>
          <td class="paramname"><em>dev_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve the contextual information of a RegEx device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__regexdev__info.html">rte_regexdev_info</a></em> to be filled with the contextual information of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the contextual information of the RegEx device</li>
<li>&lt;0: Error code returned by the driver info get function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad45418b9292bfb06c9e519a47acb18d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45418b9292bfb06c9e519a47acb18d3">&#9670;&nbsp;</a></span>rte_regexdev_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_configure </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__regexdev__config.html">rte_regexdev_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Configure a RegEx device.</p>
<p>This function must be invoked first before any other function in the API. This function can also be re-invoked when a device is in the stopped state.</p>
<p>The caller may use <a class="el" href="rte__regexdev_8h.html#a3679aa5c2e6bdb87749d7b1398a5f4f7">rte_regexdev_info_get()</a> to get the capability of each resources available for this regex device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">cfg</td><td>The RegEx device configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device configured. Otherwise negative errno is returned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5c572edf58657370348881043bd64e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c572edf58657370348881043bd64e3f">&#9670;&nbsp;</a></span>rte_regexdev_queue_pair_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_queue_pair_setup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_pair_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__regexdev__qp__conf.html">rte_regexdev_qp_conf</a> *&#160;</td>
          <td class="paramname"><em>qp_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Allocate and set up a RegEx queue pair for a RegEx device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_pair_id</td><td>The index of the RegEx queue pair to setup. The value must be in the range [0, nb_queue_pairs - 1] previously supplied to <a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a>. </td></tr>
    <tr><td class="paramname">qp_conf</td><td>The pointer to the configuration data to be used for the RegEx queue pair. NULL value is allowed, in which case default configuration used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Otherwise negative errno is returned. </dd></dl>

</div>
</div>
<a id="af5a69925157b2995b170759f2d6c9a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a69925157b2995b170759f2d6c9a29">&#9670;&nbsp;</a></span>rte_regexdev_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Start a RegEx device.</p>
<p>The device start step is the last one and consists of setting the RegEx queues to start accepting the pattern matching scan requests.</p>
<p>On success, all basic functions exported by the API (RegEx enqueue, RegEx dequeue and so on) can be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>RegEx device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Otherwise negative errno is returned. </dd></dl>

</div>
</div>
<a id="a51bbcc1b0f4be720ae9cc048c4518089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bbcc1b0f4be720ae9cc048c4518089">&#9670;&nbsp;</a></span>rte_regexdev_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_stop </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Stop a RegEx device.</p>
<p>Stop a RegEx device. The device can be restarted with a call to <a class="el" href="rte__regexdev_8h.html#af5a69925157b2995b170759f2d6c9a29">rte_regexdev_start()</a>.</p>
<p>This function causes all queued response regex ops to be drained in the response queue. While draining ops out of the device, struct <a class="el" href="structrte__regexdev__qp__conf.html#a3b78d4470c31f5365ab572ee2b85f49d">rte_regexdev_qp_conf::cb</a> will be invoked for each ops.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>RegEx device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Otherwise negative errno is returned. </dd></dl>

</div>
</div>
<a id="a19639c998e2df623edb92b664297ff6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19639c998e2df623edb92b664297ff6f">&#9670;&nbsp;</a></span>rte_regexdev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_close </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Close a RegEx device. The device cannot be restarted!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>RegEx device identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Otherwise negative errno is returned. </dd></dl>

</div>
</div>
<a id="ab43cb9763ff40d5947dafd1c3798750b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43cb9763ff40d5947dafd1c3798750b">&#9670;&nbsp;</a></span>rte_regexdev_attr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_attr_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461">rte_regexdev_attr_id</a>&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Get an attribute from a RegEx device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>RegEx device identifier. </td></tr>
    <tr><td class="paramname">attr_id</td><td>The attribute ID to retrieve. </td></tr>
    <tr><td class="paramname">attr_value</td><td>A pointer that will be filled in with the attribute value if successful.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully retrieved attribute value.</li>
<li>-EINVAL: Invalid device or <em>attr_id</em> provided, or <em>attr_value</em> is NULL.</li>
<li>-ENOTSUP: if the device doesn't support specific <em>attr_id</em>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aefbbd3146564c9db61a4d20c81792a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbbd3146564c9db61a4d20c81792a31">&#9670;&nbsp;</a></span>rte_regexdev_attr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_attr_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__regexdev_8h.html#a67232fe9fd9dac49eb93b6acf9432461">rte_regexdev_attr_id</a>&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Set an attribute to a RegEx device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>RegEx device identifier. </td></tr>
    <tr><td class="paramname">attr_id</td><td>The attribute ID to retrieve. </td></tr>
    <tr><td class="paramname">attr_value</td><td>Pointer that will be filled in with the attribute value by the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully applied the attribute value.</li>
<li>-EINVAL: Invalid device or <em>attr_id</em> provided, or <em>attr_value</em> is NULL.</li>
<li>-ENOTSUP: if the device doesn't support specific <em>attr_id</em>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab6d95cbad76491dba0f42d2131c03de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d95cbad76491dba0f42d2131c03de5">&#9670;&nbsp;</a></span>rte_regexdev_rule_db_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_rule_db_update </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__regexdev__rule.html">rte_regexdev_rule</a> *&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nb_rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Update the local rule set. This functions only modify the rule set in memory. In order for the changes to take effect, the function rte_regexdev_rule_db_compile_active must be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>RegEx device identifier. </td></tr>
    <tr><td class="paramname">rules</td><td>Points to an array of <em>nb_rules</em> objects of type <em><a class="el" href="structrte__regexdev__rule.html">rte_regexdev_rule</a></em> structure which contain the regex rules attributes to be updated in rule database. </td></tr>
    <tr><td class="paramname">nb_rules</td><td>The number of PCRE rules to update the rule database.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of regex rules actually updated on the regex device's rule database. The return value can be less than the value of the <em>nb_rules</em> parameter when the regex devices fails to update the rule database or if invalid parameters are specified in a <em><a class="el" href="structrte__regexdev__rule.html">rte_regexdev_rule</a></em>. If the return value is less than <em>nb_rules</em>, the remaining PCRE rules at the end of <em>rules</em> are not consumed and the caller has to take care of them and rte_errno is set accordingly. Possible errno values include:<ul>
<li>-EINVAL: Invalid device ID or rules is NULL</li>
<li>-ENOTSUP: The last processed rule is not supported on this device.</li>
<li>-ENOSPC: No space available in rule database.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#ab34a302ed3976da3aa37b7f8e0dffc62">rte_regexdev_rule_db_import()</a>, <a class="el" href="rte__regexdev_8h.html#a9bad8169dea5813efd1470bf0f275109">rte_regexdev_rule_db_export()</a>, <a class="el" href="rte__regexdev_8h.html#a081569d15e802854eebd83aadbabb52f">rte_regexdev_rule_db_compile_activate()</a> </dd></dl>

</div>
</div>
<a id="a081569d15e802854eebd83aadbabb52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081569d15e802854eebd83aadbabb52f">&#9670;&nbsp;</a></span>rte_regexdev_rule_db_compile_activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_rule_db_compile_activate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Compile local rule set and burn the complied result to the RegEx deive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>RegEx device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise negative errno.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#ab34a302ed3976da3aa37b7f8e0dffc62">rte_regexdev_rule_db_import()</a>, <a class="el" href="rte__regexdev_8h.html#a9bad8169dea5813efd1470bf0f275109">rte_regexdev_rule_db_export()</a>, <a class="el" href="rte__regexdev_8h.html#ab6d95cbad76491dba0f42d2131c03de5">rte_regexdev_rule_db_update()</a> </dd></dl>

</div>
</div>
<a id="ab34a302ed3976da3aa37b7f8e0dffc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34a302ed3976da3aa37b7f8e0dffc62">&#9670;&nbsp;</a></span>rte_regexdev_rule_db_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_rule_db_import </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rule_db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rule_db_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Import a prebuilt rule database from a buffer to a RegEx device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>RegEx device identifier. </td></tr>
    <tr><td class="paramname">rule_db</td><td>Points to prebuilt rule database. </td></tr>
    <tr><td class="paramname">rule_db_len</td><td>Length of the rule database.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully updated the prebuilt rule database.</li>
<li>-EINVAL: Invalid device ID or rule_db is NULL</li>
<li>-ENOTSUP: Rule database import is not supported on this device.</li>
<li>-ENOSPC: No space available in rule database.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#ab6d95cbad76491dba0f42d2131c03de5">rte_regexdev_rule_db_update()</a>, <a class="el" href="rte__regexdev_8h.html#a9bad8169dea5813efd1470bf0f275109">rte_regexdev_rule_db_export()</a> </dd></dl>

</div>
</div>
<a id="a9bad8169dea5813efd1470bf0f275109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bad8169dea5813efd1470bf0f275109">&#9670;&nbsp;</a></span>rte_regexdev_rule_db_export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_rule_db_export </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rule_db</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Export the prebuilt rule database from a RegEx device to the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>RegEx device identifier. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rule_db</td><td>Block of memory to insert the rule database. Must be at least size in capacity. If set to NULL, function returns required capacity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully exported the prebuilt rule database.</li>
<li>size: If rule_db set to NULL then required capacity for <em>rule_db</em></li>
<li>-EINVAL: Invalid device ID</li>
<li>-ENOTSUP: Rule database export is not supported on this device.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__regexdev_8h.html#ab6d95cbad76491dba0f42d2131c03de5">rte_regexdev_rule_db_update()</a>, <a class="el" href="rte__regexdev_8h.html#ab34a302ed3976da3aa37b7f8e0dffc62">rte_regexdev_rule_db_import()</a> </dd></dl>

</div>
</div>
<a id="a95207d3edcdf2bc2bf4a15ee68eeb751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95207d3edcdf2bc2bf4a15ee68eeb751">&#9670;&nbsp;</a></span>rte_regexdev_xstats_names_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_xstats_names_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__regexdev__xstats__map.html">rte_regexdev_xstats_map</a> *&#160;</td>
          <td class="paramname"><em>xstats_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve names of extended statistics of a regex device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the regex device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xstats_map</td><td>Block of memory to insert id and names into. Must be at least size in capacity. If set to NULL, function returns required capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Positive value on success: -The return value is the number of entries filled in the stats map. -If xstats_map set to NULL then required capacity for xstats_map.</li>
<li>Negative value on error: -ENODEV for invalid <em>dev_id</em> -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9569af148a1c7fd29d6f039f3fca3525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9569af148a1c7fd29d6f039f3fca3525">&#9670;&nbsp;</a></span>rte_regexdev_xstats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_xstats_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve extended statistics of an regex device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">ids</td><td>The id numbers of the stats to get. The ids can be got from the stat position in the stat list from <a class="el" href="rte__regexdev_8h.html#a95207d3edcdf2bc2bf4a15ee68eeb751">rte_regexdev_xstats_names_get()</a>, or by using <a class="el" href="rte__regexdev_8h.html#a97f64543b4468024b893eb341d34c7c9">rte_regexdev_xstats_by_name_get()</a>. </td></tr>
    <tr><td class="paramname">values</td><td>The values for each stats request by ID. </td></tr>
    <tr><td class="paramname">nb_values</td><td>The number of stats requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Positive value: number of stat entries filled into the values array</li>
<li>Negative value on error: -ENODEV for invalid <em>dev_id</em> -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a97f64543b4468024b893eb341d34c7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f64543b4468024b893eb341d34c7c9">&#9670;&nbsp;</a></span>rte_regexdev_xstats_by_name_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_xstats_by_name_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Retrieve the value of a single stat by requesting it by name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The stat name to retrieve. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>If non-NULL, the numerical id of the stat will be returned, so that further requests for the stat can be got using rte_regexdev_xstats_get, which will be faster as it doesn't need to scan a list of names for the stat. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Must be non-NULL, retrieved xstat value will be stored in this address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully retrieved xstat value.</li>
<li>-EINVAL: invalid parameters</li>
<li>-ENOTSUP: if not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a81051b7125d27b67188e12ce7acc1882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81051b7125d27b67188e12ce7acc1882">&#9670;&nbsp;</a></span>rte_regexdev_xstats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_xstats_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Reset the values of the xstats of the selected component in the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">ids</td><td>Selects specific statistics to be reset. When NULL, all statistics will be reset. If non-NULL, must point to array of at least <em>nb_ids</em> size. </td></tr>
    <tr><td class="paramname">nb_ids</td><td>The number of ids available from the <em>ids</em> array. Ignored when ids is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully reset the statistics to zero.</li>
<li>-EINVAL: invalid parameters.</li>
<li>-ENOTSUP: if not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a675332565a0036c53372823a96ae456e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675332565a0036c53372823a96ae456e">&#9670;&nbsp;</a></span>rte_regexdev_selftest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_selftest </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Trigger the RegEx device self test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Selftest successful.</li>
<li>-ENOTSUP if the device doesn't support selftest.</li>
<li>other values &lt; 0 on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a42684f89bc5a8f69d6b73f3dd95796fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42684f89bc5a8f69d6b73f3dd95796fc">&#9670;&nbsp;</a></span>rte_regexdev_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_regexdev_dump </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Dump internal information about <em>dev_id</em> to the FILE* provided in <em>f</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">f</td><td>A pointer to a file for output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a64ac4fed72c5d23e90fef9a9bcff994e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ac4fed72c5d23e90fef9a9bcff994e">&#9670;&nbsp;</a></span>rte_regexdev_enqueue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_regexdev_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>qp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__regex__ops.html">rte_regex_ops</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Enqueue a burst of scan request on a RegEx device.</p>
<p>The <a class="el" href="rte__regexdev_8h.html#a64ac4fed72c5d23e90fef9a9bcff994e">rte_regexdev_enqueue_burst()</a> function is invoked to place regex operations on the queue <em>qp_id</em> of the device designated by its <em>dev_id</em>.</p>
<p>The <em>nb_ops</em> parameter is the number of operations to process which are supplied in the <em>ops</em> array of <em>rte_regexdev_op</em> structures.</p>
<p>The <a class="el" href="rte__regexdev_8h.html#a64ac4fed72c5d23e90fef9a9bcff994e">rte_regexdev_enqueue_burst()</a> function returns the number of operations it actually enqueued for processing. A return value equal to <em>nb_ops</em> means that all packets have been enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">qp_id</td><td>The index of the queue pair which packets are to be enqueued for processing. The value must be in the range [0, nb_queue_pairs - 1] previously supplied to <a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a>. </td></tr>
    <tr><td class="paramname">ops</td><td>The address of an array of <em>nb_ops</em> pointers to <em>rte_regexdev_op</em> structures which contain the regex operations to be processed. </td></tr>
    <tr><td class="paramname">nb_ops</td><td>The number of operations to process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued on the regex device. The return value can be less than the value of the <em>nb_ops</em> parameter when the regex devices queue is full or if invalid parameters are specified in a <em>rte_regexdev_op</em>. If the return value is less than <em>nb_ops</em>, the remaining ops at the end of <em>ops</em> are not consumed and the caller has to take care of them. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01464">1464</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
<a id="acbf55cac92e6e1f3355243d6fd58e51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf55cac92e6e1f3355243d6fd58e51c">&#9670;&nbsp;</a></span>rte_regexdev_dequeue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_regexdev_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>qp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__regex__ops.html">rte_regex_ops</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice.</dd></dl>
<p>Dequeue a burst of scan response from a queue on the RegEx device. The dequeued operation are stored in <em>rte_regexdev_op</em> structures whose pointers are supplied in the <em>ops</em> array.</p>
<p>The <a class="el" href="rte__regexdev_8h.html#acbf55cac92e6e1f3355243d6fd58e51c">rte_regexdev_dequeue_burst()</a> function returns the number of ops actually dequeued, which is the number of <em>rte_regexdev_op</em> data structures effectively supplied into the <em>ops</em> array.</p>
<p>A return value equal to <em>nb_ops</em> indicates that the queue contained at least <em>nb_ops</em> operations, and this is likely to signify that other processed operations remain in the devices output queue. Applications implementing a "retrieve as many processed operations as possible" policy can check this specific case and keep invoking the <a class="el" href="rte__regexdev_8h.html#acbf55cac92e6e1f3355243d6fd58e51c">rte_regexdev_dequeue_burst()</a> function until a value less than <em>nb_ops</em> is returned.</p>
<p>The <a class="el" href="rte__regexdev_8h.html#acbf55cac92e6e1f3355243d6fd58e51c">rte_regexdev_dequeue_burst()</a> function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The RegEx device identifier </td></tr>
    <tr><td class="paramname">qp_id</td><td>The index of the queue pair from which to retrieve processed packets. The value must be in the range [0, nb_queue_pairs - 1] previously supplied to <a class="el" href="rte__regexdev_8h.html#ad45418b9292bfb06c9e519a47acb18d3">rte_regexdev_configure()</a>. </td></tr>
    <tr><td class="paramname">ops</td><td>The address of an array of pointers to <em>rte_regexdev_op</em> structures that must be large enough to store <em>nb_ops</em> pointers in it. </td></tr>
    <tr><td class="paramname">nb_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued, which is the number of pointers to <em>rte_regexdev_op</em> structures effectively supplied to the <em>ops</em> array. If the return value is less than <em>nb_ops</em>, the remaining ops at the end of <em>ops</em> are not consumed and the caller has to take care of them. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__regexdev_8h_source.html#l01523">1523</a> of file <a class="el" href="rte__regexdev_8h_source.html">rte_regexdev.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
