<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_ring/rte_ring.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_2154f83b08d9713661fee356762316ea.html">librte_ring</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_ring.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rte__ring__core_8h_source.html">rte_ring_core.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__ring__elem_8h_source.html">rte_ring_elem.h</a>&gt;</code><br />
</div>
<p><a href="rte__ring_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a124aceb72eee3d9a0aa653a5b6ce13d6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a124aceb72eee3d9a0aa653a5b6ce13d6">rte_ring_get_memsize</a> (unsigned int count)</td></tr>
<tr class="separator:a124aceb72eee3d9a0aa653a5b6ce13d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355835754cab24431cd4bbd320e59bd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a355835754cab24431cd4bbd320e59bd1">rte_ring_init</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, const char *name, unsigned int count, unsigned int flags)</td></tr>
<tr class="separator:a355835754cab24431cd4bbd320e59bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dece63653850041afd5c16d3d6e052"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#ae4dece63653850041afd5c16d3d6e052">rte_ring_create</a> (const char *name, unsigned int count, int socket_id, unsigned int flags)</td></tr>
<tr class="separator:ae4dece63653850041afd5c16d3d6e052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564e012c1eb4ae08f9eea3acfd08b377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a564e012c1eb4ae08f9eea3acfd08b377">rte_ring_free</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a564e012c1eb4ae08f9eea3acfd08b377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c464281266543ebc0766902467c69b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a09c464281266543ebc0766902467c69b">rte_ring_dump</a> (FILE *f, const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a09c464281266543ebc0766902467c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb91b9286b8fa4b962c8e01accd089b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#adb91b9286b8fa4b962c8e01accd089b9">rte_ring_mp_enqueue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned int n, unsigned int *free_space)</td></tr>
<tr class="separator:adb91b9286b8fa4b962c8e01accd089b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdfaae6cda589eb3b2a44c6a593c6a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aebdfaae6cda589eb3b2a44c6a593c6a5">rte_ring_sp_enqueue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned int n, unsigned int *free_space)</td></tr>
<tr class="separator:aebdfaae6cda589eb3b2a44c6a593c6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8debfb458e927d559e7ce750048502d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#ab8debfb458e927d559e7ce750048502d">rte_ring_enqueue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned int n, unsigned int *free_space)</td></tr>
<tr class="separator:ab8debfb458e927d559e7ce750048502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62960349fbeb3a8b685608d2b1a7d2b2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a62960349fbeb3a8b685608d2b1a7d2b2">rte_ring_mp_enqueue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *obj)</td></tr>
<tr class="separator:a62960349fbeb3a8b685608d2b1a7d2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7f172fbce0358e0b140fb9bd82aa7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#afd7f172fbce0358e0b140fb9bd82aa7a">rte_ring_sp_enqueue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *obj)</td></tr>
<tr class="separator:afd7f172fbce0358e0b140fb9bd82aa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e5c7ff81ee177734288a1698b1106e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aa1e5c7ff81ee177734288a1698b1106e">rte_ring_enqueue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *obj)</td></tr>
<tr class="separator:aa1e5c7ff81ee177734288a1698b1106e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503f3b4bad03df05f3e54fca463a659b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a503f3b4bad03df05f3e54fca463a659b">rte_ring_mc_dequeue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned int n, unsigned int *available)</td></tr>
<tr class="separator:a503f3b4bad03df05f3e54fca463a659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319f440dd465c84c14549bda92d65fb0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a319f440dd465c84c14549bda92d65fb0">rte_ring_sc_dequeue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned int n, unsigned int *available)</td></tr>
<tr class="separator:a319f440dd465c84c14549bda92d65fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558ff95b944832acf8de439c769638f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a558ff95b944832acf8de439c769638f3">rte_ring_dequeue_bulk</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned int n, unsigned int *available)</td></tr>
<tr class="separator:a558ff95b944832acf8de439c769638f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa879b5b00dc3ce5d423c17411054270a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aa879b5b00dc3ce5d423c17411054270a">rte_ring_mc_dequeue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_p)</td></tr>
<tr class="separator:aa879b5b00dc3ce5d423c17411054270a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a18b67229a569e0ad2fb1e5df70d2c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#ae8a18b67229a569e0ad2fb1e5df70d2c">rte_ring_sc_dequeue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_p)</td></tr>
<tr class="separator:ae8a18b67229a569e0ad2fb1e5df70d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896024f865225e243f2c66c02825a9e2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a896024f865225e243f2c66c02825a9e2">rte_ring_dequeue</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_p)</td></tr>
<tr class="separator:a896024f865225e243f2c66c02825a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaa3ea274086d9c6abdaf0c15dcdf90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#adbaa3ea274086d9c6abdaf0c15dcdf90">rte_ring_reset</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:adbaa3ea274086d9c6abdaf0c15dcdf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f9762abc6db3e0143ef33ce39c1a68"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a35f9762abc6db3e0143ef33ce39c1a68">rte_ring_count</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a35f9762abc6db3e0143ef33ce39c1a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373545f5ea25c26a0294b8d02554efbd"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a373545f5ea25c26a0294b8d02554efbd">rte_ring_free_count</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a373545f5ea25c26a0294b8d02554efbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06554a79e893291d4734507b3c599a21"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a06554a79e893291d4734507b3c599a21">rte_ring_full</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a06554a79e893291d4734507b3c599a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a7cda8ef5a62ee0a286c11d45d1bf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#abf9a7cda8ef5a62ee0a286c11d45d1bf">rte_ring_empty</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:abf9a7cda8ef5a62ee0a286c11d45d1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8adfaeefc2ce7bedc31aa7e41d17f9c"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aa8adfaeefc2ce7bedc31aa7e41d17f9c">rte_ring_get_size</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:aa8adfaeefc2ce7bedc31aa7e41d17f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e1b5610452f55f3f5a1ae02035f1e8"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aa5e1b5610452f55f3f5a1ae02035f1e8">rte_ring_get_capacity</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:aa5e1b5610452f55f3f5a1ae02035f1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2914024007350d4c278afb5d41c748"><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="rte__ring__core_8h.html#ac4ab714e4ca3d28c4850fe08cc958df1">rte_ring_sync_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#acb2914024007350d4c278afb5d41c748">rte_ring_get_prod_sync_type</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:acb2914024007350d4c278afb5d41c748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f6e9e56669930544a5b991e203abe6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a92f6e9e56669930544a5b991e203abe6">rte_ring_is_prod_single</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:a92f6e9e56669930544a5b991e203abe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd010b7d53e286ecb754a3b95a3f65c"><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="rte__ring__core_8h.html#ac4ab714e4ca3d28c4850fe08cc958df1">rte_ring_sync_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#abdd010b7d53e286ecb754a3b95a3f65c">rte_ring_get_cons_sync_type</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:abdd010b7d53e286ecb754a3b95a3f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d4c41836496b02d6a97d174df5ffcb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#aa1d4c41836496b02d6a97d174df5ffcb">rte_ring_is_cons_single</a> (const struct <a class="el" href="structrte__ring.html">rte_ring</a> *r)</td></tr>
<tr class="separator:aa1d4c41836496b02d6a97d174df5ffcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfcef0ad324fcc4c03bcb59cd7e867f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a7bfcef0ad324fcc4c03bcb59cd7e867f">rte_ring_list_dump</a> (FILE *f)</td></tr>
<tr class="separator:a7bfcef0ad324fcc4c03bcb59cd7e867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26dd65732f16f720eca5e1aa94e2a8a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#ad26dd65732f16f720eca5e1aa94e2a8a">rte_ring_lookup</a> (const char *name)</td></tr>
<tr class="separator:ad26dd65732f16f720eca5e1aa94e2a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d334902c9fb5460d026d380763da7e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a41d334902c9fb5460d026d380763da7e">rte_ring_mp_enqueue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned int n, unsigned int *free_space)</td></tr>
<tr class="separator:a41d334902c9fb5460d026d380763da7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459bb85fb1b34128531dce87f671f19b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a459bb85fb1b34128531dce87f671f19b">rte_ring_sp_enqueue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned int n, unsigned int *free_space)</td></tr>
<tr class="separator:a459bb85fb1b34128531dce87f671f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ad08ed07e2e485c94466e03bf252c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a85ad08ed07e2e485c94466e03bf252c4">rte_ring_enqueue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void *const *obj_table, unsigned int n, unsigned int *free_space)</td></tr>
<tr class="separator:a85ad08ed07e2e485c94466e03bf252c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f2dbf94a22d4b3aed6d2667bdb5df4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a55f2dbf94a22d4b3aed6d2667bdb5df4">rte_ring_mc_dequeue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned int n, unsigned int *available)</td></tr>
<tr class="separator:a55f2dbf94a22d4b3aed6d2667bdb5df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059fd217e14df1ae8ca8816c23ec1ce3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a059fd217e14df1ae8ca8816c23ec1ce3">rte_ring_sc_dequeue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned int n, unsigned int *available)</td></tr>
<tr class="separator:a059fd217e14df1ae8ca8816c23ec1ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd35643c4cdc6fa00ece3cafbcd94d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ring_8h.html#a9dd35643c4cdc6fa00ece3cafbcd94d2">rte_ring_dequeue_burst</a> (struct <a class="el" href="structrte__ring.html">rte_ring</a> *r, void **obj_table, unsigned int n, unsigned int *available)</td></tr>
<tr class="separator:a9dd35643c4cdc6fa00ece3cafbcd94d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Ring</p>
<p>The Ring Manager is a fixed-size queue, implemented as a table of pointers. Head and tail pointers are modified atomically, allowing concurrent access to it. It has the following features:</p>
<ul>
<li>FIFO (First In First Out)</li>
<li>Maximum size is fixed; the pointers are stored in a table.</li>
<li>Lockless implementation.</li>
<li>Multi- or single-consumer dequeue.</li>
<li>Multi- or single-producer enqueue.</li>
<li>Bulk dequeue.</li>
<li>Bulk enqueue.</li>
<li>Ability to select different sync modes for producer/consumer.</li>
<li>Dequeue start/finish (depending on consumer sync modes).</li>
<li>Enqueue start/finish (depending on producer sync mode).</li>
</ul>
<p>Note: the ring implementation is not preemptible. Refer to Programmer's guide/Environment Abstraction Layer/Multiple pthread/Known Issues/rte_ring for more information. </p>

<p class="definition">Definition in file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a124aceb72eee3d9a0aa653a5b6ce13d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124aceb72eee3d9a0aa653a5b6ce13d6">&#9670;&nbsp;</a></span>rte_ring_get_memsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rte_ring_get_memsize </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the memory size needed for a ring</p>
<p>This function returns the number of bytes needed for a ring, given the number of elements in it. This value is the sum of the size of the structure <a class="el" href="structrte__ring.html">rte_ring</a> and the size of the memory needed by the objects pointers. The value is aligned to a cache line size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of elements in the ring (must be a power of 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The memory size needed for the ring on success.</li>
<li>-EINVAL if count is not a power of 2. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a355835754cab24431cd4bbd320e59bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355835754cab24431cd4bbd320e59bd1">&#9670;&nbsp;</a></span>rte_ring_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_ring_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a ring structure.</p>
<p>Initialize a ring structure in memory pointed by "r". The size of the memory area must be large enough to store the ring structure and the object table. It is advised to use <a class="el" href="rte__ring_8h.html#a124aceb72eee3d9a0aa653a5b6ce13d6">rte_ring_get_memsize()</a> to get the appropriate size.</p>
<p>The ring size is set to <em>count</em>, which must be a power of two. Water marking is disabled by default. The real usable ring size is <em>count-1</em> instead of <em>count</em> to differentiate a free ring from an empty ring.</p>
<p>The ring is not added in RTE_TAILQ_RING global list. Indeed, the memory given by the caller may not be shareable among dpdk processes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The pointer to the ring structure followed by the objects table. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the ring. </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the ring (must be a power of 2). </td></tr>
    <tr><td class="paramname">flags</td><td>An OR of the following:<ul>
<li>One of mutually exclusive flags that define producer behavior:<ul>
<li>RING_F_SP_ENQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#aa1e5c7ff81ee177734288a1698b1106e">rte_ring_enqueue()</a></code> or <code><a class="el" href="rte__ring_8h.html#ab8debfb458e927d559e7ce750048502d">rte_ring_enqueue_bulk()</a></code> is "single-producer".</li>
<li>RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#aa1e5c7ff81ee177734288a1698b1106e">rte_ring_enqueue()</a></code> or <code><a class="el" href="rte__ring_8h.html#ab8debfb458e927d559e7ce750048502d">rte_ring_enqueue_bulk()</a></code> is "multi-producer RTS mode".</li>
<li>RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#aa1e5c7ff81ee177734288a1698b1106e">rte_ring_enqueue()</a></code> or <code><a class="el" href="rte__ring_8h.html#ab8debfb458e927d559e7ce750048502d">rte_ring_enqueue_bulk()</a></code> is "multi-producer HTS mode". If none of these flags is set, then default "multi-producer" behavior is selected.</li>
</ul>
</li>
<li>One of mutually exclusive flags that define consumer behavior:<ul>
<li>RING_F_SC_DEQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a896024f865225e243f2c66c02825a9e2">rte_ring_dequeue()</a></code> or <code><a class="el" href="rte__ring_8h.html#a558ff95b944832acf8de439c769638f3">rte_ring_dequeue_bulk()</a></code> is "single-consumer". Otherwise, it is "multi-consumers".</li>
<li>RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a896024f865225e243f2c66c02825a9e2">rte_ring_dequeue()</a></code> or <code><a class="el" href="rte__ring_8h.html#a558ff95b944832acf8de439c769638f3">rte_ring_dequeue_bulk()</a></code> is "multi-consumer RTS mode".</li>
<li>RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a896024f865225e243f2c66c02825a9e2">rte_ring_dequeue()</a></code> or <code><a class="el" href="rte__ring_8h.html#a558ff95b944832acf8de439c769638f3">rte_ring_dequeue_bulk()</a></code> is "multi-consumer HTS mode". If none of these flags is set, then default "multi-consumer" behavior is selected. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negative value on error. </dd></dl>

</div>
</div>
<a id="ae4dece63653850041afd5c16d3d6e052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dece63653850041afd5c16d3d6e052">&#9670;&nbsp;</a></span>rte_ring_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__ring.html">rte_ring</a>* rte_ring_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new ring named <em>name</em> in memory.</p>
<p>This function uses <code>memzone_reserve()</code> to allocate memory. Then it calls <a class="el" href="rte__ring_8h.html#a355835754cab24431cd4bbd320e59bd1">rte_ring_init()</a> to initialize an empty ring.</p>
<p>The new ring size is set to <em>count</em>, which must be a power of two. Water marking is disabled by default. The real usable ring size is <em>count-1</em> instead of <em>count</em> to differentiate a free ring from an empty ring.</p>
<p>The ring is added in RTE_TAILQ_RING list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the ring. </td></tr>
    <tr><td class="paramname">count</td><td>The size of the ring (must be a power of 2). </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>An OR of the following:<ul>
<li>One of mutually exclusive flags that define producer behavior:<ul>
<li>RING_F_SP_ENQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#aa1e5c7ff81ee177734288a1698b1106e">rte_ring_enqueue()</a></code> or <code><a class="el" href="rte__ring_8h.html#ab8debfb458e927d559e7ce750048502d">rte_ring_enqueue_bulk()</a></code> is "single-producer".</li>
<li>RING_F_MP_RTS_ENQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#aa1e5c7ff81ee177734288a1698b1106e">rte_ring_enqueue()</a></code> or <code><a class="el" href="rte__ring_8h.html#ab8debfb458e927d559e7ce750048502d">rte_ring_enqueue_bulk()</a></code> is "multi-producer RTS mode".</li>
<li>RING_F_MP_HTS_ENQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#aa1e5c7ff81ee177734288a1698b1106e">rte_ring_enqueue()</a></code> or <code><a class="el" href="rte__ring_8h.html#ab8debfb458e927d559e7ce750048502d">rte_ring_enqueue_bulk()</a></code> is "multi-producer HTS mode". If none of these flags is set, then default "multi-producer" behavior is selected.</li>
</ul>
</li>
<li>One of mutually exclusive flags that define consumer behavior:<ul>
<li>RING_F_SC_DEQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a896024f865225e243f2c66c02825a9e2">rte_ring_dequeue()</a></code> or <code><a class="el" href="rte__ring_8h.html#a558ff95b944832acf8de439c769638f3">rte_ring_dequeue_bulk()</a></code> is "single-consumer". Otherwise, it is "multi-consumers".</li>
<li>RING_F_MC_RTS_DEQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a896024f865225e243f2c66c02825a9e2">rte_ring_dequeue()</a></code> or <code><a class="el" href="rte__ring_8h.html#a558ff95b944832acf8de439c769638f3">rte_ring_dequeue_bulk()</a></code> is "multi-consumer RTS mode".</li>
<li>RING_F_MC_HTS_DEQ: If this flag is set, the default behavior when using <code><a class="el" href="rte__ring_8h.html#a896024f865225e243f2c66c02825a9e2">rte_ring_dequeue()</a></code> or <code><a class="el" href="rte__ring_8h.html#a558ff95b944832acf8de439c769638f3">rte_ring_dequeue_bulk()</a></code> is "multi-consumer HTS mode". If none of these flags is set, then default "multi-consumer" behavior is selected. </li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the pointer to the new allocated ring. NULL on error with rte_errno set appropriately. Possible errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to rte_config structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - count provided is not a power of 2</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a115">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2distributor_2main_8c-example.html#a65">examples/distributor/main.c</a>, <a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a51">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2ip_pipeline_2pipeline_8c-example.html#a4">examples/ip_pipeline/pipeline.c</a>, <a class="el" href="examples_2ip_pipeline_2swq_8c-example.html#a4">examples/ip_pipeline/swq.c</a>, <a class="el" href="examples_2ip_pipeline_2thread_8c-example.html#a7">examples/ip_pipeline/thread.c</a>, <a class="el" href="examples_2multi_process_2client_server_mp_2mp_server_2init_8c-example.html#a16">examples/multi_process/client_server_mp/mp_server/init.c</a>, <a class="el" href="examples_2multi_process_2simple_mp_2main_8c-example.html#a10">examples/multi_process/simple_mp/main.c</a>, <a class="el" href="examples_2packet_ordering_2main_8c-example.html#a55">examples/packet_ordering/main.c</a>, <a class="el" href="examples_2performance-thread_2common_2lthread_tls_8c-example.html#a3">examples/performance-thread/common/lthread_tls.c</a>, <a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a80">examples/performance-thread/l3fwd-thread/main.c</a>, <a class="el" href="examples_2pipeline_2thread_8c-example.html#a6">examples/pipeline/thread.c</a>, <a class="el" href="examples_2qos_sched_2init_8c-example.html#a38">examples/qos_sched/init.c</a>, and <a class="el" href="examples_2server_node_efd_2server_2init_8c-example.html#a22">examples/server_node_efd/server/init.c</a>.</dd>
</dl>

</div>
</div>
<a id="a564e012c1eb4ae08f9eea3acfd08b377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564e012c1eb4ae08f9eea3acfd08b377">&#9670;&nbsp;</a></span>rte_ring_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_ring_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-allocate all memory used by the ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Ring to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a95">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2ip_pipeline_2pipeline_8c-example.html#a7">examples/ip_pipeline/pipeline.c</a>, <a class="el" href="examples_2ip_pipeline_2swq_8c-example.html#a5">examples/ip_pipeline/swq.c</a>, <a class="el" href="examples_2ip_pipeline_2thread_8c-example.html#a4">examples/ip_pipeline/thread.c</a>, and <a class="el" href="examples_2pipeline_2thread_8c-example.html#a3">examples/pipeline/thread.c</a>.</dd>
</dl>

</div>
</div>
<a id="a09c464281266543ebc0766902467c69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c464281266543ebc0766902467c69b">&#9670;&nbsp;</a></span>rte_ring_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_ring_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of the ring to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb91b9286b8fa4b962c8e01accd089b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb91b9286b8fa4b962c8e01accd089b9">&#9670;&nbsp;</a></span>rte_ring_mp_enqueue_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_mp_enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>free_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on the ring (multi-producers safe).</p>
<p>This function uses a "compare and set" instruction to move the producer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
    <tr><td class="paramname">free_space</td><td>if non-NULL, returns the amount of space in the ring after the enqueue operation has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects enqueued, either 0 or n </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00213">213</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="aebdfaae6cda589eb3b2a44c6a593c6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdfaae6cda589eb3b2a44c6a593c6a5">&#9670;&nbsp;</a></span>rte_ring_sp_enqueue_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_sp_enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>free_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on a ring (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
    <tr><td class="paramname">free_space</td><td>if non-NULL, returns the amount of space in the ring after the enqueue operation has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects enqueued, either 0 or n </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2qos_sched_2app_thread_8c-example.html#a9">examples/qos_sched/app_thread.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00236">236</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="ab8debfb458e927d559e7ce750048502d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8debfb458e927d559e7ce750048502d">&#9670;&nbsp;</a></span>rte_ring_enqueue_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_enqueue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>free_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on a ring.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
    <tr><td class="paramname">free_space</td><td>if non-NULL, returns the amount of space in the ring after the enqueue operation has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects enqueued, either 0 or n </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2multi_process_2client_server_mp_2mp_server_2main_8c-example.html#a10">examples/multi_process/client_server_mp/mp_server/main.c</a>, and <a class="el" href="examples_2server_node_efd_2server_2main_8c-example.html#a9">examples/server_node_efd/server/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00263">263</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a62960349fbeb3a8b685608d2b1a7d2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62960349fbeb3a8b685608d2b1a7d2b2">&#9670;&nbsp;</a></span>rte_ring_mp_enqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_ring_mp_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue one object on a ring (multi-producers safe).</p>
<p>This function uses a "compare and set" instruction to move the producer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueued.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2performance-thread_2common_2lthread_tls_8c-example.html#a4">examples/performance-thread/common/lthread_tls.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00285">285</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="afd7f172fbce0358e0b140fb9bd82aa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7f172fbce0358e0b140fb9bd82aa7a">&#9670;&nbsp;</a></span>rte_ring_sp_enqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_ring_sp_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue one object on a ring (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueued.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ip_pipeline_2thread_8c-example.html#a15">examples/ip_pipeline/thread.c</a>, and <a class="el" href="examples_2pipeline_2thread_8c-example.html#a14">examples/pipeline/thread.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00302">302</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="aa1e5c7ff81ee177734288a1698b1106e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e5c7ff81ee177734288a1698b1106e">&#9670;&nbsp;</a></span>rte_ring_enqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_ring_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue one object on a ring.</p>
<p>This function calls the multi-producer or the single-producer version, depending on the default behaviour that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects enqueued.</li>
<li>-ENOBUFS: Not enough room in the ring to enqueue; no object is enqueued. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2multi_process_2simple_mp_2mp_commands_8c-example.html#a3">examples/multi_process/simple_mp/mp_commands.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00323">323</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a503f3b4bad03df05f3e54fca463a659b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503f3b4bad03df05f3e54fca463a659b">&#9670;&nbsp;</a></span>rte_ring_mc_dequeue_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_mc_dequeue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring (multi-consumers safe).</p>
<p>This function uses a "compare and set" instruction to move the consumer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
    <tr><td class="paramname">available</td><td>If non-NULL, returns the number of remaining ring entries after the dequeue has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects dequeued, either 0 or n </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00347">347</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a319f440dd465c84c14549bda92d65fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319f440dd465c84c14549bda92d65fb0">&#9670;&nbsp;</a></span>rte_ring_sc_dequeue_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_sc_dequeue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring (NOT multi-consumers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table, must be strictly positive. </td></tr>
    <tr><td class="paramname">available</td><td>If non-NULL, returns the number of remaining ring entries after the dequeue has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects dequeued, either 0 or n </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2qos_sched_2app_thread_8c-example.html#a13">examples/qos_sched/app_thread.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00371">371</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a558ff95b944832acf8de439c769638f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558ff95b944832acf8de439c769638f3">&#9670;&nbsp;</a></span>rte_ring_dequeue_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_dequeue_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behaviour that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
    <tr><td class="paramname">available</td><td>If non-NULL, returns the number of remaining ring entries after the dequeue has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects dequeued, either 0 or n </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a39">examples/server_node_efd/node/node.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00398">398</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="aa879b5b00dc3ce5d423c17411054270a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa879b5b00dc3ce5d423c17411054270a">&#9670;&nbsp;</a></span>rte_ring_mc_dequeue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_ring_mc_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue one object from a ring (multi-consumers safe).</p>
<p>This function uses a "compare and set" instruction to move the consumer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue; no object is dequeued. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2performance-thread_2common_2lthread_tls_8c-example.html#a6">examples/performance-thread/common/lthread_tls.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00421">421</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="ae8a18b67229a569e0ad2fb1e5df70d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a18b67229a569e0ad2fb1e5df70d2c">&#9670;&nbsp;</a></span>rte_ring_sc_dequeue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_ring_sc_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue one object from a ring (NOT multi-consumers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue, no object is dequeued. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ip_pipeline_2thread_8c-example.html#a16">examples/ip_pipeline/thread.c</a>, and <a class="el" href="examples_2pipeline_2thread_8c-example.html#a15">examples/pipeline/thread.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00439">439</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a896024f865225e243f2c66c02825a9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896024f865225e243f2c66c02825a9e2">&#9670;&nbsp;</a></span>rte_ring_dequeue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_ring_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue one object from a ring.</p>
<p>This function calls the multi-consumers or the single-consumer version depending on the default behaviour that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, objects dequeued.</li>
<li>-ENOENT: Not enough entries in the ring to dequeue, no object is dequeued. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2multi_process_2simple_mp_2main_8c-example.html#a4">examples/multi_process/simple_mp/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00461">461</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="adbaa3ea274086d9c6abdaf0c15dcdf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaa3ea274086d9c6abdaf0c15dcdf90">&#9670;&nbsp;</a></span>rte_ring_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_ring_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush a ring.</p>
<p>This function flush all the elements in a ring</p>
<dl class="section warning"><dt>Warning</dt><dd>Make sure the ring is not in use while calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35f9762abc6db3e0143ef33ce39c1a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f9762abc6db3e0143ef33ce39c1a68">&#9670;&nbsp;</a></span>rte_ring_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int rte_ring_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of entries in a ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the ring. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a41">examples/server_node_efd/node/node.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00489">489</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a373545f5ea25c26a0294b8d02554efbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373545f5ea25c26a0294b8d02554efbd">&#9670;&nbsp;</a></span>rte_ring_free_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int rte_ring_free_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of free entries in a ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of free entries in the ring. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00506">506</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a06554a79e893291d4734507b3c599a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06554a79e893291d4734507b3c599a21">&#9670;&nbsp;</a></span>rte_ring_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_full </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if a ring is full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The ring is full.</li>
<li>0: The ring is not full. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00521">521</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="abf9a7cda8ef5a62ee0a286c11d45d1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a7cda8ef5a62ee0a286c11d45d1bf">&#9670;&nbsp;</a></span>rte_ring_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if a ring is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The ring is empty.</li>
<li>0: The ring is not empty. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00536">536</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="aa8adfaeefc2ce7bedc31aa7e41d17f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8adfaeefc2ce7bedc31aa7e41d17f9c">&#9670;&nbsp;</a></span>rte_ring_get_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int rte_ring_get_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the size of the ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the data store used by the ring. NOTE: this is not the same as the usable space in the ring. To query that use <code><a class="el" href="rte__ring_8h.html#aa5e1b5610452f55f3f5a1ae02035f1e8">rte_ring_get_capacity()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00554">554</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="aa5e1b5610452f55f3f5a1ae02035f1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e1b5610452f55f3f5a1ae02035f1e8">&#9670;&nbsp;</a></span>rte_ring_get_capacity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int rte_ring_get_capacity </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of elements which can be stored in the ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The usable size of the ring. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00568">568</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="acb2914024007350d4c278afb5d41c748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2914024007350d4c278afb5d41c748">&#9670;&nbsp;</a></span>rte_ring_get_prod_sync_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="rte__ring__core_8h.html#ac4ab714e4ca3d28c4850fe08cc958df1">rte_ring_sync_type</a> rte_ring_get_prod_sync_type </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return sync type used by producer in the ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Producer sync type value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00568">568</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a92f6e9e56669930544a5b991e203abe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f6e9e56669930544a5b991e203abe6">&#9670;&nbsp;</a></span>rte_ring_is_prod_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_is_prod_single </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check is the ring for single producer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if ring is SP, zero otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00596">596</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="abdd010b7d53e286ecb754a3b95a3f65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd010b7d53e286ecb754a3b95a3f65c">&#9670;&nbsp;</a></span>rte_ring_get_cons_sync_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="rte__ring__core_8h.html#ac4ab714e4ca3d28c4850fe08cc958df1">rte_ring_sync_type</a> rte_ring_get_cons_sync_type </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return sync type used by consumer in the ring.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Consumer sync type value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00596">596</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="aa1d4c41836496b02d6a97d174df5ffcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d4c41836496b02d6a97d174df5ffcb">&#9670;&nbsp;</a></span>rte_ring_is_cons_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_ring_is_cons_single </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check is the ring for single consumer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if ring is SC, zero otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00624">624</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a7bfcef0ad324fcc4c03bcb59cd7e867f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfcef0ad324fcc4c03bcb59cd7e867f">&#9670;&nbsp;</a></span>rte_ring_list_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_ring_list_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of all rings on the console</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad26dd65732f16f720eca5e1aa94e2a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26dd65732f16f720eca5e1aa94e2a8a">&#9670;&nbsp;</a></span>rte_ring_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__ring.html">rte_ring</a>* rte_ring_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search a ring from its name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the ring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the ring matching the name, or NULL if not found, with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - required entry not available to return. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a16">examples/multi_process/client_server_mp/mp_client/client.c</a>, <a class="el" href="examples_2multi_process_2simple_mp_2main_8c-example.html#a13">examples/multi_process/simple_mp/main.c</a>, <a class="el" href="examples_2qos_sched_2init_8c-example.html#a37">examples/qos_sched/init.c</a>, and <a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a33">examples/server_node_efd/node/node.c</a>.</dd>
</dl>

</div>
</div>
<a id="a41d334902c9fb5460d026d380763da7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d334902c9fb5460d026d380763da7e">&#9670;&nbsp;</a></span>rte_ring_mp_enqueue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_mp_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>free_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on the ring (multi-producers safe).</p>
<p>This function uses a "compare and set" instruction to move the producer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
    <tr><td class="paramname">free_space</td><td>if non-NULL, returns the amount of space in the ring after the enqueue operation has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects enqueued. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00668">668</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a459bb85fb1b34128531dce87f671f19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459bb85fb1b34128531dce87f671f19b">&#9670;&nbsp;</a></span>rte_ring_sp_enqueue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_sp_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>free_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on a ring (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
    <tr><td class="paramname">free_space</td><td>if non-NULL, returns the amount of space in the ring after the enqueue operation has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects enqueued. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a76">examples/performance-thread/l3fwd-thread/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00691">691</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a85ad08ed07e2e485c94466e03bf252c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ad08ed07e2e485c94466e03bf252c4">&#9670;&nbsp;</a></span>rte_ring_enqueue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>free_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue several objects on a ring.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the ring from the obj_table. </td></tr>
    <tr><td class="paramname">free_space</td><td>if non-NULL, returns the amount of space in the ring after the enqueue operation has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects enqueued. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a70">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2distributor_2main_8c-example.html#a42">examples/distributor/main.c</a>, <a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a28">examples/ioat/ioatfwd.c</a>, and <a class="el" href="examples_2packet_ordering_2main_8c-example.html#a41">examples/packet_ordering/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00718">718</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a55f2dbf94a22d4b3aed6d2667bdb5df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f2dbf94a22d4b3aed6d2667bdb5df4">&#9670;&nbsp;</a></span>rte_ring_mc_dequeue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_mc_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring (multi-consumers safe). When the request objects are more than the available objects, only dequeue the actual number of objects</p>
<p>This function uses a "compare and set" instruction to move the consumer index atomically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
    <tr><td class="paramname">available</td><td>If non-NULL, returns the number of remaining ring entries after the dequeue has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects dequeued, 0 if ring is empty </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00746">746</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a059fd217e14df1ae8ca8816c23ec1ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059fd217e14df1ae8ca8816c23ec1ce3">&#9670;&nbsp;</a></span>rte_ring_sc_dequeue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_sc_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue several objects from a ring (NOT multi-consumers safe).When the request objects are more than the available objects, only dequeue the actual number of objects</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
    <tr><td class="paramname">available</td><td>If non-NULL, returns the number of remaining ring entries after the dequeue has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>n: Actual number of objects dequeued, 0 if ring is empty </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a74">examples/performance-thread/l3fwd-thread/main.c</a>, and <a class="el" href="examples_2qos_sched_2app_thread_8c-example.html#a14">examples/qos_sched/app_thread.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00771">771</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
<a id="a9dd35643c4cdc6fa00ece3cafbcd94d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd35643c4cdc6fa00ece3cafbcd94d2">&#9670;&nbsp;</a></span>rte_ring_dequeue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> unsigned int rte_ring_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__ring.html">rte_ring</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue multiple objects from a ring up to a maximum number.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behaviour that was specified at ring creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A pointer to the ring structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to dequeue from the ring to the obj_table. </td></tr>
    <tr><td class="paramname">available</td><td>If non-NULL, returns the number of remaining ring entries after the dequeue has finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Number of objects dequeued </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a72">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2distributor_2main_8c-example.html#a47">examples/distributor/main.c</a>, <a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a30">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a21">examples/multi_process/client_server_mp/mp_client/client.c</a>, and <a class="el" href="examples_2packet_ordering_2main_8c-example.html#a44">examples/packet_ordering/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__ring_8h_source.html#l00798">798</a> of file <a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
