<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_eventdev/rte_event_timer_adapter.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_9b3d03c4eb61cec62b5319e654017f5d.html">librte_eventdev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_event_timer_adapter.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rte__spinlock_8h_source.html">rte_spinlock.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rte__eventdev__trace__fp_8h_source.html">rte_eventdev_trace_fp.h</a>&quot;</code><br />
</div>
<p><a href="rte__event__timer__adapter_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__timer__adapter__conf.html">rte_event_timer_adapter_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__timer__adapter__stats.html">rte_event_timer_adapter_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__timer__adapter__info.html">rte_event_timer_adapter_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__timer.html">rte_event_timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5df887dddf1e34dd0e9faacb76abcda5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a5df887dddf1e34dd0e9faacb76abcda5">RTE_EVENT_TIMER_ADAPTER_F_ADJUST_RES</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:a5df887dddf1e34dd0e9faacb76abcda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32ac29ca5674cc6573a6c79f7c8c5bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#ae32ac29ca5674cc6573a6c79f7c8c5bc">RTE_EVENT_TIMER_ADAPTER_F_SP_PUT</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:ae32ac29ca5674cc6573a6c79f7c8c5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3c1efabfac7c38181e4f1bb8d732fd23"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a3c1efabfac7c38181e4f1bb8d732fd23">rte_event_timer_adapter_port_conf_cb_t</a>) (uint16_t id, uint8_t event_dev_id, uint8_t *event_port_id, void *conf_arg)</td></tr>
<tr class="separator:a3c1efabfac7c38181e4f1bb8d732fd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9fd5df53756805b093928da42cc84da9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a9fd5df53756805b093928da42cc84da9">rte_event_timer_adapter_clk_src</a> { <br />
&#160;&#160;<a class="el" href="rte__event__timer__adapter_8h.html#a9fd5df53756805b093928da42cc84da9a97700ac3fa74d00342d3d5fbd72969f8">RTE_EVENT_TIMER_ADAPTER_CPU_CLK</a>, 
<a class="el" href="rte__event__timer__adapter_8h.html#a9fd5df53756805b093928da42cc84da9aee26ed3b5b047a1f906fb6119a4b0b08">RTE_EVENT_TIMER_ADAPTER_EXT_CLK0</a>, 
<a class="el" href="rte__event__timer__adapter_8h.html#a9fd5df53756805b093928da42cc84da9a5b2918eed15299ee7f34e4d2f8f16e7c">RTE_EVENT_TIMER_ADAPTER_EXT_CLK1</a>, 
<a class="el" href="rte__event__timer__adapter_8h.html#a9fd5df53756805b093928da42cc84da9adeffb4f41fef4a18ea70b2cd5d7c934a">RTE_EVENT_TIMER_ADAPTER_EXT_CLK2</a>, 
<br />
&#160;&#160;<a class="el" href="rte__event__timer__adapter_8h.html#a9fd5df53756805b093928da42cc84da9ae7f827ed3b33efff5a5566439f8fb448">RTE_EVENT_TIMER_ADAPTER_EXT_CLK3</a>
<br />
 }</td></tr>
<tr class="separator:a9fd5df53756805b093928da42cc84da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1053a05c662ebf7100f03cb2dd8eb85a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a1053a05c662ebf7100f03cb2dd8eb85a">rte_event_timer_state</a> { <br />
&#160;&#160;<a class="el" href="rte__event__timer__adapter_8h.html#a1053a05c662ebf7100f03cb2dd8eb85aaa8266f476e8b90d64a5583baa5793648">RTE_EVENT_TIMER_NOT_ARMED</a> = 0, 
<a class="el" href="rte__event__timer__adapter_8h.html#a1053a05c662ebf7100f03cb2dd8eb85aa6092248b8e82de3b7aab0e77d3f28f8d">RTE_EVENT_TIMER_ARMED</a> = 1, 
<a class="el" href="rte__event__timer__adapter_8h.html#a1053a05c662ebf7100f03cb2dd8eb85aa93727db8d56b3ef71506b46c72e202eb">RTE_EVENT_TIMER_CANCELED</a> = 2, 
<a class="el" href="rte__event__timer__adapter_8h.html#a1053a05c662ebf7100f03cb2dd8eb85aa991c74cca13be76619169aab023ac55a">RTE_EVENT_TIMER_ERROR</a> = -1, 
<br />
&#160;&#160;<a class="el" href="rte__event__timer__adapter_8h.html#a1053a05c662ebf7100f03cb2dd8eb85aa4d17b993377dd7e4c4fb1c1f6dbb9e2e">RTE_EVENT_TIMER_ERROR_TOOEARLY</a> = -2, 
<a class="el" href="rte__event__timer__adapter_8h.html#a1053a05c662ebf7100f03cb2dd8eb85aabe3e7ba55d87d1217d041bc6f638c971">RTE_EVENT_TIMER_ERROR_TOOLATE</a> = -3
<br />
 }</td></tr>
<tr class="separator:a1053a05c662ebf7100f03cb2dd8eb85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0267328b1ae6ea8ff8cc9bf4ff39b641"><td class="memItemLeft" align="right" valign="top">struct rte_event_timer_adapter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a0267328b1ae6ea8ff8cc9bf4ff39b641">rte_event_timer_adapter_create</a> (const struct <a class="el" href="structrte__event__timer__adapter__conf.html">rte_event_timer_adapter_conf</a> *conf)</td></tr>
<tr class="separator:a0267328b1ae6ea8ff8cc9bf4ff39b641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626ef2a7bfbdc949c817a40e0287373c"><td class="memItemLeft" align="right" valign="top">struct rte_event_timer_adapter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a626ef2a7bfbdc949c817a40e0287373c">rte_event_timer_adapter_create_ext</a> (const struct <a class="el" href="structrte__event__timer__adapter__conf.html">rte_event_timer_adapter_conf</a> *conf, <a class="el" href="rte__event__timer__adapter_8h.html#a3c1efabfac7c38181e4f1bb8d732fd23">rte_event_timer_adapter_port_conf_cb_t</a> conf_cb, void *conf_arg)</td></tr>
<tr class="separator:a626ef2a7bfbdc949c817a40e0287373c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce42b431be91f89139b083438ee94d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#adce42b431be91f89139b083438ee94d5">rte_event_timer_adapter_get_info</a> (const struct rte_event_timer_adapter *adapter, struct <a class="el" href="structrte__event__timer__adapter__info.html">rte_event_timer_adapter_info</a> *adapter_info)</td></tr>
<tr class="separator:adce42b431be91f89139b083438ee94d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6871577f075b250188f7444afc3091b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#ab6871577f075b250188f7444afc3091b">rte_event_timer_adapter_start</a> (const struct rte_event_timer_adapter *adapter)</td></tr>
<tr class="separator:ab6871577f075b250188f7444afc3091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b33505308246e1719354c11ec998d06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a1b33505308246e1719354c11ec998d06">rte_event_timer_adapter_stop</a> (const struct rte_event_timer_adapter *adapter)</td></tr>
<tr class="separator:a1b33505308246e1719354c11ec998d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7803143848595dd1f9192989b4610aa5"><td class="memItemLeft" align="right" valign="top">struct rte_event_timer_adapter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a7803143848595dd1f9192989b4610aa5">rte_event_timer_adapter_lookup</a> (uint16_t adapter_id)</td></tr>
<tr class="separator:a7803143848595dd1f9192989b4610aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3b19eec57ce45f87c473d3822889c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a5e3b19eec57ce45f87c473d3822889c2">rte_event_timer_adapter_free</a> (struct rte_event_timer_adapter *adapter)</td></tr>
<tr class="separator:a5e3b19eec57ce45f87c473d3822889c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebfc421d971d680826236daf90b1f3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a0ebfc421d971d680826236daf90b1f3d">rte_event_timer_adapter_service_id_get</a> (struct rte_event_timer_adapter *adapter, uint32_t *service_id)</td></tr>
<tr class="separator:a0ebfc421d971d680826236daf90b1f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e5fc21680c067767bb14ba8a57ee92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#aa5e5fc21680c067767bb14ba8a57ee92">rte_event_timer_adapter_stats_get</a> (struct rte_event_timer_adapter *adapter, struct <a class="el" href="structrte__event__timer__adapter__stats.html">rte_event_timer_adapter_stats</a> *stats)</td></tr>
<tr class="separator:aa5e5fc21680c067767bb14ba8a57ee92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9ac31355595f9c00189502dc107a6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a0b9ac31355595f9c00189502dc107a6b">rte_event_timer_adapter_stats_reset</a> (struct rte_event_timer_adapter *adapter)</td></tr>
<tr class="separator:a0b9ac31355595f9c00189502dc107a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54242cd4a7bb6664f6c80e86a05d0fa8"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a54242cd4a7bb6664f6c80e86a05d0fa8">rte_event_timer_arm_burst</a> (const struct rte_event_timer_adapter *adapter, struct <a class="el" href="structrte__event__timer.html">rte_event_timer</a> **evtims, uint16_t nb_evtims)</td></tr>
<tr class="separator:a54242cd4a7bb6664f6c80e86a05d0fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6799c8a7911bdf615330078500fd058"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#ad6799c8a7911bdf615330078500fd058">rte_event_timer_arm_tmo_tick_burst</a> (const struct rte_event_timer_adapter *adapter, struct <a class="el" href="structrte__event__timer.html">rte_event_timer</a> **evtims, const uint64_t timeout_ticks, const uint16_t nb_evtims)</td></tr>
<tr class="separator:ad6799c8a7911bdf615330078500fd058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ea97c2c4ca7c633a6ab0b747d785a5"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__event__timer__adapter_8h.html#a45ea97c2c4ca7c633a6ab0b747d785a5">rte_event_timer_cancel_burst</a> (const struct rte_event_timer_adapter *adapter, struct <a class="el" href="structrte__event__timer.html">rte_event_timer</a> **evtims, uint16_t nb_evtims)</td></tr>
<tr class="separator:a45ea97c2c4ca7c633a6ab0b747d785a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Event Timer Adapter</p>
<p>An event timer adapter has the following abstract working model: </p><pre class="fragment">                          timer_tick_ns
                              +
                 +-------+    |
                 |       |    |
         +-------+ bkt 0 +----v---+
         |       |       |        |
         |       +-------+        |
     +---+---+                +---+---+  +---+---+---+---+
     |       |                |       |  |   |   |   |   |
     | bkt n |                | bkt 1 |&lt;-&gt; t0| t1| t2| tn|
     |       |                |       |  |   |   |   |   |
     +---+---+                +---+---+  +---+---+---+---+
         |     Timer adapter      |
     +---+---+                +---+---+
     |       |                |       |
     | bkt 4 |                | bkt 2 |&lt;--- Current bucket
     |       |                |       |
     +---+---+                +---+---+
          |      +-------+       |
          |      |       |       |
          +------+ bkt 3 +-------+
                 |       |
                 +-------+
</pre><ul>
<li>It has a virtual monotonically increasing 64-bit timer adapter clock based on <em>enum rte_event_timer_adapter_clk_src</em> clock source. The clock source could be a CPU clock, or a platform dependent external clock.</li>
<li>The application creates a timer adapter instance with given the clock source, the total number of event timers, and a resolution(expressed in ns) to traverse between the buckets.</li>
<li>Each timer adapter may have 0 to n buckets based on the configured max timeout(max_tmo_ns) and resolution(timer_tick_ns). Upon starting the timer adapter, the adapter starts ticking at <em>timer_tick_ns</em> resolution.</li>
<li>The application arms an event timer that will expire <em>timer_tick_ns</em> from now.</li>
<li>The application can cancel an armed timer and no timer expiry event will be generated.</li>
<li>If a timer expires then the library injects the timer expiry event in the designated event queue.</li>
<li>The timer expiry event will be received through <em>rte_event_dequeue_burst</em>.</li>
<li>The application frees the timer adapter instance.</li>
</ul>
<p>Multiple timer adapters can be created with a varying level of resolution for various expiry use cases that run in parallel.</p>
<p>Before using the timer adapter, the application has to create and configure an event device along with the event port. Based on the event device capability it might require creating an additional event port to be used by the timer adapter.</p>
<p>The application creates the event timer adapter using the <code><a class="el" href="rte__event__timer__adapter_8h.html#a0267328b1ae6ea8ff8cc9bf4ff39b641">rte_event_timer_adapter_create()</a></code>. The event device id is passed to this function, inside this function the event device capability is checked, and if an in-built port is absent the application uses the default function to create a new producer port.</p>
<p>The application may also use the function <code><a class="el" href="rte__event__timer__adapter_8h.html#a626ef2a7bfbdc949c817a40e0287373c">rte_event_timer_adapter_create_ext()</a></code> to have granular control over producer port creation in a case where the in-built port is absent.</p>
<p>After creating the timer adapter, the application has to start it using <code><a class="el" href="rte__event__timer__adapter_8h.html#ab6871577f075b250188f7444afc3091b">rte_event_timer_adapter_start()</a></code>. The buckets are traversed from 0 to n; when the adapter ticks, the next bucket is visited. Each time, the list per bucket is processed, and timer expiry events are sent to the designated event queue.</p>
<p>The application can arm one or more event timers using the <code><a class="el" href="rte__event__timer__adapter_8h.html#a54242cd4a7bb6664f6c80e86a05d0fa8">rte_event_timer_arm_burst()</a></code>. The <em>timeout_ticks</em> represents the number of <em>timer_tick_ns</em> after which the timer has to expire. The timeout at which the timers expire can be grouped or be independent of each event timer instance. <code><a class="el" href="rte__event__timer__adapter_8h.html#ad6799c8a7911bdf615330078500fd058">rte_event_timer_arm_tmo_tick_burst()</a></code> addresses the former case and <code><a class="el" href="rte__event__timer__adapter_8h.html#a54242cd4a7bb6664f6c80e86a05d0fa8">rte_event_timer_arm_burst()</a></code> addresses the latter case.</p>
<p>The application can cancel the timers from expiring using the <code><a class="el" href="rte__event__timer__adapter_8h.html#a45ea97c2c4ca7c633a6ab0b747d785a5">rte_event_timer_cancel_burst()</a></code>.</p>
<p>On the secondary process, <code><a class="el" href="rte__event__timer__adapter_8h.html#a7803143848595dd1f9192989b4610aa5">rte_event_timer_adapter_lookup()</a></code> can be used to get the timer adapter pointer from its id and use it to invoke fastpath operations such as arm and cancel.</p>
<p>Some of the use cases of event timer adapter are Beacon Timers, Generic SW Timeout, Wireless MAC Scheduling, 3G Frame Protocols, Packet Scheduling, Protocol Retransmission Timers, Supervision Timers. All these use cases require high resolution and low time drift. </p>

<p class="definition">Definition in file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5df887dddf1e34dd0e9faacb76abcda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df887dddf1e34dd0e9faacb76abcda5">&#9670;&nbsp;</a></span>RTE_EVENT_TIMER_ADAPTER_F_ADJUST_RES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TIMER_ADAPTER_F_ADJUST_RES&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event timer adapter implementation may have constraints on the resolution (timer_tick_ns) and maximum timer expiry timeout(max_tmo_ns) based on the given timer adapter or system. If this flag is set, the implementation adjusts the resolution and maximum timeout to the best possible configuration. On successful timer adapter creation, the application can get the configured resolution and max timeout with <code><a class="el" href="rte__event__timer__adapter_8h.html#adce42b431be91f89139b083438ee94d5">rte_event_timer_adapter_get_info()</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__event__timer__adapter__info.html#a7005cb8e134017d1fb0452e0aa567ec1">rte_event_timer_adapter_info::min_resolution_ns</a> </dd>
<dd>
struct <a class="el" href="structrte__event__timer__adapter__info.html#a2fd95d22a6412c72f6d09cd1b7c0c0d2">rte_event_timer_adapter_info::max_tmo_ns</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__event__timer__adapter_8h_source.html#l00147">147</a> of file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>

</div>
</div>
<a id="ae32ac29ca5674cc6573a6c79f7c8c5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32ac29ca5674cc6573a6c79f7c8c5bc">&#9670;&nbsp;</a></span>RTE_EVENT_TIMER_ADAPTER_F_SP_PUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TIMER_ADAPTER_F_SP_PUT&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code><a class="el" href="rte__event__timer__adapter_8h.html#a54242cd4a7bb6664f6c80e86a05d0fa8">rte_event_timer_arm_burst()</a></code> API to be used in single producer mode.</p>
<dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__event__timer__adapter__conf.html#a899a76dc5f03f0d4ea3793c339e07ee9">rte_event_timer_adapter_conf::flags</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__event__timer__adapter_8h_source.html#l00152">152</a> of file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3c1efabfac7c38181e4f1bb8d732fd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1efabfac7c38181e4f1bb8d732fd23">&#9670;&nbsp;</a></span>rte_event_timer_adapter_port_conf_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_event_timer_adapter_port_conf_cb_t) (uint16_t id, uint8_t event_dev_id, uint8_t *event_port_id, void *conf_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function type for producer port creation. </p>

<p class="definition">Definition at line <a class="el" href="rte__event__timer__adapter_8h_source.html#l00197">197</a> of file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9fd5df53756805b093928da42cc84da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd5df53756805b093928da42cc84da9">&#9670;&nbsp;</a></span>rte_event_timer_adapter_clk_src</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__event__timer__adapter_8h.html#a9fd5df53756805b093928da42cc84da9">rte_event_timer_adapter_clk_src</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer adapter clock source </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9fd5df53756805b093928da42cc84da9a97700ac3fa74d00342d3d5fbd72969f8"></a>RTE_EVENT_TIMER_ADAPTER_CPU_CLK&#160;</td><td class="fielddoc"><p>Use CPU clock as the clock source. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fd5df53756805b093928da42cc84da9aee26ed3b5b047a1f906fb6119a4b0b08"></a>RTE_EVENT_TIMER_ADAPTER_EXT_CLK0&#160;</td><td class="fielddoc"><p>Platform dependent external clock source 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fd5df53756805b093928da42cc84da9a5b2918eed15299ee7f34e4d2f8f16e7c"></a>RTE_EVENT_TIMER_ADAPTER_EXT_CLK1&#160;</td><td class="fielddoc"><p>Platform dependent external clock source 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fd5df53756805b093928da42cc84da9adeffb4f41fef4a18ea70b2cd5d7c934a"></a>RTE_EVENT_TIMER_ADAPTER_EXT_CLK2&#160;</td><td class="fielddoc"><p>Platform dependent external clock source 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9fd5df53756805b093928da42cc84da9ae7f827ed3b33efff5a5566439f8fb448"></a>RTE_EVENT_TIMER_ADAPTER_EXT_CLK3&#160;</td><td class="fielddoc"><p>Platform dependent external clock source 3. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__event__timer__adapter_8h_source.html#l00123">123</a> of file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>

</div>
</div>
<a id="a1053a05c662ebf7100f03cb2dd8eb85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1053a05c662ebf7100f03cb2dd8eb85a">&#9670;&nbsp;</a></span>rte_event_timer_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__event__timer__adapter_8h.html#a1053a05c662ebf7100f03cb2dd8eb85a">rte_event_timer_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event timer state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1053a05c662ebf7100f03cb2dd8eb85aaa8266f476e8b90d64a5583baa5793648"></a>RTE_EVENT_TIMER_NOT_ARMED&#160;</td><td class="fielddoc"><p>Event timer not armed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1053a05c662ebf7100f03cb2dd8eb85aa6092248b8e82de3b7aab0e77d3f28f8d"></a>RTE_EVENT_TIMER_ARMED&#160;</td><td class="fielddoc"><p>Event timer successfully armed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1053a05c662ebf7100f03cb2dd8eb85aa93727db8d56b3ef71506b46c72e202eb"></a>RTE_EVENT_TIMER_CANCELED&#160;</td><td class="fielddoc"><p>Event timer successfully canceled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1053a05c662ebf7100f03cb2dd8eb85aa991c74cca13be76619169aab023ac55a"></a>RTE_EVENT_TIMER_ERROR&#160;</td><td class="fielddoc"><p>Generic event timer error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1053a05c662ebf7100f03cb2dd8eb85aa4d17b993377dd7e4c4fb1c1f6dbb9e2e"></a>RTE_EVENT_TIMER_ERROR_TOOEARLY&#160;</td><td class="fielddoc"><p>Event timer timeout tick value is too small for the adapter to handle, given its configured resolution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1053a05c662ebf7100f03cb2dd8eb85aabe3e7ba55d87d1217d041bc6f638c971"></a>RTE_EVENT_TIMER_ERROR_TOOLATE&#160;</td><td class="fielddoc"><p>Event timer timeout tick is greater than the maximum timeout. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__event__timer__adapter_8h_source.html#l00434">434</a> of file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0267328b1ae6ea8ff8cc9bf4ff39b641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0267328b1ae6ea8ff8cc9bf4ff39b641">&#9670;&nbsp;</a></span>rte_event_timer_adapter_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_event_timer_adapter* rte_event_timer_adapter_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__event__timer__adapter__conf.html">rte_event_timer_adapter_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an event timer adapter.</p>
<p>This function must be invoked first before any other function in the API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>The event timer adapter configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new allocated event timer adapter on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ERANGE: timer_tick_ns is not in supported range.</li>
<li>ENOMEM: unable to allocate sufficient memory for adapter instances</li>
<li>EINVAL: invalid event device identifier specified in config</li>
<li>ENOSPC: maximum number of adapters already created</li>
<li>EIO: event device reconfiguration and restart error. The adapter reconfigures the event device with an additional port by default if it is required to use a service to manage timers. If the device had been started before this call, this error code indicates an error in restart following an error in reconfiguration, i.e., a combination of the two error codes. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a626ef2a7bfbdc949c817a40e0287373c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626ef2a7bfbdc949c817a40e0287373c">&#9670;&nbsp;</a></span>rte_event_timer_adapter_create_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_event_timer_adapter* rte_event_timer_adapter_create_ext </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__event__timer__adapter__conf.html">rte_event_timer_adapter_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__event__timer__adapter_8h.html#a3c1efabfac7c38181e4f1bb8d732fd23">rte_event_timer_adapter_port_conf_cb_t</a>&#160;</td>
          <td class="paramname"><em>conf_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>conf_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a timer adapter with the supplied callback.</p>
<p>This function can be used to have a more granular control over the timer adapter creation. If a built-in port is absent, then the function uses the callback provided to create and get the port id to be used as a producer port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>The timer adapter configuration structure </td></tr>
    <tr><td class="paramname">conf_cb</td><td>The port config callback function. </td></tr>
    <tr><td class="paramname">conf_arg</td><td>Opaque pointer to the argument for the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new allocated event timer adapter on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ERANGE: timer_tick_ns is not in supported range.</li>
<li>ENOMEM: unable to allocate sufficient memory for adapter instances</li>
<li>EINVAL: invalid event device identifier specified in config</li>
<li>ENOSPC: maximum number of adapters already created </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adce42b431be91f89139b083438ee94d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce42b431be91f89139b083438ee94d5">&#9670;&nbsp;</a></span>rte_event_timer_adapter_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_get_info </td>
          <td>(</td>
          <td class="paramtype">const struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__timer__adapter__info.html">rte_event_timer_adapter_info</a> *&#160;</td>
          <td class="paramname"><em>adapter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the contextual information of an event timer adapter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">adapter</td><td>A pointer to the event timer adapter structure.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">adapter_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__event__timer__adapter__info.html">rte_event_timer_adapter_info</a></em> to be filled with the contextual information of the adapter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the contextual information of the timer adapter</li>
<li>&lt;0: Error code returned by the driver info get function.</li>
<li>-EINVAL: adapter identifier invalid</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__event__timer__adapter_8h.html#a5df887dddf1e34dd0e9faacb76abcda5">RTE_EVENT_TIMER_ADAPTER_F_ADJUST_RES</a>, struct <a class="el" href="structrte__event__timer__adapter__info.html">rte_event_timer_adapter_info</a> </dd></dl>

</div>
</div>
<a id="ab6871577f075b250188f7444afc3091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6871577f075b250188f7444afc3091b">&#9670;&nbsp;</a></span>rte_event_timer_adapter_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_start </td>
          <td>(</td>
          <td class="paramtype">const struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a timer adapter.</p>
<p>The adapter start step is the last one and consists of setting the timer adapter to start accepting the timers and schedules to event queues.</p>
<p>On success, all basic functions exported by the API (timer arm, timer cancel and so on) can be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>A pointer to the event timer adapter structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, adapter started.</li>
<li>&lt;0: Error code returned by the driver start function.</li>
<li>-EINVAL if adapter identifier invalid</li>
<li>-ENOENT if software adapter but no service core mapped</li>
<li>-ENOTSUP if software adapter and more than one service core mapped</li>
<li>-EALREADY if adapter has already been started</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The eventdev to which the event_timer_adapter is connected needs to be started before calling <a class="el" href="rte__event__timer__adapter_8h.html#ab6871577f075b250188f7444afc3091b">rte_event_timer_adapter_start()</a>. </dd></dl>

</div>
</div>
<a id="a1b33505308246e1719354c11ec998d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b33505308246e1719354c11ec998d06">&#9670;&nbsp;</a></span>rte_event_timer_adapter_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_stop </td>
          <td>(</td>
          <td class="paramtype">const struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop an event timer adapter.</p>
<p>The adapter can be restarted with a call to <code><a class="el" href="rte__event__timer__adapter_8h.html#ab6871577f075b250188f7444afc3091b">rte_event_timer_adapter_start()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>A pointer to the event timer adapter structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, adapter stopped.</li>
<li>&lt;0: Error code returned by the driver stop function.</li>
<li>-EINVAL if adapter identifier invalid </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7803143848595dd1f9192989b4610aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7803143848595dd1f9192989b4610aa5">&#9670;&nbsp;</a></span>rte_event_timer_adapter_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_event_timer_adapter* rte_event_timer_adapter_lookup </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>adapter_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup an event timer adapter using its identifier.</p>
<p>If an event timer adapter was created in another process with the same identifier, this function will locate its state and set up access to it so that it can be used in this process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter_id</td><td>The event timer adapter identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the event timer adapter matching the identifier on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - requested entry not available to return. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5e3b19eec57ce45f87c473d3822889c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3b19eec57ce45f87c473d3822889c2">&#9670;&nbsp;</a></span>rte_event_timer_adapter_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an event timer adapter.</p>
<p>Destroy an event timer adapter, freeing all resources.</p>
<p>Before invoking this function, the application must wait for all the armed timers to expire or cancel the outstanding armed timers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>A pointer to an event timer adapter structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully freed the event timer adapter resources.</li>
<li>&lt;0: Failed to free the event timer adapter resources.</li>
<li>-EAGAIN: adapter is busy; timers outstanding</li>
<li>-EBUSY: stop hasn't been called for this adapter yet</li>
<li>-EINVAL: adapter id invalid, or adapter invalid </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0ebfc421d971d680826236daf90b1f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebfc421d971d680826236daf90b1f3d">&#9670;&nbsp;</a></span>rte_event_timer_adapter_service_id_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_service_id_get </td>
          <td>(</td>
          <td class="paramtype">struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>service_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the service ID of the event timer adapter. If the adapter doesn't use an rte_service function, this function returns -ESRCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">adapter</td><td>A pointer to an event timer adapter.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">service_id</td><td>A pointer to a uint32_t, to be filled in with the service id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>&lt;0: Error code on failure</li>
<li>-ESRCH: the adapter does not require a service to operate </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa5e5fc21680c067767bb14ba8a57ee92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e5fc21680c067767bb14ba8a57ee92">&#9670;&nbsp;</a></span>rte_event_timer_adapter_stats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_stats_get </td>
          <td>(</td>
          <td class="paramtype">struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__timer__adapter__stats.html">rte_event_timer_adapter_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve statistics for an event timer adapter instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">adapter</td><td>A pointer to an event timer adapter structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>A pointer to a structure to fill with statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully retrieved.</li>
<li>&lt;0: Failure; error code returned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0b9ac31355595f9c00189502dc107a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9ac31355595f9c00189502dc107a6b">&#9670;&nbsp;</a></span>rte_event_timer_adapter_stats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_stats_reset </td>
          <td>(</td>
          <td class="paramtype">struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset statistics for an event timer adapter instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>A pointer to an event timer adapter structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully reset;</li>
<li>&lt;0: Failure; error code returned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a54242cd4a7bb6664f6c80e86a05d0fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54242cd4a7bb6664f6c80e86a05d0fa8">&#9670;&nbsp;</a></span>rte_event_timer_arm_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_timer_arm_burst </td>
          <td>(</td>
          <td class="paramtype">const struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__timer.html">rte_event_timer</a> **&#160;</td>
          <td class="paramname"><em>evtims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_evtims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Arm a burst of event timers with separate expiration timeout tick for each event timer.</p>
<p>Before calling this function, the application allocates <code>struct <a class="el" href="structrte__event__timer.html">rte_event_timer</a></code> objects from mempool or huge page backed application buffers of desired size. On successful allocation, application updates the <code>struct <a class="el" href="structrte__event__timer.html">rte_event_timer</a></code>` attributes such as expiry event attributes, timeout ticks from now. This function submits the event timer arm requests to the event timer adapter and on expiry, the events will be injected to designated event queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>A pointer to an event timer adapter structure. </td></tr>
    <tr><td class="paramname">evtims</td><td>Pointer to an array of objects of type <em><a class="el" href="structrte__event__timer.html">rte_event_timer</a></em> structure. </td></tr>
    <tr><td class="paramname">nb_evtims</td><td>Number of event timers in the supplied array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of successfully armed event timers. The return value can be less than the value of the <em>nb_evtims</em> parameter. If the return value is less than <em>nb_evtims</em>, the remaining event timers at the end of <em>evtims</em> are not consumed, and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL Invalid timer adapter, expiry event queue ID is invalid, or an expiry event's sched type doesn't match the capabilities of the destination event queue.</li>
<li>EAGAIN Specified timer adapter is not running</li>
<li>EALREADY A timer was encountered that was already armed </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__event__timer__adapter_8h_source.html#l00575">575</a> of file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>

</div>
</div>
<a id="ad6799c8a7911bdf615330078500fd058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6799c8a7911bdf615330078500fd058">&#9670;&nbsp;</a></span>rte_event_timer_arm_tmo_tick_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_timer_arm_tmo_tick_burst </td>
          <td>(</td>
          <td class="paramtype">const struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__timer.html">rte_event_timer</a> **&#160;</td>
          <td class="paramname"><em>evtims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>timeout_ticks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>nb_evtims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Arm a burst of event timers with same expiration timeout tick.</p>
<p>Provides the same functionality as <code><a class="el" href="rte__event__timer__adapter_8h.html#a54242cd4a7bb6664f6c80e86a05d0fa8">rte_event_timer_arm_burst()</a></code>, except that application can use this API when all the event timers have the same timeout expiration tick. This specialized function can provide the additional hint to the adapter implementation and optimize if possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>A pointer to an event timer adapter structure. </td></tr>
    <tr><td class="paramname">evtims</td><td>Points to an array of objects of type <em><a class="el" href="structrte__event__timer.html">rte_event_timer</a></em> structure. </td></tr>
    <tr><td class="paramname">timeout_ticks</td><td>The number of ticks in which the timers should expire. </td></tr>
    <tr><td class="paramname">nb_evtims</td><td>Number of event timers in the supplied array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of successfully armed event timers. The return value can be less than the value of the <em>nb_evtims</em> parameter. If the return value is less than <em>nb_evtims</em>, the remaining event timers at the end of <em>evtims</em> are not consumed, and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL Invalid timer adapter, expiry event queue ID is invalid, or an expiry event's sched type doesn't match the capabilities of the destination event queue.</li>
<li>EAGAIN Specified event timer adapter is not running</li>
<li>EALREADY A timer was encountered that was already armed </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__event__timer__adapter_8h_source.html#l00618">618</a> of file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>

</div>
</div>
<a id="a45ea97c2c4ca7c633a6ab0b747d785a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ea97c2c4ca7c633a6ab0b747d785a5">&#9670;&nbsp;</a></span>rte_event_timer_cancel_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_timer_cancel_burst </td>
          <td>(</td>
          <td class="paramtype">const struct rte_event_timer_adapter *&#160;</td>
          <td class="paramname"><em>adapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__timer.html">rte_event_timer</a> **&#160;</td>
          <td class="paramname"><em>evtims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_evtims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cancel a burst of event timers from being scheduled to the event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adapter</td><td>A pointer to an event timer adapter structure. </td></tr>
    <tr><td class="paramname">evtims</td><td>Points to an array of objects of type <em><a class="el" href="structrte__event__timer.html">rte_event_timer</a></em> structure </td></tr>
    <tr><td class="paramname">nb_evtims</td><td>Number of event timer instances in the supplied array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of successfully canceled event timers. The return value can be less than the value of the <em>nb_evtims</em> parameter. If the return value is less than <em>nb_evtims</em>, the remaining event timers at the end of <em>evtims</em> are not consumed, and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL Invalid timer adapter identifier</li>
<li>EAGAIN Specified timer adapter is not running</li>
<li>EALREADY A timer was encountered that was already canceled </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__event__timer__adapter_8h_source.html#l00655">655</a> of file <a class="el" href="rte__event__timer__adapter_8h_source.html">rte_event_timer_adapter.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
