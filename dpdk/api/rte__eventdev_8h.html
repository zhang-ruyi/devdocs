<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_eventdev/rte_eventdev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_9b3d03c4eb61cec62b5319e654017f5d.html">librte_eventdev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_eventdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;rte_config.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__errno_8h_source.html">rte_errno.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__eventdev__trace__fp_8h_source.html">rte_eventdev_trace_fp.h</a>&quot;</code><br />
</div>
<p><a href="rte__eventdev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__dev__info.html">rte_event_dev_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__dev__config.html">rte_event_dev_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event.html">rte_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__event__dev__xstats__name.html">rte_event_dev_xstats_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acd8e2def7069ede68d5d37031323f952"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#acd8e2def7069ede68d5d37031323f952">RTE_EVENT_DEV_CAP_QUEUE_QOS</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:acd8e2def7069ede68d5d37031323f952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba3fa8f6c8170889356bdf893ec3183"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aeba3fa8f6c8170889356bdf893ec3183">RTE_EVENT_DEV_CAP_EVENT_QOS</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:aeba3fa8f6c8170889356bdf893ec3183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d3efc148e69c47d8bfb16c71a7f72d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#af5d3efc148e69c47d8bfb16c71a7f72d">RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED</a>&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td></tr>
<tr class="separator:af5d3efc148e69c47d8bfb16c71a7f72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74409c333b42420f7fb085ac79509a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a74409c333b42420f7fb085ac79509a03">RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES</a>&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td></tr>
<tr class="separator:a74409c333b42420f7fb085ac79509a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64cc76b136d54ca0c86332ed3723b15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ae64cc76b136d54ca0c86332ed3723b15">RTE_EVENT_DEV_CAP_BURST_MODE</a>&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td></tr>
<tr class="separator:ae64cc76b136d54ca0c86332ed3723b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1353d48908ed22912d8cdeee018ae0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a4b1353d48908ed22912d8cdeee018ae0">RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE</a>&#160;&#160;&#160;(1ULL &lt;&lt; 5)</td></tr>
<tr class="separator:a4b1353d48908ed22912d8cdeee018ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be33f24673d26d71a3695dfd62623fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6be33f24673d26d71a3695dfd62623fa">RTE_EVENT_DEV_CAP_NONSEQ_MODE</a>&#160;&#160;&#160;(1ULL &lt;&lt; 6)</td></tr>
<tr class="separator:a6be33f24673d26d71a3695dfd62623fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2706ca7f81fc820e297b99e0e8c2583e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a2706ca7f81fc820e297b99e0e8c2583e">RTE_EVENT_DEV_CAP_RUNTIME_PORT_LINK</a>&#160;&#160;&#160;(1ULL &lt;&lt; 7)</td></tr>
<tr class="separator:a2706ca7f81fc820e297b99e0e8c2583e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa865eedbbd9dac71ac37321fa63ac8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#affa865eedbbd9dac71ac37321fa63ac8">RTE_EVENT_DEV_CAP_MULTIPLE_QUEUE_PORT</a>&#160;&#160;&#160;(1ULL &lt;&lt; 8)</td></tr>
<tr class="separator:affa865eedbbd9dac71ac37321fa63ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49215a9464a6825173251862149abab4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a49215a9464a6825173251862149abab4">RTE_EVENT_DEV_CAP_CARRY_FLOW_ID</a>&#160;&#160;&#160;(1ULL &lt;&lt; 9)</td></tr>
<tr class="separator:a49215a9464a6825173251862149abab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89072eb7078f8be0f9b0c2642e34ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7a89072eb7078f8be0f9b0c2642e34ef">RTE_EVENT_DEV_PRIORITY_HIGHEST</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a7a89072eb7078f8be0f9b0c2642e34ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0110e34375b970cb883979a3c489e5c5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a0110e34375b970cb883979a3c489e5c5">RTE_EVENT_DEV_PRIORITY_NORMAL</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a0110e34375b970cb883979a3c489e5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba559138ff70b32510631ad1ce5b8da5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aba559138ff70b32510631ad1ce5b8da5">RTE_EVENT_DEV_PRIORITY_LOWEST</a>&#160;&#160;&#160;255</td></tr>
<tr class="separator:aba559138ff70b32510631ad1ce5b8da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e175391c335d69f4f488f0a8a08f69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#af6e175391c335d69f4f488f0a8a08f69">RTE_EVENT_DEV_ATTR_PORT_COUNT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:af6e175391c335d69f4f488f0a8a08f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346e82537d965576cfa4642da7ae66b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a346e82537d965576cfa4642da7ae66b2">RTE_EVENT_DEV_ATTR_QUEUE_COUNT</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a346e82537d965576cfa4642da7ae66b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd45d7b76782e02927ea966bd2d27b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7dd45d7b76782e02927ea966bd2d27b1">RTE_EVENT_DEV_ATTR_STARTED</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a7dd45d7b76782e02927ea966bd2d27b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc71a4c2e35b5b23fe6fcf593c5909a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aedc71a4c2e35b5b23fe6fcf593c5909a">RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:aedc71a4c2e35b5b23fe6fcf593c5909a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b417a1b2250685f2b583aa30a259241"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6b417a1b2250685f2b583aa30a259241">RTE_EVENT_QUEUE_CFG_ALL_TYPES</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:a6b417a1b2250685f2b583aa30a259241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0d54b104105e6f861c6e41b0ca3f9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a3b0d54b104105e6f861c6e41b0ca3f9f">RTE_EVENT_QUEUE_CFG_SINGLE_LINK</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:a3b0d54b104105e6f861c6e41b0ca3f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b359fd06e58898590f9b5f3b8011f4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6b359fd06e58898590f9b5f3b8011f4a">RTE_EVENT_QUEUE_ATTR_PRIORITY</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a6b359fd06e58898590f9b5f3b8011f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f614827b00ced79a709be7b627e54c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ad5f614827b00ced79a709be7b627e54c">RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_FLOWS</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ad5f614827b00ced79a709be7b627e54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115b78b02fc98a801bc62dd916ac9cf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a115b78b02fc98a801bc62dd916ac9cf6">RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_ORDER_SEQUENCES</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a115b78b02fc98a801bc62dd916ac9cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ec3e9f90f3228a3ce31a548bed490"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a0d0ec3e9f90f3228a3ce31a548bed490">RTE_EVENT_QUEUE_ATTR_EVENT_QUEUE_CFG</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a0d0ec3e9f90f3228a3ce31a548bed490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe4b0cd9c9643f681b461938110156a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a5fe4b0cd9c9643f681b461938110156a">RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a5fe4b0cd9c9643f681b461938110156a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc5d49a30616703a0f27f0c66f9b2ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#afbc5d49a30616703a0f27f0c66f9b2ca">RTE_EVENT_PORT_CFG_DISABLE_IMPL_REL</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:afbc5d49a30616703a0f27f0c66f9b2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb50136dfac62bd29ddce2429b6c885"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aafb50136dfac62bd29ddce2429b6c885">RTE_EVENT_PORT_CFG_SINGLE_LINK</a>&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td></tr>
<tr class="separator:aafb50136dfac62bd29ddce2429b6c885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fc8695cb074e656ab5eadf286b0f08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a40fc8695cb074e656ab5eadf286b0f08">RTE_EVENT_PORT_ATTR_ENQ_DEPTH</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a40fc8695cb074e656ab5eadf286b0f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd80caf495a4624fa213cc2330c8923"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#afcd80caf495a4624fa213cc2330c8923">RTE_EVENT_PORT_ATTR_DEQ_DEPTH</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:afcd80caf495a4624fa213cc2330c8923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a28fba179c8b08f42eaab7f3683a39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a60a28fba179c8b08f42eaab7f3683a39">RTE_EVENT_PORT_ATTR_NEW_EVENT_THRESHOLD</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a60a28fba179c8b08f42eaab7f3683a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf25098a79d7e3ad4fd936737808a9f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aebf25098a79d7e3ad4fd936737808a9f">RTE_EVENT_PORT_ATTR_IMPLICIT_RELEASE_DISABLE</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:aebf25098a79d7e3ad4fd936737808a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ab13bc5be32cbc9ee15e294b4c9a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a366ab13bc5be32cbc9ee15e294b4c9a2">RTE_SCHED_TYPE_ORDERED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a366ab13bc5be32cbc9ee15e294b4c9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c199a28e97411266a069bd07c9757fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a3c199a28e97411266a069bd07c9757fa">RTE_SCHED_TYPE_ATOMIC</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a3c199a28e97411266a069bd07c9757fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88982845a12ff215c721fccb18ed4a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac88982845a12ff215c721fccb18ed4a7">RTE_SCHED_TYPE_PARALLEL</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ac88982845a12ff215c721fccb18ed4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a711c45b3d3f125069b1a7cb731435"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ae5a711c45b3d3f125069b1a7cb731435">RTE_EVENT_TYPE_ETHDEV</a>&#160;&#160;&#160;0x0</td></tr>
<tr class="separator:ae5a711c45b3d3f125069b1a7cb731435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982ad2bf50bd73e7cdbe2a62e5d581f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a982ad2bf50bd73e7cdbe2a62e5d581f6">RTE_EVENT_TYPE_CRYPTODEV</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a982ad2bf50bd73e7cdbe2a62e5d581f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247d3e6500516ff097e06f199dfb5cc3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a247d3e6500516ff097e06f199dfb5cc3">RTE_EVENT_TYPE_TIMER</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:a247d3e6500516ff097e06f199dfb5cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15be67634b343dc7dc7b6d63630abdd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac15be67634b343dc7dc7b6d63630abdd">RTE_EVENT_TYPE_CPU</a>&#160;&#160;&#160;0x3</td></tr>
<tr class="separator:ac15be67634b343dc7dc7b6d63630abdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934df8149a7a1a4cfcdbb18a880d837c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a934df8149a7a1a4cfcdbb18a880d837c">RTE_EVENT_TYPE_ETH_RX_ADAPTER</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a934df8149a7a1a4cfcdbb18a880d837c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351dba845f2d001f6245fd41692d8c9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a351dba845f2d001f6245fd41692d8c9e">RTE_EVENT_TYPE_MAX</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a351dba845f2d001f6245fd41692d8c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69a0db3e4653c786aef1febe7594b78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aa69a0db3e4653c786aef1febe7594b78">RTE_EVENT_OP_NEW</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aa69a0db3e4653c786aef1febe7594b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416488eee18e9e740dba1c61a312f06a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a416488eee18e9e740dba1c61a312f06a">RTE_EVENT_OP_FORWARD</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a416488eee18e9e740dba1c61a312f06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab927860cf68a0c0a8caf96fe9feb2a23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ab927860cf68a0c0a8caf96fe9feb2a23">RTE_EVENT_OP_RELEASE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ab927860cf68a0c0a8caf96fe9feb2a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0938b6c89c22b3de3ee9e8bfa1da2ae7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a0938b6c89c22b3de3ee9e8bfa1da2ae7">RTE_EVENT_ETH_RX_ADAPTER_CAP_INTERNAL_PORT</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a0938b6c89c22b3de3ee9e8bfa1da2ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3abde85e981790ae41c69ad7df33b75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac3abde85e981790ae41c69ad7df33b75">RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:ac3abde85e981790ae41c69ad7df33b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d39c45789a6d8c808b08c57057f715c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a8d39c45789a6d8c808b08c57057f715c">RTE_EVENT_ETH_RX_ADAPTER_CAP_OVERRIDE_FLOW_ID</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a8d39c45789a6d8c808b08c57057f715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3ed17910cfdeb061734fe14f9651fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aee3ed17910cfdeb061734fe14f9651fc">RTE_EVENT_TIMER_ADAPTER_CAP_INTERNAL_PORT</a>&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td></tr>
<tr class="separator:aee3ed17910cfdeb061734fe14f9651fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832fc0958c7dedc25a4c294d7bc08c48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a832fc0958c7dedc25a4c294d7bc08c48">RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_NEW</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a832fc0958c7dedc25a4c294d7bc08c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafffb3091cacef210c8710c7bb717311"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aafffb3091cacef210c8710c7bb717311">RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_FWD</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:aafffb3091cacef210c8710c7bb717311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594e773a009ba1c9c2e19f413125893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7594e773a009ba1c9c2e19f413125893">RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_QP_EV_BIND</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:a7594e773a009ba1c9c2e19f413125893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07cd5e93133ab8aa760e3eb17a3b81b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ab07cd5e93133ab8aa760e3eb17a3b81b">RTE_EVENT_CRYPTO_ADAPTER_CAP_SESSION_PRIVATE_DATA</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:ab07cd5e93133ab8aa760e3eb17a3b81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6c6cbdc5b9091cc561ab38983be324"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a3b6c6cbdc5b9091cc561ab38983be324">RTE_EVENT_ETH_TX_ADAPTER_CAP_INTERNAL_PORT</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:a3b6c6cbdc5b9091cc561ab38983be324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0248ac6e03597e9a8c57a96cd38f8e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ae0248ac6e03597e9a8c57a96cd38f8e1">RTE_EVENT_DEV_XSTATS_NAME_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:ae0248ac6e03597e9a8c57a96cd38f8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac602147b65d5e9a7367f970710fccaec"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac602147b65d5e9a7367f970710fccaec">eventdev_stop_flush_t</a>) (uint8_t dev_id, struct <a class="el" href="structrte__event.html">rte_event</a> event, void *arg)</td></tr>
<tr class="separator:ac602147b65d5e9a7367f970710fccaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a505adb6f39a9108c494df8070312dee5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a> </td></tr>
<tr class="separator:a505adb6f39a9108c494df8070312dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6541eb8822285c7b77455636201d5134"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6541eb8822285c7b77455636201d5134">rte_event_dev_count</a> (void)</td></tr>
<tr class="separator:a6541eb8822285c7b77455636201d5134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da264acd9bd0da6795801c6568f0387"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a7da264acd9bd0da6795801c6568f0387">rte_event_dev_get_dev_id</a> (const char *name)</td></tr>
<tr class="separator:a7da264acd9bd0da6795801c6568f0387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92ef37cd075e2db64d4f358b939c205"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ae92ef37cd075e2db64d4f358b939c205">rte_event_dev_socket_id</a> (uint8_t dev_id)</td></tr>
<tr class="separator:ae92ef37cd075e2db64d4f358b939c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd7355a0be9b94bbca0f32796e57358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a5bd7355a0be9b94bbca0f32796e57358">rte_event_dev_info_get</a> (uint8_t dev_id, struct <a class="el" href="structrte__event__dev__info.html">rte_event_dev_info</a> *dev_info)</td></tr>
<tr class="separator:a5bd7355a0be9b94bbca0f32796e57358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e78537e4554caf73c13c79e8a3cd06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a79e78537e4554caf73c13c79e8a3cd06">rte_event_dev_attr_get</a> (uint8_t dev_id, uint32_t attr_id, uint32_t *attr_value)</td></tr>
<tr class="separator:a79e78537e4554caf73c13c79e8a3cd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e7d0094442b3a158e89f120a21687d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure</a> (uint8_t dev_id, const struct <a class="el" href="structrte__event__dev__config.html">rte_event_dev_config</a> *dev_conf)</td></tr>
<tr class="separator:af1e7d0094442b3a158e89f120a21687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d3f2bd3f600cdc3d8724844cbbcf20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a57d3f2bd3f600cdc3d8724844cbbcf20">rte_event_queue_default_conf_get</a> (uint8_t dev_id, uint8_t queue_id, struct <a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a> *queue_conf)</td></tr>
<tr class="separator:a57d3f2bd3f600cdc3d8724844cbbcf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1db34b6c7bb2b05a5db7aab8c6834"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup</a> (uint8_t dev_id, uint8_t queue_id, const struct <a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a> *queue_conf)</td></tr>
<tr class="separator:a57a1db34b6c7bb2b05a5db7aab8c6834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d7fa11b04003ff32884d83ae04960"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9f6d7fa11b04003ff32884d83ae04960">rte_event_queue_attr_get</a> (uint8_t dev_id, uint8_t queue_id, uint32_t attr_id, uint32_t *attr_value)</td></tr>
<tr class="separator:a9f6d7fa11b04003ff32884d83ae04960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf86b3088e02126b06be3c0a5ac07bb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#abf86b3088e02126b06be3c0a5ac07bb7">rte_event_port_default_conf_get</a> (uint8_t dev_id, uint8_t port_id, struct <a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a> *port_conf)</td></tr>
<tr class="separator:abf86b3088e02126b06be3c0a5ac07bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac087670e6e885abcdf046c8e74844cd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup</a> (uint8_t dev_id, uint8_t port_id, const struct <a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a> *port_conf)</td></tr>
<tr class="separator:ac087670e6e885abcdf046c8e74844cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cc781b1ab9af77077c6c91eab37220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#aa1cc781b1ab9af77077c6c91eab37220">rte_event_port_attr_get</a> (uint8_t dev_id, uint8_t port_id, uint32_t attr_id, uint32_t *attr_value)</td></tr>
<tr class="separator:aa1cc781b1ab9af77077c6c91eab37220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e99f06a45adaa095b257b93ebaf201"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ab6e99f06a45adaa095b257b93ebaf201">rte_event_dev_start</a> (uint8_t dev_id)</td></tr>
<tr class="separator:ab6e99f06a45adaa095b257b93ebaf201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644f6cc4ab24a5c07bfff9b0f5c42e8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop</a> (uint8_t dev_id)</td></tr>
<tr class="separator:a644f6cc4ab24a5c07bfff9b0f5c42e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab856d854c98af5d73490b9958cb624d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ab856d854c98af5d73490b9958cb624d7">rte_event_dev_stop_flush_callback_register</a> (uint8_t dev_id, <a class="el" href="rte__eventdev_8h.html#ac602147b65d5e9a7367f970710fccaec">eventdev_stop_flush_t</a> callback, void *userdata)</td></tr>
<tr class="separator:ab856d854c98af5d73490b9958cb624d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70f4ed704d89a4ffce3b4c105bac076"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#af70f4ed704d89a4ffce3b4c105bac076">rte_event_dev_close</a> (uint8_t dev_id)</td></tr>
<tr class="separator:af70f4ed704d89a4ffce3b4c105bac076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56aa49dc89eb44d2e35bd72bd809db17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a56aa49dc89eb44d2e35bd72bd809db17">rte_event_eth_rx_adapter_caps_get</a> (uint8_t dev_id, uint16_t eth_port_id, uint32_t *caps)</td></tr>
<tr class="separator:a56aa49dc89eb44d2e35bd72bd809db17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78649b804d0c880dd23b23fcd28100f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a78649b804d0c880dd23b23fcd28100f9">rte_event_timer_adapter_caps_get</a> (uint8_t dev_id, uint32_t *caps)</td></tr>
<tr class="separator:a78649b804d0c880dd23b23fcd28100f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b478480a0d8d93b20622be566c127ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6b478480a0d8d93b20622be566c127ee">rte_event_crypto_adapter_caps_get</a> (uint8_t dev_id, uint8_t cdev_id, uint32_t *caps)</td></tr>
<tr class="separator:a6b478480a0d8d93b20622be566c127ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad147297659da4017ff8a8cec1757548c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ad147297659da4017ff8a8cec1757548c">rte_event_eth_tx_adapter_caps_get</a> (uint8_t dev_id, uint16_t eth_port_id, uint32_t *caps)</td></tr>
<tr class="separator:ad147297659da4017ff8a8cec1757548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6b7f3fd1b11858a2db91864708f9a4"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst</a> (uint8_t dev_id, uint8_t port_id, const struct <a class="el" href="structrte__event.html">rte_event</a> ev[], uint16_t nb_events)</td></tr>
<tr class="separator:afc6b7f3fd1b11858a2db91864708f9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9c183571cdd91c8a1c70fc6a6c1241"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a9b9c183571cdd91c8a1c70fc6a6c1241">rte_event_enqueue_new_burst</a> (uint8_t dev_id, uint8_t port_id, const struct <a class="el" href="structrte__event.html">rte_event</a> ev[], uint16_t nb_events)</td></tr>
<tr class="separator:a9b9c183571cdd91c8a1c70fc6a6c1241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6260ce13081213f8eb8b1b4da935ad"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a2a6260ce13081213f8eb8b1b4da935ad">rte_event_enqueue_forward_burst</a> (uint8_t dev_id, uint8_t port_id, const struct <a class="el" href="structrte__event.html">rte_event</a> ev[], uint16_t nb_events)</td></tr>
<tr class="separator:a2a6260ce13081213f8eb8b1b4da935ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245cbc6e55632565a57f6f98f492428f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a245cbc6e55632565a57f6f98f492428f">rte_event_dequeue_timeout_ticks</a> (uint8_t dev_id, uint64_t ns, uint64_t *timeout_ticks)</td></tr>
<tr class="separator:a245cbc6e55632565a57f6f98f492428f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af1610d3ede24979267333cf2da1aab"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst</a> (uint8_t dev_id, uint8_t port_id, struct <a class="el" href="structrte__event.html">rte_event</a> ev[], uint16_t nb_events, uint64_t timeout_ticks)</td></tr>
<tr class="separator:a2af1610d3ede24979267333cf2da1aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f0abd90e6784a4dc1c4f07ece2715a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link</a> (uint8_t dev_id, uint8_t port_id, const uint8_t queues[], const uint8_t priorities[], uint16_t nb_links)</td></tr>
<tr class="separator:a27f0abd90e6784a4dc1c4f07ece2715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dad9f41edf100e192e5610b2f078d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ad8dad9f41edf100e192e5610b2f078d5">rte_event_port_unlink</a> (uint8_t dev_id, uint8_t port_id, uint8_t queues[], uint16_t nb_unlinks)</td></tr>
<tr class="separator:ad8dad9f41edf100e192e5610b2f078d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065a820ce96a30fd83b54f535ef580d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a065a820ce96a30fd83b54f535ef580d9">rte_event_port_unlinks_in_progress</a> (uint8_t dev_id, uint8_t port_id)</td></tr>
<tr class="separator:a065a820ce96a30fd83b54f535ef580d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0524c6c5b1d32981669c4d84254228a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a0524c6c5b1d32981669c4d84254228a1">rte_event_port_links_get</a> (uint8_t dev_id, uint8_t port_id, uint8_t queues[], uint8_t priorities[])</td></tr>
<tr class="separator:a0524c6c5b1d32981669c4d84254228a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e46a7e6c7b3c17629b007d0a85e62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a335e46a7e6c7b3c17629b007d0a85e62">rte_event_dev_service_id_get</a> (uint8_t dev_id, uint32_t *service_id)</td></tr>
<tr class="separator:a335e46a7e6c7b3c17629b007d0a85e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766ba60306ac044b59d6143c77288c46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a766ba60306ac044b59d6143c77288c46">rte_event_dev_dump</a> (uint8_t dev_id, FILE *f)</td></tr>
<tr class="separator:a766ba60306ac044b59d6143c77288c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a9a479f54119d010b9af696a7e661a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a33a9a479f54119d010b9af696a7e661a">rte_event_dev_xstats_names_get</a> (uint8_t dev_id, enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a> mode, uint8_t queue_port_id, struct <a class="el" href="structrte__event__dev__xstats__name.html">rte_event_dev_xstats_name</a> *xstats_names, unsigned int *ids, unsigned int size)</td></tr>
<tr class="separator:a33a9a479f54119d010b9af696a7e661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad889f39c336e7727791dcce9807a635e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#ad889f39c336e7727791dcce9807a635e">rte_event_dev_xstats_get</a> (uint8_t dev_id, enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a> mode, uint8_t queue_port_id, const unsigned int ids[], uint64_t values[], unsigned int n)</td></tr>
<tr class="separator:ad889f39c336e7727791dcce9807a635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912e145c33166be1c5d196527e2511c8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a912e145c33166be1c5d196527e2511c8">rte_event_dev_xstats_by_name_get</a> (uint8_t dev_id, const char *name, unsigned int *id)</td></tr>
<tr class="separator:a912e145c33166be1c5d196527e2511c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6643e9fbaac8254e143182fa61d3f73e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a6643e9fbaac8254e143182fa61d3f73e">rte_event_dev_xstats_reset</a> (uint8_t dev_id, enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a> mode, int16_t queue_port_id, const uint32_t ids[], uint32_t nb_ids)</td></tr>
<tr class="separator:a6643e9fbaac8254e143182fa61d3f73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592ae650e0315dd61364e1cab3ecd6a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eventdev_8h.html#a592ae650e0315dd61364e1cab3ecd6a7">rte_event_dev_selftest</a> (uint8_t dev_id)</td></tr>
<tr class="separator:a592ae650e0315dd61364e1cab3ecd6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Event Device API</p>
<p>In a polling model, lcores poll ethdev ports and associated rx queues directly to look for packet. In an event driven model, by contrast, lcores call the scheduler that selects packets for them based on programmer specified criteria. Eventdev library adds support for event driven programming model, which offer applications automatic multicore scaling, dynamic load balancing, pipelining, packet ingress order maintenance and synchronization services to simplify application packet processing.</p>
<p>The Event Device API is composed of two parts:</p>
<ul>
<li>The application-oriented Event API that includes functions to setup an event device (configure it, setup its queues, ports and start it), to establish the link between queues to port and to receive events, and so on.</li>
<li>The driver-oriented Event API that exports a function allowing an event poll Mode Driver (PMD) to simultaneously register itself as an event device driver.</li>
</ul>
<p>Event device components: </p><pre class="fragment">                +-----------------+
                | +-------------+ |
   +-------+    | |    flow 0   | |
   |Packet |    | +-------------+ |
   |event  |    | +-------------+ |
   |       |    | |    flow 1   | |port_link(port0, queue0)
   +-------+    | +-------------+ |     |     +--------+
   +-------+    | +-------------+ o-----v-----o        |dequeue +------+
   |Crypto |    | |    flow n   | |           | event  +-------&gt;|Core 0|
   |work   |    | +-------------+ o----+      | port 0 |        |      |
   |done ev|    |  event queue 0  |    |      +--------+        +------+
   +-------+    +-----------------+    |
   +-------+                           |
   |Timer  |    +-----------------+    |      +--------+
   |expiry |    | +-------------+ |    +------o        |dequeue +------+
   |event  |    | |    flow 0   | o-----------o event  +-------&gt;|Core 1|
   +-------+    | +-------------+ |      +----o port 1 |        |      |
  Event enqueue | +-------------+ |      |    +--------+        +------+
o-------------&gt; | |    flow 1   | |      |
   enqueue(     | +-------------+ |      |
   queue_id,    |                 |      |    +--------+        +------+
   flow_id,     | +-------------+ |      |    |        |dequeue |Core 2|
   sched_type,  | |    flow n   | o-----------o event  +-------&gt;|      |
   event_type,  | +-------------+ |      |    | port 2 |        +------+
   subev_type,  |  event queue 1  |      |    +--------+
   event)       +-----------------+      |    +--------+
                                         |    |        |dequeue +------+
   +-------+    +-----------------+      |    | event  +-------&gt;|Core n|
   |Core   |    | +-------------+ o-----------o port n |        |      |
   |(SW)   |    | |    flow 0   | |      |    +--------+        +--+---+
   |event  |    | +-------------+ |      |                         |
   +-------+    | +-------------+ |      |                         |
       ^        | |    flow 1   | |      |                         |
       |        | +-------------+ o------+                         |
       |        | +-------------+ |                                |
       |        | |    flow n   | |                                |
       |        | +-------------+ |                                |
       |        |  event queue n  |                                |
       |        +-----------------+                                |
       |                                                           |
       +-----------------------------------------------------------+
</pre><p>Event device: A hardware or software-based event scheduler.</p>
<p>Event: A unit of scheduling that encapsulates a packet or other datatype like SW generated event from the CPU, Crypto work completion notification, Timer expiry event notification etc as well as metadata. The metadata includes flow ID, scheduling type, event priority, event_type, sub_event_type etc.</p>
<p>Event queue: A queue containing events that are scheduled by the event dev. An event queue contains events of different flows associated with scheduling types, such as atomic, ordered, or parallel.</p>
<p>Event port: An application's interface into the event dev for enqueue and dequeue operations. Each event port can be linked with one or more event queues for dequeue operations.</p>
<p>By default, all the functions of the Event Device API exported by a PMD are lock-free functions which assume to not be invoked in parallel on different logical cores to work on the same target object. For instance, the dequeue function of a PMD cannot be invoked in parallel on two logical cores to operates on same event port. Of course, this function can be invoked in parallel by different logical cores on different ports. It is the responsibility of the upper level application to enforce this rule.</p>
<p>In all functions of the Event API, the Event device is designated by an integer &gt;= 0 named the device identifier <em>dev_id</em></p>
<p>At the Event driver level, Event devices are represented by a generic data structure of type <em>rte_event_dev</em>.</p>
<p>Event devices are dynamically registered during the PCI/SoC device probing phase performed at EAL initialization time. When an Event device is being probed, a <em>rte_event_dev</em> structure and a new device identifier are allocated for that device. Then, the event_dev_init() function supplied by the Event driver matching the probed device is invoked to properly initialize the device.</p>
<p>The role of the device init function consists of resetting the hardware or software event driver implementations.</p>
<p>If the device init operation is successful, the correspondence between the device identifier assigned to the new device and its associated <em>rte_event_dev</em> structure is effectively registered. Otherwise, both the <em>rte_event_dev</em> structure and the device identifier are freed.</p>
<p>The functions exported by the application Event API to setup a device designated by its device identifier must be invoked in the following order:</p><ul>
<li><a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a></li>
<li><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a></li>
<li><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a></li>
<li><a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a></li>
<li><a class="el" href="rte__eventdev_8h.html#ab6e99f06a45adaa095b257b93ebaf201">rte_event_dev_start()</a></li>
</ul>
<p>Then, the application can invoke, in any order, the functions exported by the Event API to schedule events, dequeue events, enqueue events, change event queue(s) to event port [un]link establishment and so on.</p>
<p>Application may use rte_event_[queue/port]_default_conf_get() to get the default configuration to set up an event queue or event port by overriding few default values.</p>
<p>If the application wants to change the configuration (i.e. call <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>, <a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, or <a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a>), it must call <a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a> first to stop the device and then do the reconfiguration before calling <a class="el" href="rte__eventdev_8h.html#ab6e99f06a45adaa095b257b93ebaf201">rte_event_dev_start()</a> again. The schedule, enqueue and dequeue functions should not be invoked when the device is stopped.</p>
<p>Finally, an application can close an Event device by invoking the <a class="el" href="rte__eventdev_8h.html#af70f4ed704d89a4ffce3b4c105bac076">rte_event_dev_close()</a> function.</p>
<p>Each function of the application Event API invokes a specific function of the PMD that controls the target device designated by its device identifier.</p>
<p>For this purpose, all device-specific functions of an Event driver are supplied through a set of pointers contained in a generic structure of type <em>event_dev_ops</em>. The address of the <em>event_dev_ops</em> structure is stored in the <em>rte_event_dev</em> structure by the device init function of the Event driver, which is invoked during the PCI/SoC device probing phase, as explained earlier.</p>
<p>In other words, each function of the Event API simply retrieves the <em>rte_event_dev</em> structure associated with the device identifier and performs an indirect invocation of the corresponding driver function supplied in the <em>event_dev_ops</em> structure of the <em>rte_event_dev</em> structure.</p>
<p>For performance reasons, the address of the fast-path functions of the Event driver is not contained in the <em>event_dev_ops</em> structure. Instead, they are directly stored at the beginning of the <em>rte_event_dev</em> structure to avoid an extra indirect memory access during their invocation.</p>
<p>RTE event device drivers do not use interrupts for enqueue or dequeue operation. Instead, Event drivers export Poll-Mode enqueue and dequeue functions to applications.</p>
<p>The events are injected to event device through <em>enqueue</em> operation by event producers in the system. The typical event producers are ethdev subsystem for generating packet events, CPU(SW) for generating events based on different stages of application processing, cryptodev for generating crypto work completion notification etc</p>
<p>The <em>dequeue</em> operation gets one or more events from the event ports. The application process the events and send to downstream event queue through <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> if it is an intermediate stage of event processing, on the final stage, the application may use Tx adapter API for maintaining the ingress order and then send the packet/event on the wire.</p>
<p>The point at which events are scheduled to ports depends on the device. For hardware devices, scheduling occurs asynchronously without any software intervention. Software schedulers can either be distributed (each worker thread schedules events to its own port) or centralized (a dedicated thread schedules to all ports). Distributed software schedulers perform the scheduling in <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, whereas centralized scheduler logic need a dedicated service core for scheduling. The RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED capability flag is not set indicates the device is centralized and thus needs a dedicated scheduling thread that repeatedly calls software specific scheduling function.</p>
<p>An event driven worker thread has following typical workflow on fastpath: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (1) {</div>
<div class="line">   <a class="code" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst</a>(...);</div>
<div class="line">   (<span class="keyword">event</span> processing)</div>
<div class="line">   <a class="code" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst</a>(...);</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition in file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="acd8e2def7069ede68d5d37031323f952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8e2def7069ede68d5d37031323f952">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_QUEUE_QOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_QUEUE_QOS&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event scheduling prioritization is based on the priority associated with each event queue.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00229">229</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aeba3fa8f6c8170889356bdf893ec3183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba3fa8f6c8170889356bdf893ec3183">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_EVENT_QOS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_EVENT_QOS&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event scheduling prioritization is based on the priority associated with each event. Priority of each event is supplied in <em><a class="el" href="structrte__event.html">rte_event</a></em> structure on each enqueue operation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00236">236</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="af5d3efc148e69c47d8bfb16c71a7f72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d3efc148e69c47d8bfb16c71a7f72d">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED&#160;&#160;&#160;(1ULL &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device operates in distributed scheduling mode. In distributed scheduling mode, event scheduling happens in HW or <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> or the combination of these two. If the flag is not set then eventdev is centralized and thus needs a dedicated service core that acts as a scheduling thread .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a87">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a95">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a7">examples/l2fwd-event/l2fwd_event.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a58">examples/l3fwd/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00245">245</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a74409c333b42420f7fb085ac79509a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74409c333b42420f7fb085ac79509a03">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_QUEUE_ALL_TYPES&#160;&#160;&#160;(1ULL &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of enqueuing events of any type to any queue. If this capability is not set, the queue only supports events of the <em>RTE_SCHED_TYPE_</em> type that it was created with.</p>
<dl class="section see"><dt>See also</dt><dd>RTE_SCHED_TYPE_* values </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a86">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a96">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a7">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a7">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a7">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a7">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00252">252</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ae64cc76b136d54ca0c86332ed3723b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64cc76b136d54ca0c86332ed3723b15">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_BURST_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_BURST_MODE&#160;&#160;&#160;(1ULL &lt;&lt; 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of operating in burst mode for enqueue(forward, release) and dequeue operation. If this capability is not set, application still uses the <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> and <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> but PMD accepts only one event at a time.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a9">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a11">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a22">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a21">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a22">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a21">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00260">260</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a4b1353d48908ed22912d8cdeee018ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1353d48908ed22912d8cdeee018ae0">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE&#160;&#160;&#160;(1ULL &lt;&lt; 5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device ports support disabling the implicit release feature, in which the port will release all unreleased events in its dequeue operation. If this capability is set and the port is configured with implicit release disabled, the application is responsible for explicitly releasing events using either the RTE_EVENT_OP_FORWARD or the RTE_EVENT_OP_RELEASE event enqueue operations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a27">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a6">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a6">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a6">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a6">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00270">270</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a6be33f24673d26d71a3695dfd62623fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be33f24673d26d71a3695dfd62623fa">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_NONSEQ_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_NONSEQ_MODE&#160;&#160;&#160;(1ULL &lt;&lt; 6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of operating in none sequential mode. The path of the event is not necessary to be sequential. Application can change the path of event at runtime. If the flag is not set, then event each event will follow a path from queue 0 to queue 1 to queue 2 etc. If the flag is set, events may be sent to queues in any order. If the flag is not set, the eventdev will return an error when the application enqueues an event for a qid which is not the next in the sequence. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00280">280</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a2706ca7f81fc820e297b99e0e8c2583e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2706ca7f81fc820e297b99e0e8c2583e">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_RUNTIME_PORT_LINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_RUNTIME_PORT_LINK&#160;&#160;&#160;(1ULL &lt;&lt; 7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of configuring the queue/port link at runtime. If the flag is not set, the eventdev queue/port link is only can be configured during initialization. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00286">286</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="affa865eedbbd9dac71ac37321fa63ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa865eedbbd9dac71ac37321fa63ac8">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_MULTIPLE_QUEUE_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_MULTIPLE_QUEUE_PORT&#160;&#160;&#160;(1ULL &lt;&lt; 8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device is capable of setting up the link between multiple queue with single port. If the flag is not set, the eventdev can only map a single queue to each port or map a single queue to many port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00292">292</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a49215a9464a6825173251862149abab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49215a9464a6825173251862149abab4">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CAP_CARRY_FLOW_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CAP_CARRY_FLOW_ID&#160;&#160;&#160;(1ULL &lt;&lt; 9)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event device preserves the flow ID from the enqueued event to the dequeued event if the flag is set. Otherwise, the content of this field is implementation dependent. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00298">298</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a7a89072eb7078f8be0f9b0c2642e34ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a89072eb7078f8be0f9b0c2642e34ef">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_PRIORITY_HIGHEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_PRIORITY_HIGHEST&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Highest priority expressed across eventdev subsystem </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a22">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a44">examples/l2fwd-event/l2fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a44">examples/l3fwd/l3fwd_event_generic.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00305">305</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a0110e34375b970cb883979a3c489e5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0110e34375b970cb883979a3c489e5c5">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_PRIORITY_NORMAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_PRIORITY_NORMAL&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normal priority expressed across eventdev subsystem </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a20">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a27">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a38">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a37">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a38">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a37">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00310">310</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aba559138ff70b32510631ad1ce5b8da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba559138ff70b32510631ad1ce5b8da5">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_PRIORITY_LOWEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_PRIORITY_LOWEST&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lowest priority expressed across eventdev subsystem </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a35">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, and <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a38">examples/eventdev_pipeline/pipeline_worker_tx.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00315">315</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="af6e175391c335d69f4f488f0a8a08f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e175391c335d69f4f488f0a8a08f69">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_ATTR_PORT_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_ATTR_PORT_COUNT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The count of ports. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00429">429</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a346e82537d965576cfa4642da7ae66b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346e82537d965576cfa4642da7ae66b2">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_ATTR_QUEUE_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_ATTR_QUEUE_COUNT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The count of queues. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00433">433</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a7dd45d7b76782e02927ea966bd2d27b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd45d7b76782e02927ea966bd2d27b1">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_ATTR_STARTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_ATTR_STARTED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The status of the device, zero for stopped, non-zero for started. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00437">437</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aedc71a4c2e35b5b23fe6fcf593c5909a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc71a4c2e35b5b23fe6fcf593c5909a">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Override the global <em>dequeue_timeout_ns</em> and use per dequeue timeout in ns. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a245cbc6e55632565a57f6f98f492428f">rte_event_dequeue_timeout_ticks()</a>, <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00460">460</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a6b417a1b2250685f2b583aa30a259241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b417a1b2250685f2b583aa30a259241">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_CFG_ALL_TYPES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_CFG_ALL_TYPES&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow ATOMIC,ORDERED,PARALLEL schedule type enqueue</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a366ab13bc5be32cbc9ee15e294b4c9a2">RTE_SCHED_TYPE_ORDERED</a>, <a class="el" href="rte__eventdev_8h.html#a3c199a28e97411266a069bd07c9757fa">RTE_SCHED_TYPE_ATOMIC</a>, <a class="el" href="rte__eventdev_8h.html#ac88982845a12ff215c721fccb18ed4a7">RTE_SCHED_TYPE_PARALLEL</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a36">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a15">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a8">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a8">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a8">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a8">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00554">554</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a3b0d54b104105e6f861c6e41b0ca3f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0d54b104105e6f861c6e41b0ca3f9f">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_CFG_SINGLE_LINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_CFG_SINGLE_LINK&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event queue links only to a single event port.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a23">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a42">examples/l2fwd-event/l2fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a42">examples/l3fwd/l3fwd_event_generic.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00559">559</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a6b359fd06e58898590f9b5f3b8011f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b359fd06e58898590f9b5f3b8011f4a">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_PRIORITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_PRIORITY&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The priority of the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00653">653</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ad5f614827b00ced79a709be7b627e54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f614827b00ced79a709be7b627e54c">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_FLOWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_FLOWS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of atomic flows configured for the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00657">657</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a115b78b02fc98a801bc62dd916ac9cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115b78b02fc98a801bc62dd916ac9cf6">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_ORDER_SEQUENCES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_NB_ATOMIC_ORDER_SEQUENCES&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of atomic order sequences configured for the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00661">661</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a0d0ec3e9f90f3228a3ce31a548bed490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0ec3e9f90f3228a3ce31a548bed490">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_EVENT_QUEUE_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_EVENT_QUEUE_CFG&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The cfg flags for the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00665">665</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a5fe4b0cd9c9643f681b461938110156a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe4b0cd9c9643f681b461938110156a">&#9670;&nbsp;</a></span>RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The schedule type of the queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00669">669</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="afbc5d49a30616703a0f27f0c66f9b2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc5d49a30616703a0f27f0c66f9b2ca">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_CFG_DISABLE_IMPL_REL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_CFG_DISABLE_IMPL_REL&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the port not to release outstanding events in rte_event_dev_dequeue_burst(). If set, all events received through the port must be explicitly released with RTE_EVENT_OP_RELEASE or RTE_EVENT_OP_FORWARD. Must be unset if the device is not RTE_EVENT_DEV_CAP_IMPLICIT_RELEASE_DISABLE capable. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a29">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a31">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a30">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a31">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a30">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00704">704</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aafb50136dfac62bd29ddce2429b6c885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb50136dfac62bd29ddce2429b6c885">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_CFG_SINGLE_LINK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_CFG_SINGLE_LINK&#160;&#160;&#160;(1ULL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This event port links only to a single event queue.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a27f0abd90e6784a4dc1c4f07ece2715a">rte_event_port_link()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00709">709</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a40fc8695cb074e656ab5eadf286b0f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fc8695cb074e656ab5eadf286b0f08">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_ATTR_ENQ_DEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_ATTR_ENQ_DEPTH&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The queue depth of the port on the enqueue side </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00794">794</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="afcd80caf495a4624fa213cc2330c8923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd80caf495a4624fa213cc2330c8923">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_ATTR_DEQ_DEPTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_ATTR_DEQ_DEPTH&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The queue depth of the port on the dequeue side </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00798">798</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a60a28fba179c8b08f42eaab7f3683a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a28fba179c8b08f42eaab7f3683a39">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_ATTR_NEW_EVENT_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_ATTR_NEW_EVENT_THRESHOLD&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The new event threshold of the port </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00802">802</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aebf25098a79d7e3ad4fd936737808a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf25098a79d7e3ad4fd936737808a9f">&#9670;&nbsp;</a></span>RTE_EVENT_PORT_ATTR_IMPLICIT_RELEASE_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_PORT_ATTR_IMPLICIT_RELEASE_DISABLE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The implicit release disable attribute of the port </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00806">806</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a366ab13bc5be32cbc9ee15e294b4c9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ab13bc5be32cbc9ee15e294b4c9a2">&#9670;&nbsp;</a></span>RTE_SCHED_TYPE_ORDERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SCHED_TYPE_ORDERED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordered scheduling</p>
<p>Events from an ordered flow of an event queue can be scheduled to multiple ports for concurrent processing while maintaining the original event order. This scheme enables the user to achieve high single flow throughput by avoiding SW synchronization for ordering between ports which bound to cores.</p>
<p>The source flow ordering from an event queue is maintained when events are enqueued to their destination queue within the same ordered flow context. An event port holds the context until application call <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> from the same port, which implicitly releases the context. User may allow the scheduler to release the context earlier than that by invoking <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> with RTE_EVENT_OP_RELEASE operation.</p>
<p>Events from the source queue appear in their original order when dequeued from a destination queue. Event ordering is based on the received event(s), but also other (newly allocated or stored) events are ordered when enqueued within the same ordered context. Events not enqueued (e.g. released or stored) within the context are considered missing from reordering and are skipped at this time (but can be ordered again within another context).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, <a class="el" href="rte__eventdev_8h.html#ab927860cf68a0c0a8caf96fe9feb2a23">RTE_EVENT_OP_RELEASE</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a1">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a36">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a40">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a78">examples/ipsec-secgw/ipsec-secgw.c</a>, <a class="el" href="examples_2l2fwd-event_2main_8c-example.html#a0">examples/l2fwd-event/main.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a15">examples/l3fwd/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00942">942</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a3c199a28e97411266a069bd07c9757fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c199a28e97411266a069bd07c9757fa">&#9670;&nbsp;</a></span>RTE_SCHED_TYPE_ATOMIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SCHED_TYPE_ATOMIC&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic scheduling</p>
<p>Events from an atomic flow of an event queue can be scheduled only to a single port at a time. The port is guaranteed to have exclusive (atomic) access to the associated flow context, which enables the user to avoid SW synchronization. Atomic flows also help to maintain event ordering since only one port at a time can process events from a flow of an event queue.</p>
<p>The atomic queue synchronization context is dedicated to the port until application call <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> from the same port, which implicitly releases the context. User may allow the scheduler to release the context earlier than that by invoking <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> with RTE_EVENT_OP_RELEASE operation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, <a class="el" href="rte__eventdev_8h.html#ab927860cf68a0c0a8caf96fe9feb2a23">RTE_EVENT_OP_RELEASE</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a0">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a14">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a22">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a79">examples/ipsec-secgw/ipsec-secgw.c</a>, <a class="el" href="examples_2l2fwd-event_2main_8c-example.html#a1">examples/l2fwd-event/main.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_8c-example.html#a3">examples/l3fwd/l3fwd_event.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a16">examples/l3fwd/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00961">961</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ac88982845a12ff215c721fccb18ed4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88982845a12ff215c721fccb18ed4a7">&#9670;&nbsp;</a></span>RTE_SCHED_TYPE_PARALLEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_SCHED_TYPE_PARALLEL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parallel scheduling</p>
<p>The scheduler performs priority scheduling, load balancing, etc. functions but does not provide additional event synchronization or ordering. It is free to schedule events from a single parallel flow of an event queue to multiple events ports for concurrent processing. The application is responsible for flow context synchronization and event ordering (SW synchronization).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a>, <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a2">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a37">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a41">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a80">examples/ipsec-secgw/ipsec-secgw.c</a>, <a class="el" href="examples_2l2fwd-event_2main_8c-example.html#a2">examples/l2fwd-event/main.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a17">examples/l3fwd/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00974">974</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ae5a711c45b3d3f125069b1a7cb731435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a711c45b3d3f125069b1a7cb731435">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_ETHDEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_ETHDEV&#160;&#160;&#160;0x0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from ethdev subsystem </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a41">examples/ipsec-secgw/event_helper.c</a>, and <a class="el" href="examples_2ipsec-secgw_2ipsec_worker_8c-example.html#a43">examples/ipsec-secgw/ipsec_worker.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00978">978</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a982ad2bf50bd73e7cdbe2a62e5d581f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982ad2bf50bd73e7cdbe2a62e5d581f6">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_CRYPTODEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_CRYPTODEV&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from crypodev subsystem </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00980">980</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a247d3e6500516ff097e06f199dfb5cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247d3e6500516ff097e06f199dfb5cc3">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_TIMER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_TIMER&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from event timer adapter </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00982">982</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ac15be67634b343dc7dc7b6d63630abdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15be67634b343dc7dc7b6d63630abdd">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_CPU</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_CPU&#160;&#160;&#160;0x3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from cpu for pipelining. Application may use <em>sub_event_type</em> to further classify the event </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a3">examples/eventdev_pipeline/pipeline_worker_tx.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00986">986</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a934df8149a7a1a4cfcdbb18a880d837c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934df8149a7a1a4cfcdbb18a880d837c">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_ETH_RX_ADAPTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_ETH_RX_ADAPTER&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event generated from event eth Rx adapter </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00988">988</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a351dba845f2d001f6245fd41692d8c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351dba845f2d001f6245fd41692d8c9e">&#9670;&nbsp;</a></span>RTE_EVENT_TYPE_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TYPE_MAX&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of event types </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00990">990</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aa69a0db3e4653c786aef1febe7594b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69a0db3e4653c786aef1febe7594b78">&#9670;&nbsp;</a></span>RTE_EVENT_OP_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_OP_NEW&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event producers use this operation to inject a new event to the event device. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00996">996</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a416488eee18e9e740dba1c61a312f06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416488eee18e9e740dba1c61a312f06a">&#9670;&nbsp;</a></span>RTE_EVENT_OP_FORWARD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_OP_FORWARD&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The CPU use this operation to forward the event to different event queue or change to new application specific flow or schedule type to enable pipelining.</p>
<p>This operation must only be enqueued to the same port that the event to be forwarded was dequeued from. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a10">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a5">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a28">examples/l2fwd-event/l2fwd_event.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_em_8c-example.html#a48">examples/l3fwd/l3fwd_em.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_lpm_8c-example.html#a32">examples/l3fwd/l3fwd_lpm.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01004">1004</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ab927860cf68a0c0a8caf96fe9feb2a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab927860cf68a0c0a8caf96fe9feb2a23">&#9670;&nbsp;</a></span>RTE_EVENT_OP_RELEASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_OP_RELEASE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release the flow context associated with the schedule type.</p>
<p>If current flow's scheduler type method is <em>RTE_SCHED_TYPE_ATOMIC</em> then this function hints the scheduler that the user has completed critical section processing in the current atomic context. The scheduler is now allowed to schedule events from the same flow from an event queue to another port. However, the context may be still held until the next <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> call, this call allows but does not force the scheduler to release the context early.</p>
<p>Early atomic context release may increase parallelism and thus system performance, but the user needs to design carefully the split into critical vs non-critical sections.</p>
<p>If current flow's scheduler type method is <em>RTE_SCHED_TYPE_ORDERED</em> then this function hints the scheduler that the user has done all that need to maintain event order in the current ordered context. The scheduler is allowed to release the ordered context of this port and avoid reordering any following enqueues.</p>
<p>Early ordered context release may increase parallelism and thus system performance.</p>
<p>If current flow's scheduler type method is <em>RTE_SCHED_TYPE_PARALLEL</em> or no scheduling context is held then this function may be an NOOP, depending on the implementation.</p>
<p>This operation must only be enqueued to the same port that the event to be released was dequeued from. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a18">examples/eventdev_pipeline/pipeline_worker_tx.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01036">1036</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a0938b6c89c22b3de3ee9e8bfa1da2ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0938b6c89c22b3de3ee9e8bfa1da2ae7">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_RX_ADAPTER_CAP_INTERNAL_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_RX_ADAPTER_CAP_INTERNAL_PORT&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag is sent when the packet transfer mechanism is in HW. Ethdev can send packets to the event device using internal event port. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a89">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a86">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, and <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a6">examples/ipsec-secgw/event_helper.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01118">1118</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ac3abde85e981790ae41c69ad7df33b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3abde85e981790ae41c69ad7df33b75">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_RX_ADAPTER_CAP_MULTI_EVENTQ&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapter supports multiple event queues per ethdev. Every ethdev Rx queue can be connected to a unique event queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01122">1122</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a8d39c45789a6d8c808b08c57057f715c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d39c45789a6d8c808b08c57057f715c">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_RX_ADAPTER_CAP_OVERRIDE_FLOW_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_RX_ADAPTER_CAP_OVERRIDE_FLOW_ID&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The application can override the adapter generated flow ID in the event. This flow ID can be specified when adding an ethdev Rx queue to the adapter using the ev member of struct rte_event_eth_rx_adapter </p><dl class="section see"><dt>See also</dt><dd>struct <a class="el" href="structrte__event__eth__rx__adapter__queue__conf.html#ace15ae1b604b29456e25bfb3f73fbc8a">rte_event_eth_rx_adapter_queue_conf::ev</a> </dd>
<dd>
struct <a class="el" href="structrte__event__eth__rx__adapter__queue__conf.html#a10784c91ca56bcc794c9cbe05eeb6499">rte_event_eth_rx_adapter_queue_conf::rx_queue_flags</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01129">1129</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aee3ed17910cfdeb061734fe14f9651fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3ed17910cfdeb061734fe14f9651fc">&#9670;&nbsp;</a></span>RTE_EVENT_TIMER_ADAPTER_CAP_INTERNAL_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_TIMER_ADAPTER_CAP_INTERNAL_PORT&#160;&#160;&#160;(1ULL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag is set when the timer mechanism is in HW. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01155">1155</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a832fc0958c7dedc25a4c294d7bc08c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832fc0958c7dedc25a4c294d7bc08c48">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_NEW&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of generating events in RTE_EVENT_OP_NEW enqueue operation. Cryptodev will send packets to the event device as new events using an internal event port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01179">1179</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="aafffb3091cacef210c8710c7bb717311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafffb3091cacef210c8710c7bb717311">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_FWD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_OP_FWD&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of generating events in RTE_EVENT_OP_FORWARD enqueue operation. Cryptodev will send packets to the event device as forwarded event using an internal event port. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01186">1186</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a7594e773a009ba1c9c2e19f413125893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7594e773a009ba1c9c2e19f413125893">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_QP_EV_BIND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_INTERNAL_PORT_QP_EV_BIND&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW is capable of mapping crypto queue pair to event queue. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01191">1191</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ab07cd5e93133ab8aa760e3eb17a3b81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07cd5e93133ab8aa760e3eb17a3b81b">&#9670;&nbsp;</a></span>RTE_EVENT_CRYPTO_ADAPTER_CAP_SESSION_PRIVATE_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_CRYPTO_ADAPTER_CAP_SESSION_PRIVATE_DATA&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag indicates HW/SW supports a mechanism to store and retrieve the private data information along with the crypto session. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01196">1196</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a3b6c6cbdc5b9091cc561ab38983be324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6c6cbdc5b9091cc561ab38983be324">&#9670;&nbsp;</a></span>RTE_EVENT_ETH_TX_ADAPTER_CAP_INTERNAL_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_ETH_TX_ADAPTER_CAP_INTERNAL_PORT&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flag is sent when the PMD supports a packet transmit callback </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a6">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a8">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a15">examples/l2fwd-event/l2fwd_event.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_8c-example.html#a26">examples/l3fwd/l3fwd_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01225">1225</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="ae0248ac6e03597e9a8c57a96cd38f8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0248ac6e03597e9a8c57a96cd38f8e1">&#9670;&nbsp;</a></span>RTE_EVENT_DEV_XSTATS_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EVENT_DEV_XSTATS_NAME_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum name length for extended statistics counters </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01873">1873</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac602147b65d5e9a7367f970710fccaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac602147b65d5e9a7367f970710fccaec">&#9670;&nbsp;</a></span>eventdev_stop_flush_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* eventdev_stop_flush_t) (uint8_t dev_id, struct <a class="el" href="structrte__event.html">rte_event</a> event, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function called during <a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a>, invoked once per flushed event. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l00868">868</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a505adb6f39a9108c494df8070312dee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505adb6f39a9108c494df8070312dee5">&#9670;&nbsp;</a></span>rte_event_dev_xstats_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the component of the eventdev to retrieve statistics from. </p>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01878">1878</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6541eb8822285c7b77455636201d5134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6541eb8822285c7b77455636201d5134">&#9670;&nbsp;</a></span>rte_event_dev_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rte_event_dev_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of event devices that have been successfully initialised.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of usable event devices. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a22">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a24">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a28">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a12">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a34">examples/l2fwd-event/l2fwd_event.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_8c-example.html#a29">examples/l3fwd/l3fwd_event.c</a>.</dd>
</dl>

</div>
</div>
<a id="a7da264acd9bd0da6795801c6568f0387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da264acd9bd0da6795801c6568f0387">&#9670;&nbsp;</a></span>rte_event_dev_get_dev_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_get_dev_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the device identifier for the named event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Event device name to select the event device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns event device identifier on success.<ul>
<li>&lt;0: Failure to find named event device. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae92ef37cd075e2db64d4f358b939c205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92ef37cd075e2db64d4f358b939c205">&#9670;&nbsp;</a></span>rte_event_dev_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_socket_id </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the NUMA socket to which a device is connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The NUMA socket id to which the device is connected or a default of zero if the socket could not be determined. -(-EINVAL) dev_id value is out of range. </dd></dl>

</div>
</div>
<a id="a5bd7355a0be9b94bbca0f32796e57358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd7355a0be9b94bbca0f32796e57358">&#9670;&nbsp;</a></span>rte_event_dev_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_info_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__dev__info.html">rte_event_dev_info</a> *&#160;</td>
          <td class="paramname"><em>dev_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the contextual information of an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev_info</td><td>A pointer to a structure of type <em><a class="el" href="structrte__event__dev__info.html">rte_event_dev_info</a></em> to be filled with the contextual information of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the contextual information of the event device</li>
<li>&lt;0: Error code returned by the driver info get function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a8">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a26">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a30">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a10">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a6">examples/l2fwd-event/l2fwd_event.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a4">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a4">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a4">examples/l3fwd/l3fwd_event_generic.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a4">examples/l3fwd/l3fwd_event_internal_port.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a57">examples/l3fwd/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a79e78537e4554caf73c13c79e8a3cd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e78537e4554caf73c13c79e8a3cd06">&#9670;&nbsp;</a></span>rte_event_dev_attr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_attr_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an attribute from a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>Eventdev id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attr_id</td><td>The attribute ID to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr_value</td><td>A pointer that will be filled in with the attribute value if successful.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully retrieved attribute value</li>
<li>-EINVAL: Invalid device or <em>attr_id</em> provided, or <em>attr_value</em> is NULL </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af1e7d0094442b3a158e89f120a21687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e7d0094442b3a158e89f120a21687d">&#9670;&nbsp;</a></span>rte_event_dev_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_configure </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event__dev__config.html">rte_event_dev_config</a> *&#160;</td>
          <td class="paramname"><em>dev_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an event device.</p>
<p>This function must be invoked first before any other function in the API. This function can also be re-invoked when a device is in the stopped state.</p>
<p>The caller may use <a class="el" href="rte__eventdev_8h.html#a5bd7355a0be9b94bbca0f32796e57358">rte_event_dev_info_get()</a> to get the capability of each resources available for this event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">dev_conf</td><td>The event device configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device configured.</li>
<li>&lt;0: Error code returned by the driver configuration function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a33">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a34">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a19">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a23">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a22">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a23">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a22">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

</div>
</div>
<a id="a57d3f2bd3f600cdc3d8724844cbbcf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d3f2bd3f600cdc3d8724844cbbcf20">&#9670;&nbsp;</a></span>rte_event_queue_default_conf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_queue_default_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a> *&#160;</td>
          <td class="paramname"><em>queue_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the default configuration information of an event queue designated by its <em>queue_id</em> from the event driver for an event device.</p>
<p>This function intended to be used in conjunction with <a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a> where caller needs to set up the queue by overriding few default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_id</td><td>The index of the event queue to get the configuration information. The value must be in the range [0, nb_event_queues - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_conf</td><td>The pointer to the default event queue configuration data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the default event queue configuration data.</li>
<li>&lt;0: Error code returned by the driver info get function.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a40">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a38">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a40">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a38">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

</div>
</div>
<a id="a57a1db34b6c7bb2b05a5db7aab8c6834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1db34b6c7bb2b05a5db7aab8c6834">&#9670;&nbsp;</a></span>rte_event_queue_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event__queue__conf.html">rte_event_queue_conf</a> *&#160;</td>
          <td class="paramname"><em>queue_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up an event queue for an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the event queue to setup. The value must be in the range [0, nb_event_queues - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">queue_conf</td><td>The pointer to the configuration data to be used for the event queue. NULL value is allowed, in which case default configuration used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a57d3f2bd3f600cdc3d8724844cbbcf20">rte_event_queue_default_conf_get()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, event queue correctly set up.</li>
<li>&lt;0: event queue configuration failed </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a34">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a37">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a25">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a41">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a41">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a41">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a41">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

</div>
</div>
<a id="a9f6d7fa11b04003ff32884d83ae04960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6d7fa11b04003ff32884d83ae04960">&#9670;&nbsp;</a></span>rte_event_queue_attr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_queue_attr_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an attribute from a queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>Eventdev id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_id</td><td>Eventdev queue id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attr_id</td><td>The attribute ID to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr_value</td><td>A pointer that will be filled in with the attribute value if successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully returned value</li>
<li>-EINVAL: invalid device, queue or attr_id provided, or attr_value was NULL</li>
<li>-EOVERFLOW: returned when attr_id is set to RTE_EVENT_QUEUE_ATTR_SCHEDULE_TYPE and event_queue_cfg is set to RTE_EVENT_QUEUE_CFG_ALL_TYPES </li>
</ul>
</dd></dl>

</div>
</div>
<a id="abf86b3088e02126b06be3c0a5ac07bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf86b3088e02126b06be3c0a5ac07bb7">&#9670;&nbsp;</a></span>rte_event_port_default_conf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_default_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a> *&#160;</td>
          <td class="paramname"><em>port_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the default configuration information of an event port designated by its <em>port_id</em> from the event driver for an event device.</p>
<p>This function intended to be used in conjunction with <a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a> where caller needs to set up the port by overriding few default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>The index of the event port to get the configuration information. The value must be in the range [0, nb_event_ports - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port_conf</td><td>The pointer to the default event port configuration data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the default event port configuration data.</li>
<li>&lt;0: Error code returned by the driver info get function.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ac087670e6e885abcdf046c8e74844cd4">rte_event_port_setup()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a27">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a26">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a27">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a26">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

</div>
</div>
<a id="ac087670e6e885abcdf046c8e74844cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac087670e6e885abcdf046c8e74844cd4">&#9670;&nbsp;</a></span>rte_event_port_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_setup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event__port__conf.html">rte_event_port_conf</a> *&#160;</td>
          <td class="paramname"><em>port_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up an event port for an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The index of the event port to setup. The value must be in the range [0, nb_event_ports - 1] previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">port_conf</td><td>The pointer to the configuration data to be used for the queue. NULL value is allowed, in which case default configuration used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#abf86b3088e02126b06be3c0a5ac07bb7">rte_event_port_default_conf_get()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, event port correctly set up.</li>
<li>&lt;0: Port configuration failed</li>
<li>(-EDQUOT) Quota exceeded(Application tried to link the queue configured with RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports) </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a40">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a44">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a26">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a32">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a31">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a32">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a31">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

</div>
</div>
<a id="aa1cc781b1ab9af77077c6c91eab37220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cc781b1ab9af77077c6c91eab37220">&#9670;&nbsp;</a></span>rte_event_port_attr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_attr_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an attribute from a port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>Eventdev id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>Eventdev port id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attr_id</td><td>The attribute ID to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr_value</td><td>A pointer that will be filled in with the attribute value if successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Successfully returned value</li>
<li>(-EINVAL) Invalid device, port or attr_id, or attr_value was NULL </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab6e99f06a45adaa095b257b93ebaf201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e99f06a45adaa095b257b93ebaf201">&#9670;&nbsp;</a></span>rte_event_dev_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an event device.</p>
<p>The device start step is the last one and consists of setting the event queues to start accepting the events and schedules to event ports.</p>
<p>On success, all basic functions exported by the API (event enqueue, event dequeue and so on) can be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Event device identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device started.</li>
<li>-ESTALE : Not all ports of the device are configured</li>
<li>-ENOLINK: Not all queues are linked, which could lead to deadlock. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a85">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a49">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a28">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a36">examples/l2fwd-event/l2fwd_event.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_8c-example.html#a30">examples/l3fwd/l3fwd_event.c</a>.</dd>
</dl>

</div>
</div>
<a id="a644f6cc4ab24a5c07bfff9b0f5c42e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644f6cc4ab24a5c07bfff9b0f5c42e8e">&#9670;&nbsp;</a></span>rte_event_dev_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_event_dev_stop </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop an event device.</p>
<p>This function causes all queued events to be drained, including those residing in event ports. While draining events out of the device, this function calls the user-provided flush callback (if one was registered) once per event.</p>
<p>The device can be restarted with a call to <a class="el" href="rte__eventdev_8h.html#ab6e99f06a45adaa095b257b93ebaf201">rte_event_dev_start()</a>. Threads that continue to enqueue/dequeue while the device is stopped, or being stopped, will result in undefined behavior. This includes event adapters, which must be stopped prior to stopping the eventdev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Event device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ab856d854c98af5d73490b9958cb624d7">rte_event_dev_stop_flush_callback_register()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a29">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a64">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2main_8c-example.html#a34">examples/l2fwd-event/main.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a75">examples/l3fwd/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="ab856d854c98af5d73490b9958cb624d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab856d854c98af5d73490b9958cb624d7">&#9670;&nbsp;</a></span>rte_event_dev_stop_flush_callback_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_stop_flush_callback_register </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__eventdev_8h.html#ac602147b65d5e9a7367f970710fccaec">eventdev_stop_flush_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function to be invoked during <a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a> for each flushed event. This function can be used to properly dispose of queued events, for example events containing memory pointers.</p>
<p>The callback function is only registered for the calling process. The callback function must be registered in every process that can call <a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a>.</p>
<p>To unregister a callback, call this function with a NULL callback pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function invoked once per flushed event. </td></tr>
    <tr><td class="paramname">userdata</td><td>Argument supplied to callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success.</li>
<li>-EINVAL if <em>dev_id</em> is invalid</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a644f6cc4ab24a5c07bfff9b0f5c42e8e">rte_event_dev_stop()</a> </dd></dl>

</div>
</div>
<a id="af70f4ed704d89a4ffce3b4c105bac076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70f4ed704d89a4ffce3b4c105bac076">&#9670;&nbsp;</a></span>rte_event_dev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_close </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an event device. The device cannot be restarted!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Event device identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on successfully closing device</li>
<li>&lt;0 on failure to close device</li>
<li>(-EAGAIN) if device is busy </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a30">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a65">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2main_8c-example.html#a35">examples/l2fwd-event/main.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a76">examples/l3fwd/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a56aa49dc89eb44d2e35bd72bd809db17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56aa49dc89eb44d2e35bd72bd809db17">&#9670;&nbsp;</a></span>rte_event_eth_rx_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_eth_rx_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eth_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's ethdev Rx adapter capabilities for the specified ethernet port</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eth_port_id</td><td>The identifier of the ethernet device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory filled with Rx event adapter capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provides Rx event adapter capabilities for the ethernet device.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a88">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a84">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a5">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a10">examples/l2fwd-event/l2fwd_event.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a60">examples/l3fwd/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a78649b804d0c880dd23b23fcd28100f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78649b804d0c880dd23b23fcd28100f9">&#9670;&nbsp;</a></span>rte_event_timer_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_timer_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's timer adapter capabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory to be filled with event timer adapter capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provided event timer adapter capabilities.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6b478480a0d8d93b20622be566c127ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b478480a0d8d93b20622be566c127ee">&#9670;&nbsp;</a></span>rte_event_crypto_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_crypto_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cdev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's crypto adapter capabilities for the specified cryptodev device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cdev_id</td><td>The identifier of the cryptodev device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory filled with event adapter capabilities. It is expected to be pre-allocated &amp; initialized by caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provides event adapter capabilities for the cryptodev device.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad147297659da4017ff8a8cec1757548c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad147297659da4017ff8a8cec1757548c">&#9670;&nbsp;</a></span>rte_event_eth_tx_adapter_caps_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_eth_tx_adapter_caps_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eth_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>caps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the event device's eth Tx adapter capabilities</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eth_port_id</td><td>The identifier of the ethernet device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>A pointer to memory filled with eth Tx adapter capabilities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver provides eth Tx adapter capabilities.</li>
<li>&lt;0: Error code returned by the driver function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a4">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a7">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a12">examples/l2fwd-event/l2fwd_event.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_8c-example.html#a25">examples/l3fwd/l3fwd_event.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a62">examples/l3fwd/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="afc6b7f3fd1b11858a2db91864708f9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6b7f3fd1b11858a2db91864708f9a4">&#9670;&nbsp;</a></span>rte_event_enqueue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_enqueue_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event.html">rte_event</a>&#160;</td>
          <td class="paramname"><em>ev</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of events objects or an event object supplied in <em><a class="el" href="structrte__event.html">rte_event</a></em> structure on an event device designated by its <em>dev_id</em> through the event port specified by <em>port_id</em>. Each event object specifies the event queue on which it will be enqueued.</p>
<p>The <em>nb_events</em> parameter is the number of event objects to enqueue which are supplied in the <em>ev</em> array of <em><a class="el" href="structrte__event.html">rte_event</a></em> structure.</p>
<p>Event operations RTE_EVENT_OP_FORWARD and RTE_EVENT_OP_RELEASE must only be enqueued to the same port that their associated events were dequeued from.</p>
<p>The <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> function returns the number of events objects it actually enqueued. A return value equal to <em>nb_events</em> means that all event objects have been enqueued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramname">ev</td><td>Points to an array of <em>nb_events</em> objects of type <em><a class="el" href="structrte__event.html">rte_event</a></em> structure which contain the event object enqueue operations to be processed. </td></tr>
    <tr><td class="paramname">nb_events</td><td>The number of event objects to enqueue, typically number of rte_event_port_attr_get(...RTE_EVENT_PORT_ATTR_ENQ_DEPTH...) available for this port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event objects actually enqueued on the event device. The return value can be less than the value of the <em>nb_events</em> parameter when the event devices queue is full or if invalid parameters are specified in a <em><a class="el" href="structrte__event.html">rte_event</a></em>. If the return value is less than <em>nb_events</em>, the remaining events at the end of ev[] are not consumed and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL The port ID is invalid, device ID is invalid, an event's queue ID is invalid, or an event's sched type doesn't match the capabilities of the destination queue.</li>
<li>ENOSPC The event port was backpressured and unable to enqueue one or more events. This error code is only applicable to closed systems. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#aa1cc781b1ab9af77077c6c91eab37220">rte_event_port_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a40fc8695cb074e656ab5eadf286b0f08">RTE_EVENT_PORT_ATTR_ENQ_DEPTH</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a12">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a8">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a32">examples/l2fwd-event/l2fwd_event.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_em_8c-example.html#a49">examples/l3fwd/l3fwd_em.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_lpm_8c-example.html#a33">examples/l3fwd/l3fwd_lpm.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01438">1438</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a9b9c183571cdd91c8a1c70fc6a6c1241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9c183571cdd91c8a1c70fc6a6c1241">&#9670;&nbsp;</a></span>rte_event_enqueue_new_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_enqueue_new_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event.html">rte_event</a>&#160;</td>
          <td class="paramname"><em>ev</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of events objects of operation type <em>RTE_EVENT_OP_NEW</em> on an event device designated by its <em>dev_id</em> through the event port specified by <em>port_id</em>.</p>
<p>Provides the same functionality as <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a>, expect that application can use this API when the all objects in the burst contains the enqueue operation of the type <em>RTE_EVENT_OP_NEW</em>. This specialized function can provide the additional hint to the PMD and optimize if possible.</p>
<p>The <a class="el" href="rte__eventdev_8h.html#a9b9c183571cdd91c8a1c70fc6a6c1241">rte_event_enqueue_new_burst()</a> result is undefined if the enqueue burst has event object of operation type != RTE_EVENT_OP_NEW.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramname">ev</td><td>Points to an array of <em>nb_events</em> objects of type <em><a class="el" href="structrte__event.html">rte_event</a></em> structure which contain the event object enqueue operations to be processed. </td></tr>
    <tr><td class="paramname">nb_events</td><td>The number of event objects to enqueue, typically number of rte_event_port_attr_get(...RTE_EVENT_PORT_ATTR_ENQ_DEPTH...) available for this port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event objects actually enqueued on the event device. The return value can be less than the value of the <em>nb_events</em> parameter when the event devices queue is full or if invalid parameters are specified in a <em><a class="el" href="structrte__event.html">rte_event</a></em>. If the return value is less than <em>nb_events</em>, the remaining events at the end of ev[] are not consumed and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL The port ID is invalid, device ID is invalid, an event's queue ID is invalid, or an event's sched type doesn't match the capabilities of the destination queue.</li>
<li>ENOSPC The event port was backpressured and unable to enqueue one or more events. This error code is only applicable to closed systems. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#aa1cc781b1ab9af77077c6c91eab37220">rte_event_port_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a40fc8695cb074e656ab5eadf286b0f08">RTE_EVENT_PORT_ATTR_ENQ_DEPTH</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01489">1489</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a2a6260ce13081213f8eb8b1b4da935ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6260ce13081213f8eb8b1b4da935ad">&#9670;&nbsp;</a></span>rte_event_enqueue_forward_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_enqueue_forward_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__event.html">rte_event</a>&#160;</td>
          <td class="paramname"><em>ev</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of events objects of operation type <em>RTE_EVENT_OP_FORWARD</em> on an event device designated by its <em>dev_id</em> through the event port specified by <em>port_id</em>.</p>
<p>Provides the same functionality as <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a>, expect that application can use this API when the all objects in the burst contains the enqueue operation of the type <em>RTE_EVENT_OP_FORWARD</em>. This specialized function can provide the additional hint to the PMD and optimize if possible.</p>
<p>The <a class="el" href="rte__eventdev_8h.html#a9b9c183571cdd91c8a1c70fc6a6c1241">rte_event_enqueue_new_burst()</a> result is undefined if the enqueue burst has event object of operation type != RTE_EVENT_OP_FORWARD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramname">ev</td><td>Points to an array of <em>nb_events</em> objects of type <em><a class="el" href="structrte__event.html">rte_event</a></em> structure which contain the event object enqueue operations to be processed. </td></tr>
    <tr><td class="paramname">nb_events</td><td>The number of event objects to enqueue, typically number of rte_event_port_attr_get(...RTE_EVENT_PORT_ATTR_ENQ_DEPTH...) available for this port.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event objects actually enqueued on the event device. The return value can be less than the value of the <em>nb_events</em> parameter when the event devices queue is full or if invalid parameters are specified in a <em><a class="el" href="structrte__event.html">rte_event</a></em>. If the return value is less than <em>nb_events</em>, the remaining events at the end of ev[] are not consumed and the caller has to take care of them, and rte_errno is set accordingly. Possible errno values include:<ul>
<li>EINVAL The port ID is invalid, device ID is invalid, an event's queue ID is invalid, or an event's sched type doesn't match the capabilities of the destination queue.</li>
<li>ENOSPC The event port was backpressured and unable to enqueue one or more events. This error code is only applicable to closed systems. </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#aa1cc781b1ab9af77077c6c91eab37220">rte_event_port_attr_get()</a>, <a class="el" href="rte__eventdev_8h.html#a40fc8695cb074e656ab5eadf286b0f08">RTE_EVENT_PORT_ATTR_ENQ_DEPTH</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01540">1540</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a245cbc6e55632565a57f6f98f492428f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245cbc6e55632565a57f6f98f492428f">&#9670;&nbsp;</a></span>rte_event_dequeue_timeout_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dequeue_timeout_ticks </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>timeout_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts nanoseconds to <em>timeout_ticks</em> value for <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a></p>
<p>If the device is configured with RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT flag then application can use this function to convert timeout value in nanoseconds to implementations specific timeout value supplied in <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ns</td><td>Wait time in nanosecond </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeout_ticks</td><td>Value for the <em>timeout_ticks</em> parameter in <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success.</li>
<li>-ENOTSUP if the device doesn't support timeouts</li>
<li>-EINVAL if <em>dev_id</em> is invalid or <em>timeout_ticks</em> is NULL</li>
<li>other values &lt; 0 on failure.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a>, <a class="el" href="rte__eventdev_8h.html#aedc71a4c2e35b5b23fe6fcf593c5909a">RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT</a> </dd>
<dd>
<a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a> </dd></dl>

</div>
</div>
<a id="a2af1610d3ede24979267333cf2da1aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af1610d3ede24979267333cf2da1aab">&#9670;&nbsp;</a></span>rte_event_dequeue_burst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_event_dequeue_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event.html">rte_event</a>&#160;</td>
          <td class="paramname"><em>ev</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_ticks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of events objects or an event object from the event port designated by its <em>event_port_id</em>, on an event device designated by its <em>dev_id</em>.</p>
<p><a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> does not dictate the specifics of scheduling algorithm as each eventdev driver may have different criteria to schedule an event. However, in general, from an application perspective scheduler may use the following scheme to dispatch an event to the port.</p>
<p>1) Selection of event queue based on a) The list of event queues are linked to the event port. b) If the device has RTE_EVENT_DEV_CAP_QUEUE_QOS capability then event queue selection from list is based on event queue priority relative to other event queue supplied as <em>priority</em> in <a class="el" href="rte__eventdev_8h.html#a57a1db34b6c7bb2b05a5db7aab8c6834">rte_event_queue_setup()</a> c) If the device has RTE_EVENT_DEV_CAP_EVENT_QOS capability then event queue selection from the list is based on event priority supplied as <em>priority</em> in <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> 2) Selection of event a) The number of flows available in selected event queue. b) Schedule type method associated with the event</p>
<p>The <em>nb_events</em> parameter is the maximum number of event objects to dequeue which are returned in the <em>ev</em> array of <em><a class="el" href="structrte__event.html">rte_event</a></em> structure.</p>
<p>The <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> function returns the number of events objects it actually dequeued. A return value equal to <em>nb_events</em> means that all event objects have been dequeued.</p>
<p>The number of events dequeued is the number of scheduler contexts held by this port. These contexts are automatically released in the next <a class="el" href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst()</a> invocation if the port supports implicit releases, or invoking <a class="el" href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst()</a> with RTE_EVENT_OP_RELEASE operation can be used to release the contexts early.</p>
<p>Event operations RTE_EVENT_OP_FORWARD and RTE_EVENT_OP_RELEASE must only be enqueued to the same port that their associated events were dequeued from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>The identifier of the event port. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ev</td><td>Points to an array of <em>nb_events</em> objects of type <em><a class="el" href="structrte__event.html">rte_event</a></em> structure for output to be populated with the dequeued event objects. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_events</td><td>The maximum number of event objects to dequeue, typically number of rte_event_port_dequeue_depth() available for this port.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout_ticks</td><td><ul>
<li>0 no-wait, returns immediately if there is no event.</li>
<li>&gt;0 wait for the event, if the device is configured with RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT then this function will wait until at least one event is available or <em>timeout_ticks</em> time. if the device is not configured with RTE_EVENT_DEV_CFG_PER_DEQUEUE_TIMEOUT then this function will wait until the event available or <em>dequeue_timeout_ns</em> ns which was previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event objects actually dequeued from the port. The return value can be less than the value of the <em>nb_events</em> parameter when the event port's queue is not full.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>rte_event_port_dequeue_depth() </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a4">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a13">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec_worker_8c-example.html#a38">examples/ipsec-secgw/ipsec_worker.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a31">examples/l2fwd-event/l2fwd_event.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_em_8c-example.html#a45">examples/l3fwd/l3fwd_em.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_lpm_8c-example.html#a30">examples/l3fwd/l3fwd_lpm.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__eventdev_8h_source.html#l01645">1645</a> of file <a class="el" href="rte__eventdev_8h_source.html">rte_eventdev.h</a>.</p>

</div>
</div>
<a id="a27f0abd90e6784a4dc1c4f07ece2715a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f0abd90e6784a4dc1c4f07ece2715a">&#9670;&nbsp;</a></span>rte_event_port_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_link </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>priorities</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_links</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link multiple source event queues supplied in <em>queues</em> to the destination event port designated by its <em>port_id</em> with associated service priority supplied in <em>priorities</em> on the event device designated by its <em>dev_id</em>.</p>
<p>The link establishment shall enable the event port <em>port_id</em> from receiving events from the specified event queue(s) supplied in <em>queues</em></p>
<p>An event queue may link to one or more event ports. The number of links can be established from an event queue to event port is implementation defined.</p>
<p>Event queue(s) to event port link establishment can be changed at runtime without re-configuring the device to support scaling and to reduce the latency of critical work by establishing the link with more event ports at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">port_id</td><td>Event port identifier to select the destination port to link.</td></tr>
    <tr><td class="paramname">queues</td><td>Points to an array of <em>nb_links</em> event queues to be linked to the event port. NULL value is allowed, in which case this function links all the configured event queues <em>nb_event_queues</em> which previously supplied to <a class="el" href="rte__eventdev_8h.html#af1e7d0094442b3a158e89f120a21687d">rte_event_dev_configure()</a> to the event port <em>port_id</em></td></tr>
    <tr><td class="paramname">priorities</td><td>Points to an array of <em>nb_links</em> service priorities associated with each event queue link to event port. The priority defines the event port's servicing priority for event queue, which may be ignored by an implementation. The requested priority should in the range of [RTE_EVENT_DEV_PRIORITY_HIGHEST, RTE_EVENT_DEV_PRIORITY_LOWEST]. The implementation shall normalize the requested priority to implementation supported priority value. NULL value is allowed, in which case this function links the event queues with RTE_EVENT_DEV_PRIORITY_NORMAL servicing priority</td></tr>
    <tr><td class="paramname">nb_links</td><td>The number of links to establish. This parameter is ignored if queues is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of links actually established. The return value can be less than the value of the <em>nb_links</em> parameter when the implementation has the limitation on specific queue to port link establishment or if invalid parameters are specified in <em>queues</em> If the return value is less than <em>nb_links</em>, the remaining links at the end of link[] are not established, and the caller has to take care of them. If return value is less than <em>nb_links</em> then implementation shall update the rte_errno accordingly, Possible rte_errno values are (EDQUOT) Quota exceeded(Application tried to link the queue configured with RTE_EVENT_QUEUE_CFG_SINGLE_LINK to more than one event ports) (EINVAL) Invalid parameter </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a41">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a45">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a27">examples/ipsec-secgw/event_helper.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_generic_8c-example.html#a33">examples/l2fwd-event/l2fwd_event_generic.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_internal_port_8c-example.html#a32">examples/l2fwd-event/l2fwd_event_internal_port.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_event_generic_8c-example.html#a33">examples/l3fwd/l3fwd_event_generic.c</a>, and <a class="el" href="examples_2l3fwd_2l3fwd_event_internal_port_8c-example.html#a32">examples/l3fwd/l3fwd_event_internal_port.c</a>.</dd>
</dl>

</div>
</div>
<a id="ad8dad9f41edf100e192e5610b2f078d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8dad9f41edf100e192e5610b2f078d5">&#9670;&nbsp;</a></span>rte_event_port_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_unlink </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_unlinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlink multiple source event queues supplied in <em>queues</em> from the destination event port designated by its <em>port_id</em> on the event device designated by its <em>dev_id</em>.</p>
<p>The unlink call issues an async request to disable the event port <em>port_id</em> from receiving events from the specified event queue <em>queue_id</em>. Event queue(s) to event port unlink establishment can be changed at runtime without re-configuring the device.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#a065a820ce96a30fd83b54f535ef580d9">rte_event_port_unlinks_in_progress()</a> to poll for completed unlinks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">port_id</td><td>Event port identifier to select the destination port to unlink.</td></tr>
    <tr><td class="paramname">queues</td><td>Points to an array of <em>nb_unlinks</em> event queues to be unlinked from the event port. NULL value is allowed, in which case this function unlinks all the event queue(s) from the event port <em>port_id</em>.</td></tr>
    <tr><td class="paramname">nb_unlinks</td><td>The number of unlinks to establish. This parameter is ignored if queues is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of unlinks successfully requested. The return value can be less than the value of the <em>nb_unlinks</em> parameter when the implementation has the limitation on specific queue to port unlink establishment or if invalid parameters are specified. If the return value is less than <em>nb_unlinks</em>, the remaining queues at the end of queues[] are not unlinked, and the caller has to take care of them. If return value is less than <em>nb_unlinks</em> then implementation shall update the rte_errno accordingly, Possible rte_errno values are (EINVAL) Invalid parameter </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipsec-secgw_2event_helper_8c-example.html#a52">examples/ipsec-secgw/event_helper.c</a>.</dd>
</dl>

</div>
</div>
<a id="a065a820ce96a30fd83b54f535ef580d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065a820ce96a30fd83b54f535ef580d9">&#9670;&nbsp;</a></span>rte_event_port_unlinks_in_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_unlinks_in_progress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of unlinks in progress.</p>
<p>This function provides the application with a method to detect when an unlink has been completed by the implementation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__eventdev_8h.html#ad8dad9f41edf100e192e5610b2f078d5">rte_event_port_unlink()</a> to issue unlink requests.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">port_id</td><td>Event port identifier to select port to check for unlinks in progress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of unlinks that are in progress. A return of zero indicates that there are no outstanding unlink requests. A positive return value indicates the number of unlinks that are in progress, but are not yet complete. A negative return value indicates an error, -EINVAL indicates an invalid parameter passed for <em>dev_id</em> or <em>port_id</em>. </dd></dl>

</div>
</div>
<a id="a0524c6c5b1d32981669c4d84254228a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0524c6c5b1d32981669c4d84254228a1">&#9670;&nbsp;</a></span>rte_event_port_links_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_port_links_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queues</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priorities</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the list of source event queues and its associated service priority linked to the destination event port designated by its <em>port_id</em> on the event device designated by its <em>dev_id</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port_id</td><td>Event port identifier.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>Points to an array of <em>queues</em> for output. The caller has to allocate <em>RTE_EVENT_MAX_QUEUES_PER_DEV</em> bytes to store the event queue(s) linked with event port <em>port_id</em></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">priorities</td><td>Points to an array of <em>priorities</em> for output. The caller has to allocate <em>RTE_EVENT_MAX_QUEUES_PER_DEV</em> bytes to store the service priority associated with each event queue linked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of links established on the event port designated by its <em>port_id</em>.<ul>
<li>&lt;0 on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a335e46a7e6c7b3c17629b007d0a85e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335e46a7e6c7b3c17629b007d0a85e62">&#9670;&nbsp;</a></span>rte_event_dev_service_id_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_service_id_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>service_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the service ID of the event dev. If the adapter doesn't use a rte_service function, this function returns -ESRCH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">service_id</td><td>A pointer to a uint32_t, to be filled in with the service id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>&lt;0: Error code on failure, if the event dev doesn't use a rte_service function, this function returns -ESRCH. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a42">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a46">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2l2fwd-event_2l2fwd_event_8c-example.html#a8">examples/l2fwd-event/l2fwd_event.c</a>, and <a class="el" href="examples_2l3fwd_2main_8c-example.html#a59">examples/l3fwd/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a766ba60306ac044b59d6143c77288c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766ba60306ac044b59d6143c77288c46">&#9670;&nbsp;</a></span>rte_event_dev_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_dump </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump internal information about <em>dev_id</em> to the FILE* provided in <em>f</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">f</td><td>A pointer to a file for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: on success</li>
<li>&lt;0: on failure. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a10">examples/eventdev_pipeline/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a33a9a479f54119d010b9af696a7e661a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a9a479f54119d010b9af696a7e661a">&#9670;&nbsp;</a></span>rte_event_dev_xstats_names_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_xstats_names_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__event__dev__xstats__name.html">rte_event_dev_xstats_name</a> *&#160;</td>
          <td class="paramname"><em>xstats_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve names of extended statistics of an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the event device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mode</td><td>The mode of statistics to retrieve. Choices include the device statistics, port statistics or queue statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_port_id</td><td>Used to specify the port or queue number in queue or port mode, and is ignored in device mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xstats_names</td><td>Block of memory to insert names into. Must be at least size in capacity. If set to NULL, function returns required capacity. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>Block of memory to insert ids into. Must be at least size in capacity. If set to NULL, function returns required capacity. The id values returned can be passed to <em>rte_event_dev_xstats_get</em> to select statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Capacity of xstats_names (number of names). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value lower or equal to size: success. The return value is the number of entries filled in the stats table.</li>
<li>positive value higher than size: error, the given statistics table is too small. The return value corresponds to the size that should be given to succeed. The entries in the table are not valid and shall not be used by the caller.</li>
<li>negative value on error: -ENODEV for invalid <em>dev_id</em> -EINVAL for invalid mode, queue port or id parameters -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad889f39c336e7727791dcce9807a635e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad889f39c336e7727791dcce9807a635e">&#9670;&nbsp;</a></span>rte_event_dev_xstats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_xstats_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>queue_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve extended statistics of an event device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">mode</td><td>The mode of statistics to retrieve. Choices include the device statistics, port statistics or queue statistics. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_port_id</td><td>Used to specify the port or queue number in queue or port mode, and is ignored in device mode. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ids</td><td>The id numbers of the stats to get. The ids can be got from the stat position in the stat list from rte_event_dev_get_xstats_names(), or by using <a class="el" href="rte__eventdev_8h.html#a912e145c33166be1c5d196527e2511c8">rte_event_dev_xstats_by_name_get()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The values for each stats request by ID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>The number of stats requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value: number of stat entries filled into the values array</li>
<li>negative value on error: -ENODEV for invalid <em>dev_id</em> -EINVAL for invalid mode, queue port or id parameters -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a912e145c33166be1c5d196527e2511c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912e145c33166be1c5d196527e2511c8">&#9670;&nbsp;</a></span>rte_event_dev_xstats_by_name_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rte_event_dev_xstats_by_name_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value of a single stat by requesting it by name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The stat name to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>If non-NULL, the numerical id of the stat will be returned, so that further requests for the stat can be got using rte_event_dev_xstats_get, which will be faster as it doesn't need to scan a list of names for the stat. If the stat cannot be found, the id returned will be (unsigned)-1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value or zero: the stat value</li>
<li>negative value: -EINVAL if stat not found, -ENOTSUP if not supported. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a16">examples/eventdev_pipeline/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a6643e9fbaac8254e143182fa61d3f73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6643e9fbaac8254e143182fa61d3f73e">&#9670;&nbsp;</a></span>rte_event_dev_xstats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_xstats_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__eventdev_8h.html#a505adb6f39a9108c494df8070312dee5">rte_event_dev_xstats_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>queue_port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nb_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the values of the xstats of the selected component in the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of the statistics to reset. Choose from device, queue or port. </td></tr>
    <tr><td class="paramname">queue_port_id</td><td>The queue or port to reset. 0 and positive values select ports and queues, while -1 indicates all ports or queues. </td></tr>
    <tr><td class="paramname">ids</td><td>Selects specific statistics to be reset. When NULL, all statistics selected by <em>mode</em> will be reset. If non-NULL, must point to array of at least <em>nb_ids</em> size. </td></tr>
    <tr><td class="paramname">nb_ids</td><td>The number of ids available from the <em>ids</em> array. Ignored when ids is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>zero: successfully reset the statistics to zero</li>
<li>negative value: -EINVAL invalid parameters, -ENOTSUP if not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a592ae650e0315dd61364e1cab3ecd6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592ae650e0315dd61364e1cab3ecd6a7">&#9670;&nbsp;</a></span>rte_event_dev_selftest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_event_dev_selftest </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger the eventdev self test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Selftest successful</li>
<li>-ENOTSUP if the device doesn't support selftest</li>
<li>other values &lt; 0 on failure. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="arte__eventdev_8h_html_afc6b7f3fd1b11858a2db91864708f9a4"><div class="ttname"><a href="rte__eventdev_8h.html#afc6b7f3fd1b11858a2db91864708f9a4">rte_event_enqueue_burst</a></div><div class="ttdeci">static uint16_t rte_event_enqueue_burst(uint8_t dev_id, uint8_t port_id, const struct rte_event ev[], uint16_t nb_events)</div><div class="ttdef"><b>Definition:</b> <a href="rte__eventdev_8h_source.html#l01438">rte_eventdev.h:1438</a></div></div>
<div class="ttc" id="arte__eventdev_8h_html_a2af1610d3ede24979267333cf2da1aab"><div class="ttname"><a href="rte__eventdev_8h.html#a2af1610d3ede24979267333cf2da1aab">rte_event_dequeue_burst</a></div><div class="ttdeci">static uint16_t rte_event_dequeue_burst(uint8_t dev_id, uint8_t port_id, struct rte_event ev[], uint16_t nb_events, uint64_t timeout_ticks)</div><div class="ttdef"><b>Definition:</b> <a href="rte__eventdev_8h_source.html#l01645">rte_eventdev.h:1645</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
