<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_eal/include/rte_memory.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_605c07ae6e02b3d13cc3bf92b6c5e54b.html">librte_eal</a></li><li class="navelem"><a class="el" href="dir_53ac78163efee0ea92d7cd5087265064.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_memory.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;rte_config.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__fbarray_8h_source.html">rte_fbarray.h</a>&gt;</code><br />
</div>
<p><a href="rte__memory_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__memseg__list.html">rte_memseg_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0307f4470d3f391102b0f489fc7d91b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a0307f4470d3f391102b0f489fc7d91b5">SOCKET_ID_ANY</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a0307f4470d3f391102b0f489fc7d91b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211220821cd4194e2730cd90d7ee1fd3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a211220821cd4194e2730cd90d7ee1fd3">RTE_MEMSEG_FLAG_DO_NOT_FREE</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:a211220821cd4194e2730cd90d7ee1fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2594ce23f2876b03ee571c4ee502e3d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a2594ce23f2876b03ee571c4ee502e3d7">RTE_MEM_EVENT_CALLBACK_NAME_LEN</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a2594ce23f2876b03ee571c4ee502e3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd07eb9cc6b4ee89b6a5d9bc71b3877f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#afd07eb9cc6b4ee89b6a5d9bc71b3877f">RTE_MEM_ALLOC_VALIDATOR_NAME_LEN</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:afd07eb9cc6b4ee89b6a5d9bc71b3877f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adbfe16e8d0c9d9ca7a994dff9ba2b5c2"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#adbfe16e8d0c9d9ca7a994dff9ba2b5c2">rte_memseg_walk_t</a>) (const struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *msl, const struct rte_memseg *ms, void *arg)</td></tr>
<tr class="separator:adbfe16e8d0c9d9ca7a994dff9ba2b5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ee9347cdc8659dc0e71911f15ce216"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a45ee9347cdc8659dc0e71911f15ce216">rte_memseg_contig_walk_t</a>) (const struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *msl, const struct rte_memseg *ms, size_t len, void *arg)</td></tr>
<tr class="separator:a45ee9347cdc8659dc0e71911f15ce216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a038d3c93aa084b849172f886a96b7d"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a7a038d3c93aa084b849172f886a96b7d">rte_memseg_list_walk_t</a>) (const struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *msl, void *arg)</td></tr>
<tr class="separator:a7a038d3c93aa084b849172f886a96b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46cb66d338cb3b01878870ee3f7ebfa"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ae46cb66d338cb3b01878870ee3f7ebfa">rte_mem_event_callback_t</a>) (enum <a class="el" href="rte__memory_8h.html#a69d754559085872a0f1dc9ffb74bd6ea">rte_mem_event</a> event_type, const void *addr, size_t len, void *arg)</td></tr>
<tr class="separator:ae46cb66d338cb3b01878870ee3f7ebfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a1194d4f5c9aa8069c024750e20787"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ae7a1194d4f5c9aa8069c024750e20787">rte_mem_alloc_validator_t</a>) (int socket_id, size_t cur_limit, size_t new_len)</td></tr>
<tr class="separator:ae7a1194d4f5c9aa8069c024750e20787"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a69d754559085872a0f1dc9ffb74bd6ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a69d754559085872a0f1dc9ffb74bd6ea">rte_mem_event</a> { <a class="el" href="rte__memory_8h.html#a69d754559085872a0f1dc9ffb74bd6eaa98e44bcc5b1e49d236ee9c9976fc2b89">RTE_MEM_EVENT_ALLOC</a> = 0, 
<a class="el" href="rte__memory_8h.html#a69d754559085872a0f1dc9ffb74bd6eaaebad2a688c7fa880385010b2410d148a">RTE_MEM_EVENT_FREE</a>
 }</td></tr>
<tr class="separator:a69d754559085872a0f1dc9ffb74bd6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab795c4d01556e640d7916bec332a8c0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ab795c4d01556e640d7916bec332a8c0c">rte_mem_lock_page</a> (const void *virt)</td></tr>
<tr class="separator:ab795c4d01556e640d7916bec332a8c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c786260d675cb7af1299dd4b7a28ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__common_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a15c786260d675cb7af1299dd4b7a28ee">rte_mem_virt2phy</a> (const void *virt)</td></tr>
<tr class="separator:a15c786260d675cb7af1299dd4b7a28ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdacd46f51e88d88157938bb92d2d94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#acdacd46f51e88d88157938bb92d2d94a">rte_mem_virt2iova</a> (const void *virt)</td></tr>
<tr class="separator:acdacd46f51e88d88157938bb92d2d94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9326254dd471dbf2b3f39500a7859e"><td class="memItemLeft" align="right" valign="top">__rte_experimental void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#acd9326254dd471dbf2b3f39500a7859e">rte_mem_iova2virt</a> (<a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> iova)</td></tr>
<tr class="separator:acd9326254dd471dbf2b3f39500a7859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3132be178038cdfa61c25b5163514c3f"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct rte_memseg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a3132be178038cdfa61c25b5163514c3f">rte_mem_virt2memseg</a> (const void *virt, const struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *msl)</td></tr>
<tr class="separator:a3132be178038cdfa61c25b5163514c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b1647d7e04ab37d89415d58202ffd6"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a37b1647d7e04ab37d89415d58202ffd6">rte_mem_virt2memseg_list</a> (const void *virt)</td></tr>
<tr class="separator:a37b1647d7e04ab37d89415d58202ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bfdb73e2da9eae195e229a7938e0b6"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a99bfdb73e2da9eae195e229a7938e0b6">rte_memseg_walk</a> (<a class="el" href="rte__memory_8h.html#adbfe16e8d0c9d9ca7a994dff9ba2b5c2">rte_memseg_walk_t</a> func, void *arg)</td></tr>
<tr class="separator:a99bfdb73e2da9eae195e229a7938e0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f88ce4de356649394bab3787b3a4c9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a93f88ce4de356649394bab3787b3a4c9">rte_memseg_contig_walk</a> (<a class="el" href="rte__memory_8h.html#a45ee9347cdc8659dc0e71911f15ce216">rte_memseg_contig_walk_t</a> func, void *arg)</td></tr>
<tr class="separator:a93f88ce4de356649394bab3787b3a4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4f5d7791961b0da0441b255211989a"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a8a4f5d7791961b0da0441b255211989a">rte_memseg_list_walk</a> (<a class="el" href="rte__memory_8h.html#a7a038d3c93aa084b849172f886a96b7d">rte_memseg_list_walk_t</a> func, void *arg)</td></tr>
<tr class="separator:a8a4f5d7791961b0da0441b255211989a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49f0c7f02f4f91356e75ab00adcbc02"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ab49f0c7f02f4f91356e75ab00adcbc02">rte_memseg_walk_thread_unsafe</a> (<a class="el" href="rte__memory_8h.html#adbfe16e8d0c9d9ca7a994dff9ba2b5c2">rte_memseg_walk_t</a> func, void *arg)</td></tr>
<tr class="separator:ab49f0c7f02f4f91356e75ab00adcbc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99552e79f28319ff5b116c1ee30f9c5"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#aa99552e79f28319ff5b116c1ee30f9c5">rte_memseg_contig_walk_thread_unsafe</a> (<a class="el" href="rte__memory_8h.html#a45ee9347cdc8659dc0e71911f15ce216">rte_memseg_contig_walk_t</a> func, void *arg)</td></tr>
<tr class="separator:aa99552e79f28319ff5b116c1ee30f9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade68a6562635ca2c66e4c262fb065c85"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ade68a6562635ca2c66e4c262fb065c85">rte_memseg_list_walk_thread_unsafe</a> (<a class="el" href="rte__memory_8h.html#a7a038d3c93aa084b849172f886a96b7d">rte_memseg_list_walk_t</a> func, void *arg)</td></tr>
<tr class="separator:ade68a6562635ca2c66e4c262fb065c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdb8f63a6781f19d504103a03890130"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a7cdb8f63a6781f19d504103a03890130">rte_memseg_get_fd</a> (const struct rte_memseg *ms)</td></tr>
<tr class="separator:a7cdb8f63a6781f19d504103a03890130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a1005a620bc517b6ce146694652846"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a32a1005a620bc517b6ce146694652846">rte_memseg_get_fd_thread_unsafe</a> (const struct rte_memseg *ms)</td></tr>
<tr class="separator:a32a1005a620bc517b6ce146694652846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0e5a347eabe2c50ffcc5e29bcac63c"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a1a0e5a347eabe2c50ffcc5e29bcac63c">rte_memseg_get_fd_offset</a> (const struct rte_memseg *ms, size_t *offset)</td></tr>
<tr class="separator:a1a0e5a347eabe2c50ffcc5e29bcac63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90171a8389646e71d70391cc466c5923"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a90171a8389646e71d70391cc466c5923">rte_memseg_get_fd_offset_thread_unsafe</a> (const struct rte_memseg *ms, size_t *offset)</td></tr>
<tr class="separator:a90171a8389646e71d70391cc466c5923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8198657eaa2ab71f82ea8f2abd8b94"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#aab8198657eaa2ab71f82ea8f2abd8b94">rte_extmem_register</a> (void *va_addr, size_t len, <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> iova_addrs[], unsigned int n_pages, size_t page_sz)</td></tr>
<tr class="separator:aab8198657eaa2ab71f82ea8f2abd8b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653510fb0c58bf63f54708677e3a2eba"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a653510fb0c58bf63f54708677e3a2eba">rte_extmem_unregister</a> (void *va_addr, size_t len)</td></tr>
<tr class="separator:a653510fb0c58bf63f54708677e3a2eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a58df31600ff9eb47c13649d17ab401"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a1a58df31600ff9eb47c13649d17ab401">rte_extmem_attach</a> (void *va_addr, size_t len)</td></tr>
<tr class="separator:a1a58df31600ff9eb47c13649d17ab401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55ad07ff6eb1f49f8a99ba60a7b8e02"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ac55ad07ff6eb1f49f8a99ba60a7b8e02">rte_extmem_detach</a> (void *va_addr, size_t len)</td></tr>
<tr class="separator:ac55ad07ff6eb1f49f8a99ba60a7b8e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2cac2edfd31adc306923902bd692cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a9d2cac2edfd31adc306923902bd692cf">rte_dump_physmem_layout</a> (FILE *f)</td></tr>
<tr class="separator:a9d2cac2edfd31adc306923902bd692cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada583c8586309d8b7c82b4d5ef45585b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ada583c8586309d8b7c82b4d5ef45585b">rte_eal_get_physmem_size</a> (void)</td></tr>
<tr class="separator:ada583c8586309d8b7c82b4d5ef45585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108b63a95946b4a1a857bb6d6410de49"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a108b63a95946b4a1a857bb6d6410de49">rte_memory_get_nchannel</a> (void)</td></tr>
<tr class="separator:a108b63a95946b4a1a857bb6d6410de49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59fa0306f5fe231dd4617b3f06a40c4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#af59fa0306f5fe231dd4617b3f06a40c4">rte_memory_get_nrank</a> (void)</td></tr>
<tr class="separator:af59fa0306f5fe231dd4617b3f06a40c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08c46c4e7c6d1e72b98a20f07770dc1"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ad08c46c4e7c6d1e72b98a20f07770dc1">rte_mem_check_dma_mask</a> (uint8_t maskbits)</td></tr>
<tr class="separator:ad08c46c4e7c6d1e72b98a20f07770dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad312e19e46eca1ac04e40cfafd5a2bed"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ad312e19e46eca1ac04e40cfafd5a2bed">rte_mem_check_dma_mask_thread_unsafe</a> (uint8_t maskbits)</td></tr>
<tr class="separator:ad312e19e46eca1ac04e40cfafd5a2bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af118808650030f34ead823809ec6fa1f"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#af118808650030f34ead823809ec6fa1f">rte_mem_set_dma_mask</a> (uint8_t maskbits)</td></tr>
<tr class="separator:af118808650030f34ead823809ec6fa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d08e94b43f0585121cf846194aa364"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ad1d08e94b43f0585121cf846194aa364">rte_eal_using_phys_addrs</a> (void)</td></tr>
<tr class="separator:ad1d08e94b43f0585121cf846194aa364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f2d3fd7b8cb5900a961d6188eafafe"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a07f2d3fd7b8cb5900a961d6188eafafe">rte_mem_event_callback_register</a> (const char *name, <a class="el" href="rte__memory_8h.html#ae46cb66d338cb3b01878870ee3f7ebfa">rte_mem_event_callback_t</a> clb, void *arg)</td></tr>
<tr class="separator:a07f2d3fd7b8cb5900a961d6188eafafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ef232c2c44bb4fc541f48eba85c060"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#ad4ef232c2c44bb4fc541f48eba85c060">rte_mem_event_callback_unregister</a> (const char *name, void *arg)</td></tr>
<tr class="separator:ad4ef232c2c44bb4fc541f48eba85c060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ed56ff206d7d7bb0cc02b157774a11"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#af5ed56ff206d7d7bb0cc02b157774a11">rte_mem_alloc_validator_register</a> (const char *name, <a class="el" href="rte__memory_8h.html#ae7a1194d4f5c9aa8069c024750e20787">rte_mem_alloc_validator_t</a> clb, int socket_id, size_t limit)</td></tr>
<tr class="memdesc:af5ed56ff206d7d7bb0cc02b157774a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register validator callback for memory allocations.  <a href="rte__memory_8h.html#af5ed56ff206d7d7bb0cc02b157774a11">More...</a><br /></td></tr>
<tr class="separator:af5ed56ff206d7d7bb0cc02b157774a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658172bcb311c74b346326a73f120edd"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__memory_8h.html#a658172bcb311c74b346326a73f120edd">rte_mem_alloc_validator_unregister</a> (const char *name, int socket_id)</td></tr>
<tr class="memdesc:a658172bcb311c74b346326a73f120edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister validator callback for memory allocations.  <a href="rte__memory_8h.html#a658172bcb311c74b346326a73f120edd">More...</a><br /></td></tr>
<tr class="separator:a658172bcb311c74b346326a73f120edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory-related RTE API. </p>

<p class="definition">Definition in file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a0307f4470d3f391102b0f489fc7d91b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0307f4470d3f391102b0f489fc7d91b5">&#9670;&nbsp;</a></span>SOCKET_ID_ANY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_ID_ANY&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Any NUMA socket. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ip_fragmentation_2main_8c-example.html#a76">examples/ip_fragmentation/main.c</a>, <a class="el" href="examples_2ip_pipeline_2link_8c-example.html#a13">examples/ip_pipeline/link.c</a>, <a class="el" href="examples_2ip_reassembly_2main_8c-example.html#a70">examples/ip_reassembly/main.c</a>, <a class="el" href="examples_2l3fwd-graph_2main_8c-example.html#a36">examples/l3fwd-graph/main.c</a>, and <a class="el" href="examples_2pipeline_2obj_8c-example.html#a19">examples/pipeline/obj.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00038">38</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<a id="a211220821cd4194e2730cd90d7ee1fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211220821cd4194e2730cd90d7ee1fd3">&#9670;&nbsp;</a></span>RTE_MEMSEG_FLAG_DO_NOT_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMSEG_FLAG_DO_NOT_FREE&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Physical memory segment descriptor. Prevent this segment from being freed back to the OS. </p>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00044">44</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<a id="a2594ce23f2876b03ee571c4ee502e3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2594ce23f2876b03ee571c4ee502e3d7">&#9670;&nbsp;</a></span>RTE_MEM_EVENT_CALLBACK_NAME_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEM_EVENT_CALLBACK_NAME_LEN&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum length of callback name </p>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00648">648</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<a id="afd07eb9cc6b4ee89b6a5d9bc71b3877f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd07eb9cc6b4ee89b6a5d9bc71b3877f">&#9670;&nbsp;</a></span>RTE_MEM_ALLOC_VALIDATOR_NAME_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEM_ALLOC_VALIDATOR_NAME_LEN&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>maximum length of alloc validator name </p>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00706">706</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adbfe16e8d0c9d9ca7a994dff9ba2b5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfe16e8d0c9d9ca7a994dff9ba2b5c2">&#9670;&nbsp;</a></span>rte_memseg_walk_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_memseg_walk_t) (const struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *msl, const struct rte_memseg *ms, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memseg walk function prototype.</p>
<p>Returning 0 will continue walk Returning 1 will stop the walk Returning -1 will stop the walk and report error </p>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00168">168</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<a id="a45ee9347cdc8659dc0e71911f15ce216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ee9347cdc8659dc0e71911f15ce216">&#9670;&nbsp;</a></span>rte_memseg_contig_walk_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_memseg_contig_walk_t) (const struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *msl, const struct rte_memseg *ms, size_t len, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memseg contig walk function prototype. This will trigger a callback on every VA-contiguous area starting at memseg <code>ms</code>, so total valid VA space at each callback call will be [<code>ms-&gt;addr</code>, <code>ms-&gt;addr + len</code>).</p>
<p>Returning 0 will continue walk Returning 1 will stop the walk Returning -1 will stop the walk and report error </p>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00180">180</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<a id="a7a038d3c93aa084b849172f886a96b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a038d3c93aa084b849172f886a96b7d">&#9670;&nbsp;</a></span>rte_memseg_list_walk_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_memseg_list_walk_t) (const struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *msl, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memseg list walk function prototype. This will trigger a callback on every allocated memseg list.</p>
<p>Returning 0 will continue walk Returning 1 will stop the walk Returning -1 will stop the walk and report error </p>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00191">191</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<a id="ae46cb66d338cb3b01878870ee3f7ebfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46cb66d338cb3b01878870ee3f7ebfa">&#9670;&nbsp;</a></span>rte_mem_event_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_mem_event_callback_t) (enum <a class="el" href="rte__memory_8h.html#a69d754559085872a0f1dc9ffb74bd6ea">rte_mem_event</a> event_type, const void *addr, size_t len, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function typedef used to register callbacks for memory events. </p>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00653">653</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<a id="ae7a1194d4f5c9aa8069c024750e20787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a1194d4f5c9aa8069c024750e20787">&#9670;&nbsp;</a></span>rte_mem_alloc_validator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mem_alloc_validator_t) (int socket_id, size_t cur_limit, size_t new_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function typedef used to register memory allocation validation callbacks.</p>
<p>Returning 0 will allow allocation attempt to continue. Returning -1 will prevent allocation from succeeding. </p>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00713">713</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a69d754559085872a0f1dc9ffb74bd6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d754559085872a0f1dc9ffb74bd6ea">&#9670;&nbsp;</a></span>rte_mem_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__memory_8h.html#a69d754559085872a0f1dc9ffb74bd6ea">rte_mem_event</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum indicating which kind of memory event has happened. Used by callbacks to distinguish between memory allocations and deallocations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69d754559085872a0f1dc9ffb74bd6eaa98e44bcc5b1e49d236ee9c9976fc2b89"></a>RTE_MEM_EVENT_ALLOC&#160;</td><td class="fielddoc"><p>Allocation event. </p>
</td></tr>
<tr><td class="fieldname"><a id="a69d754559085872a0f1dc9ffb74bd6eaaebad2a688c7fa880385010b2410d148a"></a>RTE_MEM_EVENT_FREE&#160;</td><td class="fielddoc"><p>Deallocation event. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__memory_8h_source.html#l00643">643</a> of file <a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab795c4d01556e640d7916bec332a8c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab795c4d01556e640d7916bec332a8c0c">&#9670;&nbsp;</a></span>rte_mem_lock_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mem_lock_page </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>virt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock page in physical memory and prevent from swapping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>The virtual address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative on error. </dd></dl>

</div>
</div>
<a id="a15c786260d675cb7af1299dd4b7a28ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c786260d675cb7af1299dd4b7a28ee">&#9670;&nbsp;</a></span>rte_mem_virt2phy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__common_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a> rte_mem_virt2phy </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>virt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get physical address of any mapped virtual address in the current process. It is found by browsing the /proc/self/pagemap special file. The page must be locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>The virtual address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The physical address or RTE_BAD_IOVA on error. </dd></dl>

</div>
</div>
<a id="acdacd46f51e88d88157938bb92d2d94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdacd46f51e88d88157938bb92d2d94a">&#9670;&nbsp;</a></span>rte_mem_virt2iova()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> rte_mem_virt2iova </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>virt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get IO virtual address of any mapped virtual address in the current process.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not check internal page table. Instead, in IOVA as PA mode, it will fall back to getting real physical address (which may not match the expected IOVA, such as what was specified for external memory).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>The virtual address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IO address or RTE_BAD_IOVA on error. </dd></dl>

</div>
</div>
<a id="acd9326254dd471dbf2b3f39500a7859e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9326254dd471dbf2b3f39500a7859e">&#9670;&nbsp;</a></span>rte_mem_iova2virt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void* rte_mem_iova2virt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td>
          <td class="paramname"><em>iova</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get virtual memory address corresponding to iova address.</p>
<dl class="section note"><dt>Note</dt><dd>This function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related callback functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iova</td><td>The iova address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Virtual address corresponding to iova address (or NULL if address does not exist within DPDK memory map). </dd></dl>

</div>
</div>
<a id="a3132be178038cdfa61c25b5163514c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3132be178038cdfa61c25b5163514c3f">&#9670;&nbsp;</a></span>rte_mem_virt2memseg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct rte_memseg* rte_mem_virt2memseg </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>virt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a> *&#160;</td>
          <td class="paramname"><em>msl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get memseg to which a particular virtual address belongs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>The virtual address. </td></tr>
    <tr><td class="paramname">msl</td><td>The memseg list in which to look up based on <code>virt</code> address (can be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memseg pointer on success, or NULL on error. </dd></dl>

</div>
</div>
<a id="a37b1647d7e04ab37d89415d58202ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b1647d7e04ab37d89415d58202ffd6">&#9670;&nbsp;</a></span>rte_mem_virt2memseg_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct <a class="el" href="structrte__memseg__list.html">rte_memseg_list</a>* rte_mem_virt2memseg_list </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>virt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get memseg list corresponding to virtual memory address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">virt</td><td>The virtual address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memseg list to which this virtual address belongs to. </dd></dl>

</div>
</div>
<a id="a99bfdb73e2da9eae195e229a7938e0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bfdb73e2da9eae195e229a7938e0b6">&#9670;&nbsp;</a></span>rte_memseg_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__memory_8h.html#adbfe16e8d0c9d9ca7a994dff9ba2b5c2">rte_memseg_walk_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk list of all memsegs.</p>
<dl class="section note"><dt>Note</dt><dd>This function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related callback functions.</dd>
<dd>
This function will also walk through externally allocated segments. It is up to the user to decide whether to skip through these segments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if walked over the entire list 1 if stopped by the user -1 if user function reported error </dd></dl>

</div>
</div>
<a id="a93f88ce4de356649394bab3787b3a4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f88ce4de356649394bab3787b3a4c9">&#9670;&nbsp;</a></span>rte_memseg_contig_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_contig_walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__memory_8h.html#a45ee9347cdc8659dc0e71911f15ce216">rte_memseg_contig_walk_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk each VA-contiguous area.</p>
<dl class="section note"><dt>Note</dt><dd>This function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related callback functions.</dd>
<dd>
This function will also walk through externally allocated segments. It is up to the user to decide whether to skip through these segments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if walked over the entire list 1 if stopped by the user -1 if user function reported error </dd></dl>

</div>
</div>
<a id="a8a4f5d7791961b0da0441b255211989a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4f5d7791961b0da0441b255211989a">&#9670;&nbsp;</a></span>rte_memseg_list_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_list_walk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__memory_8h.html#a7a038d3c93aa084b849172f886a96b7d">rte_memseg_list_walk_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk each allocated memseg list.</p>
<dl class="section note"><dt>Note</dt><dd>This function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related callback functions.</dd>
<dd>
This function will also walk through externally allocated segments. It is up to the user to decide whether to skip through these segments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if walked over the entire list 1 if stopped by the user -1 if user function reported error </dd></dl>

</div>
</div>
<a id="ab49f0c7f02f4f91356e75ab00adcbc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49f0c7f02f4f91356e75ab00adcbc02">&#9670;&nbsp;</a></span>rte_memseg_walk_thread_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_walk_thread_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__memory_8h.html#adbfe16e8d0c9d9ca7a994dff9ba2b5c2">rte_memseg_walk_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk list of all memsegs without performing any locking.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not perform any locking, and is only safe to call from within memory-related callback functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if walked over the entire list 1 if stopped by the user -1 if user function reported error </dd></dl>

</div>
</div>
<a id="aa99552e79f28319ff5b116c1ee30f9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99552e79f28319ff5b116c1ee30f9c5">&#9670;&nbsp;</a></span>rte_memseg_contig_walk_thread_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_contig_walk_thread_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__memory_8h.html#a45ee9347cdc8659dc0e71911f15ce216">rte_memseg_contig_walk_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk each VA-contiguous area without performing any locking.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not perform any locking, and is only safe to call from within memory-related callback functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if walked over the entire list 1 if stopped by the user -1 if user function reported error </dd></dl>

</div>
</div>
<a id="ade68a6562635ca2c66e4c262fb065c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade68a6562635ca2c66e4c262fb065c85">&#9670;&nbsp;</a></span>rte_memseg_list_walk_thread_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_list_walk_thread_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__memory_8h.html#a7a038d3c93aa084b849172f886a96b7d">rte_memseg_list_walk_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk each allocated memseg list without performing any locking.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not perform any locking, and is only safe to call from within memory-related callback functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if walked over the entire list 1 if stopped by the user -1 if user function reported error </dd></dl>

</div>
</div>
<a id="a7cdb8f63a6781f19d504103a03890130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdb8f63a6781f19d504103a03890130">&#9670;&nbsp;</a></span>rte_memseg_get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_get_fd </td>
          <td>(</td>
          <td class="paramtype">const struct rte_memseg *&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return file descriptor associated with a particular memseg (if available).</p>
<dl class="section note"><dt>Note</dt><dd>This function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related callback functions.</dd>
<dd>
This returns an internal file descriptor. Performing any operations on this file descriptor is inherently dangerous, so it should be treated as read-only for all intents and purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>A pointer to memseg for which to get file descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid file descriptor in case of success. -1 in case of error, with <code>rte_errno</code> set to the following values:<ul>
<li>EINVAL - <code>ms</code> pointer was NULL or did not point to a valid memseg</li>
<li>ENODEV - <code>ms</code> fd is not available</li>
<li>ENOENT - <code>ms</code> is an unused segment</li>
<li>ENOTSUP - segment fd's are not supported </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a32a1005a620bc517b6ce146694652846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a1005a620bc517b6ce146694652846">&#9670;&nbsp;</a></span>rte_memseg_get_fd_thread_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_get_fd_thread_unsafe </td>
          <td>(</td>
          <td class="paramtype">const struct rte_memseg *&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return file descriptor associated with a particular memseg (if available).</p>
<dl class="section note"><dt>Note</dt><dd>This function does not perform any locking, and is only safe to call from within memory-related callback functions.</dd>
<dd>
This returns an internal file descriptor. Performing any operations on this file descriptor is inherently dangerous, so it should be treated as read-only for all intents and purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>A pointer to memseg for which to get file descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid file descriptor in case of success. -1 in case of error, with <code>rte_errno</code> set to the following values:<ul>
<li>EINVAL - <code>ms</code> pointer was NULL or did not point to a valid memseg</li>
<li>ENODEV - <code>ms</code> fd is not available</li>
<li>ENOENT - <code>ms</code> is an unused segment</li>
<li>ENOTSUP - segment fd's are not supported </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1a0e5a347eabe2c50ffcc5e29bcac63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0e5a347eabe2c50ffcc5e29bcac63c">&#9670;&nbsp;</a></span>rte_memseg_get_fd_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_get_fd_offset </td>
          <td>(</td>
          <td class="paramtype">const struct rte_memseg *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get offset into segment file descriptor associated with a particular memseg (if available).</p>
<dl class="section note"><dt>Note</dt><dd>This function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related callback functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>A pointer to memseg for which to get file descriptor. </td></tr>
    <tr><td class="paramname">offset</td><td>A pointer to offset value where the result will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid file descriptor in case of success. -1 in case of error, with <code>rte_errno</code> set to the following values:<ul>
<li>EINVAL - <code>ms</code> pointer was NULL or did not point to a valid memseg</li>
<li>EINVAL - <code>offset</code> pointer was NULL</li>
<li>ENODEV - <code>ms</code> fd is not available</li>
<li>ENOENT - <code>ms</code> is an unused segment</li>
<li>ENOTSUP - segment fd's are not supported </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a90171a8389646e71d70391cc466c5923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90171a8389646e71d70391cc466c5923">&#9670;&nbsp;</a></span>rte_memseg_get_fd_offset_thread_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_memseg_get_fd_offset_thread_unsafe </td>
          <td>(</td>
          <td class="paramtype">const struct rte_memseg *&#160;</td>
          <td class="paramname"><em>ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get offset into segment file descriptor associated with a particular memseg (if available).</p>
<dl class="section note"><dt>Note</dt><dd>This function does not perform any locking, and is only safe to call from within memory-related callback functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>A pointer to memseg for which to get file descriptor. </td></tr>
    <tr><td class="paramname">offset</td><td>A pointer to offset value where the result will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid file descriptor in case of success. -1 in case of error, with <code>rte_errno</code> set to the following values:<ul>
<li>EINVAL - <code>ms</code> pointer was NULL or did not point to a valid memseg</li>
<li>EINVAL - <code>offset</code> pointer was NULL</li>
<li>ENODEV - <code>ms</code> fd is not available</li>
<li>ENOENT - <code>ms</code> is an unused segment</li>
<li>ENOTSUP - segment fd's are not supported </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aab8198657eaa2ab71f82ea8f2abd8b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8198657eaa2ab71f82ea8f2abd8b94">&#9670;&nbsp;</a></span>rte_extmem_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_extmem_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>va_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td>
          <td class="paramname"><em>iova_addrs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>page_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Register external memory chunk with DPDK.</p>
<dl class="section note"><dt>Note</dt><dd>Using this API is mutually exclusive with <code>rte_malloc</code> family of API's.</dd>
<dd>
This API will not perform any DMA mapping. It is expected that user will do that themselves.</dd>
<dd>
Before accessing this memory in other processes, it needs to be attached in each of those processes by calling <code>rte_extmem_attach</code> in each other process.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">va_addr</td><td>Start of virtual area to register. Must be aligned by <code>page_sz</code>. </td></tr>
    <tr><td class="paramname">len</td><td>Length of virtual area to register. Must be aligned by <code>page_sz</code>. </td></tr>
    <tr><td class="paramname">iova_addrs</td><td>Array of page IOVA addresses corresponding to each page in this memory area. Can be NULL, in which case page IOVA addresses will be set to RTE_BAD_IOVA. </td></tr>
    <tr><td class="paramname">n_pages</td><td>Number of elements in the iova_addrs array. Ignored if <code>iova_addrs</code> is NULL. </td></tr>
    <tr><td class="paramname">page_sz</td><td>Page size of the underlying memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-1 in case of error, with rte_errno set to one of the following: EINVAL - one of the parameters was invalid EEXIST - memory chunk is already registered ENOSPC - no more space in internal config to store a new memory chunk </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a653510fb0c58bf63f54708677e3a2eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653510fb0c58bf63f54708677e3a2eba">&#9670;&nbsp;</a></span>rte_extmem_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_extmem_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>va_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Unregister external memory chunk with DPDK.</p>
<dl class="section note"><dt>Note</dt><dd>Using this API is mutually exclusive with <code>rte_malloc</code> family of API's.</dd>
<dd>
This API will not perform any DMA unmapping. It is expected that user will do that themselves.</dd>
<dd>
Before calling this function, all other processes must call <code>rte_extmem_detach</code> to detach from the memory area.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">va_addr</td><td>Start of virtual area to unregister </td></tr>
    <tr><td class="paramname">len</td><td>Length of virtual area to unregister</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-1 in case of error, with rte_errno set to one of the following: EINVAL - one of the parameters was invalid ENOENT - memory chunk was not found </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1a58df31600ff9eb47c13649d17ab401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a58df31600ff9eb47c13649d17ab401">&#9670;&nbsp;</a></span>rte_extmem_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_extmem_attach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>va_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Attach to external memory chunk registered in another process.</p>
<dl class="section note"><dt>Note</dt><dd>Using this API is mutually exclusive with <code>rte_malloc</code> family of API's.</dd>
<dd>
This API will not perform any DMA mapping. It is expected that user will do that themselves.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">va_addr</td><td>Start of virtual area to register </td></tr>
    <tr><td class="paramname">len</td><td>Length of virtual area to register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-1 in case of error, with rte_errno set to one of the following: EINVAL - one of the parameters was invalid ENOENT - memory chunk was not found </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac55ad07ff6eb1f49f8a99ba60a7b8e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55ad07ff6eb1f49f8a99ba60a7b8e02">&#9670;&nbsp;</a></span>rte_extmem_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_extmem_detach </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>va_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Detach from external memory chunk registered in another process.</p>
<dl class="section note"><dt>Note</dt><dd>Using this API is mutually exclusive with <code>rte_malloc</code> family of API's.</dd>
<dd>
This API will not perform any DMA unmapping. It is expected that user will do that themselves.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">va_addr</td><td>Start of virtual area to unregister </td></tr>
    <tr><td class="paramname">len</td><td>Length of virtual area to unregister</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-1 in case of error, with rte_errno set to one of the following: EINVAL - one of the parameters was invalid ENOENT - memory chunk was not found </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9d2cac2edfd31adc306923902bd692cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2cac2edfd31adc306923902bd692cf">&#9670;&nbsp;</a></span>rte_dump_physmem_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_dump_physmem_layout </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the physical memory layout to a file.</p>
<dl class="section note"><dt>Note</dt><dd>This function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related callback functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada583c8586309d8b7c82b4d5ef45585b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada583c8586309d8b7c82b4d5ef45585b">&#9670;&nbsp;</a></span>rte_eal_get_physmem_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rte_eal_get_physmem_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total amount of available physical memory.</p>
<dl class="section note"><dt>Note</dt><dd>This function read-locks the memory hotplug subsystem, and thus cannot be used within memory-related callback functions.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The total amount of available physical memory in bytes. </dd></dl>

</div>
</div>
<a id="a108b63a95946b4a1a857bb6d6410de49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108b63a95946b4a1a857bb6d6410de49">&#9670;&nbsp;</a></span>rte_memory_get_nchannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rte_memory_get_nchannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of memory channels.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of memory channels on the system. The value is 0 if unknown or not the same on all devices. </dd></dl>

</div>
</div>
<a id="af59fa0306f5fe231dd4617b3f06a40c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59fa0306f5fe231dd4617b3f06a40c4">&#9670;&nbsp;</a></span>rte_memory_get_nrank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rte_memory_get_nrank </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of memory ranks.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of memory ranks on the system. The value is 0 if unknown or not the same on all devices. </dd></dl>

</div>
</div>
<a id="ad08c46c4e7c6d1e72b98a20f07770dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08c46c4e7c6d1e72b98a20f07770dc1">&#9670;&nbsp;</a></span>rte_mem_check_dma_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mem_check_dma_mask </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maskbits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Check if all currently allocated memory segments are compliant with supplied DMA address width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maskbits</td><td>Address width to check against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad312e19e46eca1ac04e40cfafd5a2bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad312e19e46eca1ac04e40cfafd5a2bed">&#9670;&nbsp;</a></span>rte_mem_check_dma_mask_thread_unsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mem_check_dma_mask_thread_unsafe </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maskbits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Check if all currently allocated memory segments are compliant with supplied DMA address width. This function will use rte_memseg_walk_thread_unsafe instead of rte_memseg_walk implying memory_hotplug_lock will not be acquired avoiding deadlock during memory initialization.</p>
<p>This function is just for EAL core memory internal use. Drivers should use the previous rte_mem_check_dma_mask.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maskbits</td><td>Address width to check against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af118808650030f34ead823809ec6fa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af118808650030f34ead823809ec6fa1f">&#9670;&nbsp;</a></span>rte_mem_set_dma_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_mem_set_dma_mask </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maskbits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Set dma mask to use once memory initialization is done. Previous functions rte_mem_check_dma_mask and rte_mem_check_dma_mask_thread_unsafe can not be used safely until memory has been initialized. </p>

</div>
</div>
<a id="ad1d08e94b43f0585121cf846194aa364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d08e94b43f0585121cf846194aa364">&#9670;&nbsp;</a></span>rte_eal_using_phys_addrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eal_using_phys_addrs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Drivers based on uio will not load unless physical addresses are obtainable. It is only possible to get physical addresses when running as a privileged user.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the system is able to obtain physical addresses. 0 if using DMA addresses through an IOMMU. </dd></dl>

</div>
</div>
<a id="a07f2d3fd7b8cb5900a961d6188eafafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f2d3fd7b8cb5900a961d6188eafafe">&#9670;&nbsp;</a></span>rte_mem_event_callback_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mem_event_callback_register </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__memory_8h.html#ae46cb66d338cb3b01878870ee3f7ebfa">rte_mem_event_callback_t</a>&#160;</td>
          <td class="paramname"><em>clb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function used to register callbacks for memory events.</p>
<dl class="section note"><dt>Note</dt><dd>callbacks will happen while memory hotplug subsystem is write-locked, therefore some functions (e.g. <code><a class="el" href="rte__memory_8h.html#a99bfdb73e2da9eae195e229a7938e0b6">rte_memseg_walk()</a></code>) will cause a deadlock when called from within such callbacks.</dd>
<dd>
mem event callbacks not being supported is an expected error condition, so user code needs to handle this situation. In these cases, return value will be -1, and rte_errno will be set to ENOTSUP.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name associated with specified callback to be added to the list.</td></tr>
    <tr><td class="paramname">clb</td><td>Callback function pointer.</td></tr>
    <tr><td class="paramname">arg</td><td>Argument to pass to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful callback register -1 on unsuccessful callback register, with rte_errno value indicating reason for failure. </dd></dl>

</div>
</div>
<a id="ad4ef232c2c44bb4fc541f48eba85c060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ef232c2c44bb4fc541f48eba85c060">&#9670;&nbsp;</a></span>rte_mem_event_callback_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mem_event_callback_unregister </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function used to unregister callbacks for memory events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name associated with specified callback to be removed from the list.</td></tr>
    <tr><td class="paramname">arg</td><td>Argument to look for among callbacks with specified callback name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful callback unregister -1 on unsuccessful callback unregister, with rte_errno value indicating reason for failure. </dd></dl>

</div>
</div>
<a id="af5ed56ff206d7d7bb0cc02b157774a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ed56ff206d7d7bb0cc02b157774a11">&#9670;&nbsp;</a></span>rte_mem_alloc_validator_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mem_alloc_validator_register </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__memory_8h.html#ae7a1194d4f5c9aa8069c024750e20787">rte_mem_alloc_validator_t</a>&#160;</td>
          <td class="paramname"><em>clb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register validator callback for memory allocations. </p>
<p>Callbacks registered by this function will be called right before memory allocator is about to trigger allocation of more pages from the system if said allocation will bring total memory usage above specified limit on specified socket. User will be able to cancel pending allocation if callback returns -1.</p>
<dl class="section note"><dt>Note</dt><dd>callbacks will happen while memory hotplug subsystem is write-locked, therefore some functions (e.g. <code><a class="el" href="rte__memory_8h.html#a99bfdb73e2da9eae195e229a7938e0b6">rte_memseg_walk()</a></code>) will cause a deadlock when called from within such callbacks.</dd>
<dd>
validator callbacks not being supported is an expected error condition, so user code needs to handle this situation. In these cases, return value will be -1, and rte_errno will be set to ENOTSUP.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name associated with specified callback to be added to the list.</td></tr>
    <tr><td class="paramname">clb</td><td>Callback function pointer.</td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID on which to watch for allocations.</td></tr>
    <tr><td class="paramname">limit</td><td>Limit above which to trigger callbacks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful callback register -1 on unsuccessful callback register, with rte_errno value indicating reason for failure. </dd></dl>

</div>
</div>
<a id="a658172bcb311c74b346326a73f120edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658172bcb311c74b346326a73f120edd">&#9670;&nbsp;</a></span>rte_mem_alloc_validator_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mem_alloc_validator_unregister </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister validator callback for memory allocations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name associated with specified callback to be removed from the list.</td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID on which to watch for allocations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful callback unregister -1 on unsuccessful callback unregister, with rte_errno value indicating reason for failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
