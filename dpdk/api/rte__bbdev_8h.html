<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_bbdev/rte_bbdev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1e371fc4c61fbb916177b5ec80f09b33.html">librte_bbdev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_bbdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__bus_8h_source.html">rte_bus.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__cpuflags_8h_source.html">rte_cpuflags.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__bbdev__op_8h_source.html">rte_bbdev_op.h</a>&quot;</code><br />
</div>
<p><a href="rte__bbdev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__queue__conf.html">rte_bbdev_queue_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__stats.html">rte_bbdev_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__driver__info.html">rte_bbdev_driver_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__info.html">rte_bbdev_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__bbdev__queue__info.html">rte_bbdev_queue_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afb7096069a91f3e740616a5967533973"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#afb7096069a91f3e740616a5967533973">RTE_BBDEV_MAX_DEVS</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:afb7096069a91f3e740616a5967533973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af802dc9dbbdfce9e4d0aa55894dcbf91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#af802dc9dbbdfce9e4d0aa55894dcbf91">RTE_BBDEV_FOREACH</a>(i)</td></tr>
<tr class="separator:af802dc9dbbdfce9e4d0aa55894dcbf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589f71722680b1d346be2d38a0385165"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a589f71722680b1d346be2d38a0385165">RTE_BBDEV_END_OF_CAPABILITIES_LIST</a>()&#160;&#160;&#160;	{ <a class="el" href="rte__bbdev__op_8h.html#a35a82e6bdeafffb0038dc34bb5ff9889a85f6ca196ad00ffab40b765721d5cbf6">RTE_BBDEV_OP_NONE</a> }</td></tr>
<tr class="separator:a589f71722680b1d346be2d38a0385165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed6d26768b2f19c294deea5dd812f59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#afed6d26768b2f19c294deea5dd812f59">RTE_BBDEV_NAME_MAX_LEN</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:afed6d26768b2f19c294deea5dd812f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a794dc2714438a7dfe7b06cef27d87a97"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a>) (uint16_t dev_id, enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> event, void *cb_arg, void *ret_param)</td></tr>
<tr class="separator:a794dc2714438a7dfe7b06cef27d87a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a393a1f786e4ca5c3bf7481382c0c765a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a393a1f786e4ca5c3bf7481382c0c765a">rte_bbdev_state</a> </td></tr>
<tr class="separator:a393a1f786e4ca5c3bf7481382c0c765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f094d19776103df98851abe088313d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> { <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6adc0d3774bec179d6aef04c864bb5c057">RTE_BBDEV_EVENT_UNKNOWN</a>, 
<a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6a236bec3c622d84a51c5717ce6fd941f4">RTE_BBDEV_EVENT_ERROR</a>, 
<a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6acd75b27861793af96f1425b74855c1fa">RTE_BBDEV_EVENT_DEQUEUE</a>, 
<a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6afdcbb8073dfbdfd7b2d843e452cb5501">RTE_BBDEV_EVENT_MAX</a>
 }</td></tr>
<tr class="separator:a5f094d19776103df98851abe088313d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a34d49972bdea770c7c223731c7652835"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a34d49972bdea770c7c223731c7652835">rte_bbdev_count</a> (void)</td></tr>
<tr class="separator:a34d49972bdea770c7c223731c7652835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edf512273576d7a7b4ece00032e4c3c"><td class="memItemLeft" align="right" valign="top">__rte_experimental bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a6edf512273576d7a7b4ece00032e4c3c">rte_bbdev_is_valid</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a6edf512273576d7a7b4ece00032e4c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9422461b3817d1fd454eeeb5ebf498ef"><td class="memItemLeft" align="right" valign="top">__rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a9422461b3817d1fd454eeeb5ebf498ef">rte_bbdev_find_next</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a9422461b3817d1fd454eeeb5ebf498ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623e937648f4c54539df6d0a1f2e6b58"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a623e937648f4c54539df6d0a1f2e6b58">rte_bbdev_setup_queues</a> (uint16_t dev_id, uint16_t num_queues, int socket_id)</td></tr>
<tr class="separator:a623e937648f4c54539df6d0a1f2e6b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6087de07f2e6d10bb40aa2d168100a9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#ad6087de07f2e6d10bb40aa2d168100a9">rte_bbdev_intr_enable</a> (uint16_t dev_id)</td></tr>
<tr class="separator:ad6087de07f2e6d10bb40aa2d168100a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3058136163aeb9f4f7b08e9393d0b44a"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a3058136163aeb9f4f7b08e9393d0b44a">rte_bbdev_queue_configure</a> (uint16_t dev_id, uint16_t queue_id, const struct <a class="el" href="structrte__bbdev__queue__conf.html">rte_bbdev_queue_conf</a> *conf)</td></tr>
<tr class="separator:a3058136163aeb9f4f7b08e9393d0b44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2082859a085d3bbe939e446fc3f98271"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a2082859a085d3bbe939e446fc3f98271">rte_bbdev_start</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a2082859a085d3bbe939e446fc3f98271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d19b9e087b075aea19c0a458b1fdf04"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5d19b9e087b075aea19c0a458b1fdf04">rte_bbdev_stop</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a5d19b9e087b075aea19c0a458b1fdf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5841baca44b4d772ae6f1f83335da96b"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5841baca44b4d772ae6f1f83335da96b">rte_bbdev_close</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a5841baca44b4d772ae6f1f83335da96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b7689b1db2c4688130fec03c1ad1e7"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aa0b7689b1db2c4688130fec03c1ad1e7">rte_bbdev_queue_start</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:aa0b7689b1db2c4688130fec03c1ad1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6779bd9668d77f6a041d2c806d124cb"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#ae6779bd9668d77f6a041d2c806d124cb">rte_bbdev_queue_stop</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:ae6779bd9668d77f6a041d2c806d124cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24d9072b98e2d987387123e222c41c8"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#af24d9072b98e2d987387123e222c41c8">rte_bbdev_stats_get</a> (uint16_t dev_id, struct <a class="el" href="structrte__bbdev__stats.html">rte_bbdev_stats</a> *stats)</td></tr>
<tr class="separator:af24d9072b98e2d987387123e222c41c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196bf79fde8f2babe773b6ba12b40c40"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a196bf79fde8f2babe773b6ba12b40c40">rte_bbdev_stats_reset</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a196bf79fde8f2babe773b6ba12b40c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3e166b35448bb139d0328f44e2c61d"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a5b3e166b35448bb139d0328f44e2c61d">rte_bbdev_info_get</a> (uint16_t dev_id, struct <a class="el" href="structrte__bbdev__info.html">rte_bbdev_info</a> *dev_info)</td></tr>
<tr class="separator:a5b3e166b35448bb139d0328f44e2c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aed46ac382085aa64f1dd271c189dfb"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a4aed46ac382085aa64f1dd271c189dfb">rte_bbdev_queue_info_get</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__queue__info.html">rte_bbdev_queue_info</a> *queue_info)</td></tr>
<tr class="separator:a4aed46ac382085aa64f1dd271c189dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae73a556dc8268f37b131d13a2bff1cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aae73a556dc8268f37b131d13a2bff1cb">TAILQ_HEAD</a> (rte_bbdev_cb_list, rte_bbdev_callback)</td></tr>
<tr class="separator:aae73a556dc8268f37b131d13a2bff1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab860c77fa5cd1b0dcc590748441bedf"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aab860c77fa5cd1b0dcc590748441bedf">rte_bbdev_enqueue_enc_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:aab860c77fa5cd1b0dcc590748441bedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68431704ff25eafa914c20da694f1c1c"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a68431704ff25eafa914c20da694f1c1c">rte_bbdev_enqueue_dec_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a68431704ff25eafa914c20da694f1c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced7a614cb04bc64e19dfbc3a523c521"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aced7a614cb04bc64e19dfbc3a523c521">rte_bbdev_enqueue_ldpc_enc_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:aced7a614cb04bc64e19dfbc3a523c521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd81d8741b7b26e77294704d75e6a9ca"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#acd81d8741b7b26e77294704d75e6a9ca">rte_bbdev_enqueue_ldpc_dec_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:acd81d8741b7b26e77294704d75e6a9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e024de23689af0824205792802e9e3"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a09e024de23689af0824205792802e9e3">rte_bbdev_dequeue_enc_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a09e024de23689af0824205792802e9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8762149adde87a41b4dc7e990f6920b"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#af8762149adde87a41b4dc7e990f6920b">rte_bbdev_dequeue_dec_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:af8762149adde87a41b4dc7e990f6920b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066269d696adb2c232ca5592a8f45d4b"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a066269d696adb2c232ca5592a8f45d4b">rte_bbdev_dequeue_ldpc_enc_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a066269d696adb2c232ca5592a8f45d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc0e152ddcea15e4501635ee6c7ee10"><td class="memItemLeft" align="right" valign="top">static __rte_experimental uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a2cc0e152ddcea15e4501635ee6c7ee10">rte_bbdev_dequeue_ldpc_dec_ops</a> (uint16_t dev_id, uint16_t queue_id, struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **ops, uint16_t num_ops)</td></tr>
<tr class="separator:a2cc0e152ddcea15e4501635ee6c7ee10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8676d241e5a33d1f5add6a0ac27efb12"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a8676d241e5a33d1f5add6a0ac27efb12">rte_bbdev_callback_register</a> (uint16_t dev_id, enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> event, <a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="separator:a8676d241e5a33d1f5add6a0ac27efb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acae82b5da1123fc3beb260e98330d6"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a6acae82b5da1123fc3beb260e98330d6">rte_bbdev_callback_unregister</a> (uint16_t dev_id, enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> event, <a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="separator:a6acae82b5da1123fc3beb260e98330d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99309310c2af97c0eba93d80c206c2ef"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#a99309310c2af97c0eba93d80c206c2ef">rte_bbdev_queue_intr_enable</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:a99309310c2af97c0eba93d80c206c2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5637be86e2b3efabf6e4fb418ed934"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#aca5637be86e2b3efabf6e4fb418ed934">rte_bbdev_queue_intr_disable</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:aca5637be86e2b3efabf6e4fb418ed934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8e1f86cf03465802d241b66a6739d0"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__bbdev_8h.html#ada8e1f86cf03465802d241b66a6739d0">rte_bbdev_queue_intr_ctl</a> (uint16_t dev_id, uint16_t queue_id, int epfd, int op, void *data)</td></tr>
<tr class="separator:ada8e1f86cf03465802d241b66a6739d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wireless base band device abstraction APIs.</p>
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> All functions in this file may be changed or removed without prior notice.</dd></dl>
<p>This API allows an application to discover, configure and use a device to process operations. An asynchronous API (enqueue, followed by later dequeue) is used for processing operations.</p>
<p>The functions in this API are not thread-safe when called on the same target object (a device, or a queue on a device), with the exception that one thread can enqueue operations to a queue while another thread dequeues from the same queue. </p>

<p class="definition">Definition in file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afb7096069a91f3e740616a5967533973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7096069a91f3e740616a5967533973">&#9670;&nbsp;</a></span>RTE_BBDEV_MAX_DEVS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_BBDEV_MAX_DEVS&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of devices </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00043">43</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="af802dc9dbbdfce9e4d0aa55894dcbf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af802dc9dbbdfce9e4d0aa55894dcbf91">&#9670;&nbsp;</a></span>RTE_BBDEV_FOREACH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_BBDEV_FOREACH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (i = <a class="code" href="rte__bbdev_8h.html#a9422461b3817d1fd454eeeb5ebf498ef">rte_bbdev_find_next</a>(-1); \</div>
<div class="line">        i &lt; <a class="code" href="rte__bbdev_8h.html#afb7096069a91f3e740616a5967533973">RTE_BBDEV_MAX_DEVS</a>; \</div>
<div class="line">        i = <a class="code" href="rte__bbdev_8h.html#a9422461b3817d1fd454eeeb5ebf498ef">rte_bbdev_find_next</a>(i))</div>
</div><!-- fragment --><p>Iterate through all enabled devices </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00090">90</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a589f71722680b1d346be2d38a0385165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589f71722680b1d346be2d38a0385165">&#9670;&nbsp;</a></span>RTE_BBDEV_END_OF_CAPABILITIES_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_BBDEV_END_OF_CAPABILITIES_LIST</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;	{ <a class="el" href="rte__bbdev__op_8h.html#a35a82e6bdeafffb0038dc34bb5ff9889a85f6ca196ad00ffab40b765721d5cbf6">RTE_BBDEV_OP_NONE</a> }</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro used at end of bbdev PMD list </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00321">321</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="afed6d26768b2f19c294deea5dd812f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed6d26768b2f19c294deea5dd812f59">&#9670;&nbsp;</a></span>RTE_BBDEV_NAME_MAX_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_BBDEV_NAME_MAX_LEN&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max length of device name </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00412">412</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a794dc2714438a7dfe7b06cef27d87a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794dc2714438a7dfe7b06cef27d87a97">&#9670;&nbsp;</a></span>rte_bbdev_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_bbdev_cb_fn) (uint16_t dev_id, enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a> event, void *cb_arg, void *ret_param)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef for application callback function registered by application software for notification of device events</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device identifier </td></tr>
    <tr><td class="paramname">event</td><td>Device event to register for notification of. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>User specified parameter to be passed to user's callback function. </td></tr>
    <tr><td class="paramname">ret_param</td><td>To pass data back to user application. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00746">746</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a393a1f786e4ca5c3bf7481382c0c765a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393a1f786e4ca5c3bf7481382c0c765a">&#9670;&nbsp;</a></span>rte_bbdev_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__bbdev_8h.html#a393a1f786e4ca5c3bf7481382c0c765a">rte_bbdev_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags indicate current state of BBDEV device </p>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00047">47</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a5f094d19776103df98851abe088313d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f094d19776103df98851abe088313d6">&#9670;&nbsp;</a></span>rte_bbdev_event_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Definitions of device event types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f094d19776103df98851abe088313d6adc0d3774bec179d6aef04c864bb5c057"></a>RTE_BBDEV_EVENT_UNKNOWN&#160;</td><td class="fielddoc"><p>unknown event type </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f094d19776103df98851abe088313d6a236bec3c622d84a51c5717ce6fd941f4"></a>RTE_BBDEV_EVENT_ERROR&#160;</td><td class="fielddoc"><p>error interrupt event </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f094d19776103df98851abe088313d6acd75b27861793af96f1425b74855c1fa"></a>RTE_BBDEV_EVENT_DEQUEUE&#160;</td><td class="fielddoc"><p>dequeue event </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f094d19776103df98851abe088313d6afdcbb8073dfbdfd7b2d843e452cb5501"></a>RTE_BBDEV_EVENT_MAX&#160;</td><td class="fielddoc"><p>max value of this enum </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00726">726</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a34d49972bdea770c7c223731c7652835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d49972bdea770c7c223731c7652835">&#9670;&nbsp;</a></span>rte_bbdev_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint16_t rte_bbdev_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of devices that have been successfully initialised.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of usable devices. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a117">examples/bbdev_app/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a6edf512273576d7a7b4ece00032e4c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edf512273576d7a7b4ece00032e4c3c">&#9670;&nbsp;</a></span>rte_bbdev_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental bool rte_bbdev_is_valid </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a device is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if device ID is valid and device is attached, false otherwise. </dd></dl>

</div>
</div>
<a id="a9422461b3817d1fd454eeeb5ebf498ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9422461b3817d1fd454eeeb5ebf498ef">&#9670;&nbsp;</a></span>rte_bbdev_find_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental uint16_t rte_bbdev_find_next </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next enabled device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The current device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The next device, or</li>
<li>RTE_BBDEV_MAX_DEVS if none found </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a623e937648f4c54539df6d0a1f2e6b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623e937648f4c54539df6d0a1f2e6b58">&#9670;&nbsp;</a></span>rte_bbdev_setup_queues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_setup_queues </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_queues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup up device queues. This function must be called on a device before setting up the queues and starting the device. It can also be called when a device is in the stopped state. If any device queues have been configured their configuration will be cleared by a call to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">num_queues</td><td>Number of queues to configure on device. </td></tr>
    <tr><td class="paramname">socket_id</td><td>ID of a socket which will be used to allocate memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-ENODEV if dev_id is invalid or the device is corrupted</li>
<li>-EINVAL if num_queues is invalid, 0 or greater than maximum</li>
<li>-EBUSY if the identified device has already started</li>
<li>-ENOMEM if unable to allocate memory </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a85">examples/bbdev_app/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="ad6087de07f2e6d10bb40aa2d168100a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6087de07f2e6d10bb40aa2d168100a9">&#9670;&nbsp;</a></span>rte_bbdev_intr_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_intr_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable interrupts. This function may be called before starting the device to enable the interrupts if they are available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>-ENODEV if dev_id is invalid or the device is corrupted</li>
<li>-EBUSY if the identified device has already started</li>
<li>-ENOTSUP if the interrupts are not supported by the device </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a3058136163aeb9f4f7b08e9393d0b44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3058136163aeb9f4f7b08e9393d0b44a">&#9670;&nbsp;</a></span>rte_bbdev_queue_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_queue_configure </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__bbdev__queue__conf.html">rte_bbdev_queue_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure a queue on a device. This function can be called after device configuration, and before starting. It can also be called when the device or the queue is in the stopped state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">conf</td><td>The queue configuration. If NULL, a default configuration will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if the identified queue size or priority are invalid</li>
<li>EBUSY if the identified queue or its device have already started </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a92">examples/bbdev_app/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a2082859a085d3bbe939e446fc3f98271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2082859a085d3bbe939e446fc3f98271">&#9670;&nbsp;</a></span>rte_bbdev_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_start </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a device. This is the last step needed before enqueueing operations is possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD driver </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a93">examples/bbdev_app/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a5d19b9e087b075aea19c0a458b1fdf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d19b9e087b075aea19c0a458b1fdf04">&#9670;&nbsp;</a></span>rte_bbdev_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_stop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a device. The device can be reconfigured, and restarted after being stopped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5841baca44b4d772ae6f1f83335da96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5841baca44b4d772ae6f1f83335da96b">&#9670;&nbsp;</a></span>rte_bbdev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_close </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a device. The device cannot be restarted without reconfiguration!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa0b7689b1db2c4688130fec03c1ad1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b7689b1db2c4688130fec03c1ad1e7">&#9670;&nbsp;</a></span>rte_bbdev_queue_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_queue_start </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a specified queue on a device. This is only needed if the queue has been stopped, or if the deferred_start flag has been set when configuring the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD driver </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ae6779bd9668d77f6a041d2c806d124cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6779bd9668d77f6a041d2c806d124cb">&#9670;&nbsp;</a></span>rte_bbdev_queue_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_queue_stop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a specified queue on a device, to allow re configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD driver </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af24d9072b98e2d987387123e222c41c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24d9072b98e2d987387123e222c41c8">&#9670;&nbsp;</a></span>rte_bbdev_stats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_stats_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__stats.html">rte_bbdev_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the general I/O statistics of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">stats</td><td>Pointer to structure to where statistics will be copied. On error, this location may or may not have been modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if invalid parameter pointer is provided </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a51">examples/bbdev_app/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a196bf79fde8f2babe773b6ba12b40c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196bf79fde8f2babe773b6ba12b40c40">&#9670;&nbsp;</a></span>rte_bbdev_stats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_stats_reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the statistics of a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5b3e166b35448bb139d0328f44e2c61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3e166b35448bb139d0328f44e2c61d">&#9670;&nbsp;</a></span>rte_bbdev_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__info.html">rte_bbdev_info</a> *&#160;</td>
          <td class="paramname"><em>dev_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">dev_info</td><td>Pointer to structure to where information will be copied. On error, this location may or may not have been modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if invalid parameter pointer is provided </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a95">examples/bbdev_app/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a4aed46ac382085aa64f1dd271c189dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aed46ac382085aa64f1dd271c189dfb">&#9670;&nbsp;</a></span>rte_bbdev_queue_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_queue_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__queue__info.html">rte_bbdev_queue_info</a> *&#160;</td>
          <td class="paramname"><em>queue_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information about a specific queue on a device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">queue_info</td><td>Pointer to structure to where information will be copied. On error, this location may or may not have been modified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if invalid parameter pointer is provided </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aae73a556dc8268f37b131d13a2bff1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae73a556dc8268f37b131d13a2bff1cb">&#9670;&nbsp;</a></span>TAILQ_HEAD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TAILQ_HEAD </td>
          <td>(</td>
          <td class="paramtype">rte_bbdev_cb_list&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_bbdev_callback&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Structure to keep track of registered callbacks </p>

</div>
</div>
<a id="aab860c77fa5cd1b0dcc590748441bedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab860c77fa5cd1b0dcc590748441bedf">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_enc_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_enqueue_enc_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of processed encode operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a67">examples/bbdev_app/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00495">495</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a68431704ff25eafa914c20da694f1c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68431704ff25eafa914c20da694f1c1c">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_dec_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_enqueue_dec_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of processed decode operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a79">examples/bbdev_app/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00526">526</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="aced7a614cb04bc64e19dfbc3a523c521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced7a614cb04bc64e19dfbc3a523c521">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_ldpc_enc_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_enqueue_ldpc_enc_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of processed encode operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00557">557</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="acd81d8741b7b26e77294704d75e6a9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd81d8741b7b26e77294704d75e6a9ca">&#9670;&nbsp;</a></span>rte_bbdev_enqueue_ldpc_dec_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_enqueue_ldpc_dec_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enqueue a burst of processed decode operations to a queue of the device. This functions only enqueues as many operations as currently possible and does not block until <code>num_ops</code> entries in the queue are available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array containing operations to be enqueued Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to enqueue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually enqueued (this is the number of processed entries in the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00588">588</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a09e024de23689af0824205792802e9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e024de23689af0824205792802e9e3">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_enc_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_dequeue_enc_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of processed encode operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries ie. A pointer to a table of void * pointers (ops) that will be filled. </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a69">examples/bbdev_app/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00621">621</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="af8762149adde87a41b4dc7e990f6920b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8762149adde87a41b4dc7e990f6920b">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_dec_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_dequeue_dec_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of processed decode operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries ie. A pointer to a table of void * pointers (ops) that will be filled. </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a81">examples/bbdev_app/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00654">654</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a066269d696adb2c232ca5592a8f45d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066269d696adb2c232ca5592a8f45d4b">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_ldpc_enc_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_dequeue_ldpc_enc_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__enc__op.html">rte_bbdev_enc_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of processed encode operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00686">686</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a2cc0e152ddcea15e4501635ee6c7ee10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc0e152ddcea15e4501635ee6c7ee10">&#9670;&nbsp;</a></span>rte_bbdev_dequeue_ldpc_dec_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental uint16_t rte_bbdev_dequeue_ldpc_dec_ops </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__bbdev__dec__op.html">rte_bbdev_dec_op</a> **&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dequeue a burst of processed decode operations from a queue of the device. This functions returns only the current contents of the queue, and does not block until @ num_ops is available. This function does not provide any error notification to avoid the corresponding overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">ops</td><td>Pointer array where operations will be dequeued to. Must have at least <code>num_ops</code> entries </td></tr>
    <tr><td class="paramname">num_ops</td><td>The maximum number of operations to dequeue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of operations actually dequeued (this is the number of entries copied into the <code>ops</code> array). </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__bbdev_8h_source.html#l00717">717</a> of file <a class="el" href="rte__bbdev_8h_source.html">rte_bbdev.h</a>.</p>

</div>
</div>
<a id="a8676d241e5a33d1f5add6a0ac27efb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8676d241e5a33d1f5add6a0ac27efb12">&#9670;&nbsp;</a></span>rte_bbdev_callback_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_callback_register </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a callback function for specific device id. Multiple callbacks can be added and will be called in the order they are added when an event is triggered. Callbacks are called in a separate thread created by the DPDK EAL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Device id. </td></tr>
    <tr><td class="paramname">event</td><td>The event that the callback will be registered for. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>User supplied callback function to be called. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Pointer to parameter that will be passed to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, negative value on failure. </dd></dl>

</div>
</div>
<a id="a6acae82b5da1123fc3beb260e98330d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acae82b5da1123fc3beb260e98330d6">&#9670;&nbsp;</a></span>rte_bbdev_callback_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_callback_unregister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__bbdev_8h.html#a5f094d19776103df98851abe088313d6">rte_bbdev_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__bbdev_8h.html#a794dc2714438a7dfe7b06cef27d87a97">rte_bbdev_cb_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for specific device id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The device identifier. </td></tr>
    <tr><td class="paramname">event</td><td>The event that the callback will be unregistered for. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>User supplied callback function to be unregistered. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Pointer to the parameter supplied when registering the callback. (void *)-1 means to remove all registered callbacks with the specified function address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>EINVAL if invalid parameter pointer is provided</li>
<li>EAGAIN if the provided callback pointer does not exist </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a99309310c2af97c0eba93d80c206c2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99309310c2af97c0eba93d80c206c2ef">&#9670;&nbsp;</a></span>rte_bbdev_queue_intr_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_queue_intr_enable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable a one-shot interrupt on the next operation enqueued to a particular queue. The interrupt will be triggered when the operation is ready to be dequeued. To handle the interrupt, an epoll file descriptor must be registered using <a class="el" href="rte__bbdev_8h.html#ada8e1f86cf03465802d241b66a6739d0">rte_bbdev_queue_intr_ctl()</a>, and then an application thread/lcore can wait for the interrupt using <a class="el" href="rte__eal__interrupts_8h.html#ae21a1a9a960fb68888b2a8918f73e879">rte_epoll_wait()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The device identifier. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD driver </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aca5637be86e2b3efabf6e4fb418ed934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5637be86e2b3efabf6e4fb418ed934">&#9670;&nbsp;</a></span>rte_bbdev_queue_intr_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_queue_intr_disable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable a one-shot interrupt on the next operation enqueued to a particular queue (if it has been enabled).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The device identifier. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>negative value on failure - as returned from PMD driver </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ada8e1f86cf03465802d241b66a6739d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8e1f86cf03465802d241b66a6739d0">&#9670;&nbsp;</a></span>rte_bbdev_queue_intr_ctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_bbdev_queue_intr_ctl </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Control interface for per-queue interrupts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The device identifier. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the queue. </td></tr>
    <tr><td class="paramname">epfd</td><td>Epoll file descriptor that will be associated with the interrupt source. If the special value RTE_EPOLL_PER_THREAD is provided, a per thread epoll file descriptor created by the EAL is used (RTE_EPOLL_PER_THREAD can also be used when calling <a class="el" href="rte__eal__interrupts_8h.html#ae21a1a9a960fb68888b2a8918f73e879">rte_epoll_wait()</a>). </td></tr>
    <tr><td class="paramname">op</td><td>The operation be performed for the vector.RTE_INTR_EVENT_ADD or RTE_INTR_EVENT_DEL. </td></tr>
    <tr><td class="paramname">data</td><td>User context, that will be returned in the epdata.data field of the <a class="el" href="structrte__epoll__event.html">rte_epoll_event</a> structure filled in by <a class="el" href="rte__eal__interrupts_8h.html#ae21a1a9a960fb68888b2a8918f73e879">rte_epoll_wait()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success</li>
<li>ENOTSUP if interrupts are not supported by the identified device</li>
<li>negative value on failure - as returned from PMD driver </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="arte__bbdev_8h_html_a9422461b3817d1fd454eeeb5ebf498ef"><div class="ttname"><a href="rte__bbdev_8h.html#a9422461b3817d1fd454eeeb5ebf498ef">rte_bbdev_find_next</a></div><div class="ttdeci">__rte_experimental uint16_t rte_bbdev_find_next(uint16_t dev_id)</div></div>
<div class="ttc" id="arte__bbdev_8h_html_afb7096069a91f3e740616a5967533973"><div class="ttname"><a href="rte__bbdev_8h.html#afb7096069a91f3e740616a5967533973">RTE_BBDEV_MAX_DEVS</a></div><div class="ttdeci">#define RTE_BBDEV_MAX_DEVS</div><div class="ttdef"><b>Definition:</b> <a href="rte__bbdev_8h_source.html#l00043">rte_bbdev.h:43</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
