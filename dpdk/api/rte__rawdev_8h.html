<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_rawdev/rte_rawdev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_537c65abdcc57b6687fa40a177fe2911.html">librte_rawdev</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_rawdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__errno_8h_source.html">rte_errno.h</a>&gt;</code><br />
</div>
<p><a href="rte__rawdev_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__rawdev__xstats__name.html">rte_rawdev_xstats_name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad99996a5cd9945fac78412e2a770cb7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#ad99996a5cd9945fac78412e2a770cb7a">RTE_RAW_DEV_XSTATS_NAME_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:ad99996a5cd9945fac78412e2a770cb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a79e12d6d63b67fe362b417d9addb347e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a79e12d6d63b67fe362b417d9addb347e">rte_rawdev_count</a> (void)</td></tr>
<tr class="separator:a79e12d6d63b67fe362b417d9addb347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb7905bb765767cc942658b3627b2a7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a3fb7905bb765767cc942658b3627b2a7">rte_rawdev_get_dev_id</a> (const char *name)</td></tr>
<tr class="separator:a3fb7905bb765767cc942658b3627b2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7f7a289d6a8f7c9ddce14dff38a48a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a6d7f7a289d6a8f7c9ddce14dff38a48a">rte_rawdev_socket_id</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a6d7f7a289d6a8f7c9ddce14dff38a48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef72677f798a8370a64a8aa8c46beba7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#aef72677f798a8370a64a8aa8c46beba7">rte_rawdev_info_get</a> (uint16_t dev_id, struct rte_rawdev_info *dev_info, size_t dev_private_size)</td></tr>
<tr class="separator:aef72677f798a8370a64a8aa8c46beba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf894153e16c9403e11c487bcc41b248"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#abf894153e16c9403e11c487bcc41b248">rte_rawdev_configure</a> (uint16_t dev_id, struct rte_rawdev_info *dev_conf, size_t dev_private_size)</td></tr>
<tr class="separator:abf894153e16c9403e11c487bcc41b248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14dd7f402beec787a49157ec163b802"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#ae14dd7f402beec787a49157ec163b802">rte_rawdev_queue_conf_get</a> (uint16_t dev_id, uint16_t queue_id, rte_rawdev_obj_t queue_conf, size_t queue_conf_size)</td></tr>
<tr class="separator:ae14dd7f402beec787a49157ec163b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bda325a2bd66d8ebc5db3ede93acfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#ae9bda325a2bd66d8ebc5db3ede93acfa">rte_rawdev_queue_setup</a> (uint16_t dev_id, uint16_t queue_id, rte_rawdev_obj_t queue_conf, size_t queue_conf_size)</td></tr>
<tr class="separator:ae9bda325a2bd66d8ebc5db3ede93acfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17de75b477bde83d40ce300c2aca3fbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a17de75b477bde83d40ce300c2aca3fbe">rte_rawdev_queue_release</a> (uint16_t dev_id, uint16_t queue_id)</td></tr>
<tr class="separator:a17de75b477bde83d40ce300c2aca3fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d837c2e95329a73ab050b2eb20266c4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a0d837c2e95329a73ab050b2eb20266c4">rte_rawdev_queue_count</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a0d837c2e95329a73ab050b2eb20266c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e470ce565295047c323fd2d8c449ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#af2e470ce565295047c323fd2d8c449ad">rte_rawdev_start</a> (uint16_t dev_id)</td></tr>
<tr class="separator:af2e470ce565295047c323fd2d8c449ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5395321daab8ff98447a296880cc4ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a5395321daab8ff98447a296880cc4ae9">rte_rawdev_stop</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a5395321daab8ff98447a296880cc4ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa4a26f63848ac2e8162fd2c19b332d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#adfa4a26f63848ac2e8162fd2c19b332d">rte_rawdev_close</a> (uint16_t dev_id)</td></tr>
<tr class="separator:adfa4a26f63848ac2e8162fd2c19b332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd447c7b6c831fbf6300b261e62028d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#acbd447c7b6c831fbf6300b261e62028d">rte_rawdev_reset</a> (uint16_t dev_id)</td></tr>
<tr class="separator:acbd447c7b6c831fbf6300b261e62028d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d33ac52259b50892bd891e229b5b0d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a5d33ac52259b50892bd891e229b5b0d4">rte_rawdev_dump</a> (uint16_t dev_id, FILE *f)</td></tr>
<tr class="separator:a5d33ac52259b50892bd891e229b5b0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bb29d3791a9866fab73ab97f44b568"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a59bb29d3791a9866fab73ab97f44b568">rte_rawdev_get_attr</a> (uint16_t dev_id, const char *attr_name, uint64_t *attr_value)</td></tr>
<tr class="separator:a59bb29d3791a9866fab73ab97f44b568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89055cb62b725345bfd536e608ab939f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a89055cb62b725345bfd536e608ab939f">rte_rawdev_set_attr</a> (uint16_t dev_id, const char *attr_name, const uint64_t attr_value)</td></tr>
<tr class="separator:a89055cb62b725345bfd536e608ab939f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd0c1f93d46bd0de6766ce35438727b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a0bd0c1f93d46bd0de6766ce35438727b">rte_rawdev_enqueue_buffers</a> (uint16_t dev_id, struct rte_rawdev_buf **buffers, unsigned int count, rte_rawdev_obj_t context)</td></tr>
<tr class="separator:a0bd0c1f93d46bd0de6766ce35438727b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850206928a35e126b04f206294369998"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a850206928a35e126b04f206294369998">rte_rawdev_dequeue_buffers</a> (uint16_t dev_id, struct rte_rawdev_buf **buffers, unsigned int count, rte_rawdev_obj_t context)</td></tr>
<tr class="separator:a850206928a35e126b04f206294369998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae293a5d25d141ee348012c140d48b450"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#ae293a5d25d141ee348012c140d48b450">rte_rawdev_xstats_names_get</a> (uint16_t dev_id, struct <a class="el" href="structrte__rawdev__xstats__name.html">rte_rawdev_xstats_name</a> *xstats_names, unsigned int size)</td></tr>
<tr class="separator:ae293a5d25d141ee348012c140d48b450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a6cb31d4c8ff7d7f46d9e24aa71230"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a23a6cb31d4c8ff7d7f46d9e24aa71230">rte_rawdev_xstats_get</a> (uint16_t dev_id, const unsigned int ids[], uint64_t values[], unsigned int n)</td></tr>
<tr class="separator:a23a6cb31d4c8ff7d7f46d9e24aa71230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dd705b822ad2193fe25244e8eb1d63"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a36dd705b822ad2193fe25244e8eb1d63">rte_rawdev_xstats_by_name_get</a> (uint16_t dev_id, const char *name, unsigned int *id)</td></tr>
<tr class="separator:a36dd705b822ad2193fe25244e8eb1d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30147de390b2761c57c33ea52b503983"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a30147de390b2761c57c33ea52b503983">rte_rawdev_xstats_reset</a> (uint16_t dev_id, const uint32_t ids[], uint32_t nb_ids)</td></tr>
<tr class="separator:a30147de390b2761c57c33ea52b503983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f5e1bf7b75cfdc565e2f08373a7aad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a74f5e1bf7b75cfdc565e2f08373a7aad">rte_rawdev_firmware_status_get</a> (uint16_t dev_id, rte_rawdev_obj_t status_info)</td></tr>
<tr class="separator:a74f5e1bf7b75cfdc565e2f08373a7aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa264e1f4d4d14b03d4c94b30c96774bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#aa264e1f4d4d14b03d4c94b30c96774bd">rte_rawdev_firmware_version_get</a> (uint16_t dev_id, rte_rawdev_obj_t version_info)</td></tr>
<tr class="separator:aa264e1f4d4d14b03d4c94b30c96774bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6b2738c496bcf86ccf5e8a06367625"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a2d6b2738c496bcf86ccf5e8a06367625">rte_rawdev_firmware_load</a> (uint16_t dev_id, rte_rawdev_obj_t firmware_image)</td></tr>
<tr class="separator:a2d6b2738c496bcf86ccf5e8a06367625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ef8524e162453524b5cfb827661df2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#ad8ef8524e162453524b5cfb827661df2">rte_rawdev_firmware_unload</a> (uint16_t dev_id)</td></tr>
<tr class="separator:ad8ef8524e162453524b5cfb827661df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776edaa7060fc6a9d66e00f84132e140"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rawdev_8h.html#a776edaa7060fc6a9d66e00f84132e140">rte_rawdev_selftest</a> (uint16_t dev_id)</td></tr>
<tr class="separator:a776edaa7060fc6a9d66e00f84132e140"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic device abstraction APIs.</p>
<p>This API allow applications to configure and use generic devices having no specific type already available in DPDK. </p>

<p class="definition">Definition in file <a class="el" href="rte__rawdev_8h_source.html">rte_rawdev.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad99996a5cd9945fac78412e2a770cb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99996a5cd9945fac78412e2a770cb7a">&#9670;&nbsp;</a></span>RTE_RAW_DEV_XSTATS_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_RAW_DEV_XSTATS_NAME_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum name length for extended statistics counters </p>

<p class="definition">Definition at line <a class="el" href="rte__rawdev_8h_source.html#l00447">447</a> of file <a class="el" href="rte__rawdev_8h_source.html">rte_rawdev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a79e12d6d63b67fe362b417d9addb347e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e12d6d63b67fe362b417d9addb347e">&#9670;&nbsp;</a></span>rte_rawdev_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rte_rawdev_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of raw devices that have been successfully initialised.</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of usable raw devices. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a47">examples/ioat/ioatfwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a3fb7905bb765767cc942658b3627b2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb7905bb765767cc942658b3627b2a7">&#9670;&nbsp;</a></span>rte_rawdev_get_dev_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_rawdev_get_dev_id </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the device identifier for the named raw device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Raw device name to select the raw device identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns raw device identifier on success.<ul>
<li>&lt;0: Failure to find named raw device. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2vhost_2ioat_8c-example.html#a4">examples/vhost/ioat.c</a>.</dd>
</dl>

</div>
</div>
<a id="a6d7f7a289d6a8f7c9ddce14dff38a48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7f7a289d6a8f7c9ddce14dff38a48a">&#9670;&nbsp;</a></span>rte_rawdev_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_socket_id </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the NUMA socket to which a device is connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The NUMA socket id to which the device is connected or a default of zero if the socket could not be determined. -(-EINVAL) dev_id value is out of range. </dd></dl>

</div>
</div>
<a id="aef72677f798a8370a64a8aa8c46beba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef72677f798a8370a64a8aa8c46beba7">&#9670;&nbsp;</a></span>rte_rawdev_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_info_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_rawdev_info *&#160;</td>
          <td class="paramname"><em>dev_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dev_private_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the contextual information of a raw device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev_info</td><td>A pointer to a structure of type <em>rte_rawdev_info</em> to be filled with the contextual information of the device. The dev_info-&gt;dev_private field should point to an appropriate buffer space for holding the device- specific info for that hardware. If the dev_private field is set to NULL, then the device-specific info function will not be called and only basic information about the device will be returned. This can be used to safely query the type of a rawdev instance without needing to know the size of the private data to return.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dev_private_size</td><td>The length of the memory space pointed to by dev_private in dev_info. This should be set to the size of the expected private structure to be returned, and may be checked by drivers to ensure the expected struct type is provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the contextual information of the raw device</li>
<li>&lt;0: Error code returned by the driver info get function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a48">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a74">examples/ntb/ntb_fwd.c</a>, and <a class="el" href="examples_2vhost_2ioat_8c-example.html#a5">examples/vhost/ioat.c</a>.</dd>
</dl>

</div>
</div>
<a id="abf894153e16c9403e11c487bcc41b248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf894153e16c9403e11c487bcc41b248">&#9670;&nbsp;</a></span>rte_rawdev_configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_configure </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_rawdev_info *&#160;</td>
          <td class="paramname"><em>dev_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dev_private_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure a raw device.</p>
<p>This function must be invoked first before any other function in the API. This function can also be re-invoked when a device is in the stopped state.</p>
<p>The caller may use <a class="el" href="rte__rawdev_8h.html#aef72677f798a8370a64a8aa8c46beba7">rte_rawdev_info_get()</a> to get the capability of each resources available for this raw device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">dev_conf</td><td>The raw device configuration structure encapsulated into rte_rawdev_info object. It is assumed that the opaque object has enough information which the driver/implementation can use to configure the device. It is also assumed that once the configuration is done, a <code>queue_id</code> type field can be used to refer to some arbitrary internal representation of a queue. </td></tr>
    <tr><td class="paramname">dev_private_size</td><td>The length of the memory space pointed to by dev_private in dev_info. This should be set to the size of the expected private structure to be used by the driver, and may be checked by drivers to ensure the expected struct type is provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device configured.</li>
<li>&lt;0: Error code returned by the driver configuration function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a45">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a76">examples/ntb/ntb_fwd.c</a>, and <a class="el" href="examples_2vhost_2ioat_8c-example.html#a6">examples/vhost/ioat.c</a>.</dd>
</dl>

</div>
</div>
<a id="ae14dd7f402beec787a49157ec163b802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14dd7f402beec787a49157ec163b802">&#9670;&nbsp;</a></span>rte_rawdev_queue_conf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_queue_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_rawdev_obj_t&#160;</td>
          <td class="paramname"><em>queue_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>queue_conf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the current configuration information of a raw queue designated by its <em>queue_id</em> from the raw driver for a raw device.</p>
<p>This function intended to be used in conjunction with rte_raw_queue_setup() where caller needs to set up the queue by overriding few default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_id</td><td>The index of the raw queue to get the configuration information. The value must be in the range [0, nb_raw_queues - 1] previously supplied to <a class="el" href="rte__rawdev_8h.html#abf894153e16c9403e11c487bcc41b248">rte_rawdev_configure()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queue_conf</td><td>The pointer to the default raw queue configuration data. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_conf_size</td><td>The size of the structure pointed to by queue_conf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, driver updates the default raw queue configuration data.</li>
<li>&lt;0: Error code returned by the driver info get function.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>rte_raw_queue_setup() </dd></dl>

</div>
</div>
<a id="ae9bda325a2bd66d8ebc5db3ede93acfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bda325a2bd66d8ebc5db3ede93acfa">&#9670;&nbsp;</a></span>rte_rawdev_queue_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_rawdev_obj_t&#160;</td>
          <td class="paramname"><em>queue_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>queue_conf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up a raw queue for a raw device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the raw queue to setup. The value must be in the range [0, nb_raw_queues - 1] previously supplied to <a class="el" href="rte__rawdev_8h.html#abf894153e16c9403e11c487bcc41b248">rte_rawdev_configure()</a>. </td></tr>
    <tr><td class="paramname">queue_conf</td><td>The pointer to the configuration data to be used for the raw queue. NULL value is allowed, in which case default configuration used. </td></tr>
    <tr><td class="paramname">queue_conf_size</td><td>The size of the structure pointed to by queue_conf</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__rawdev_8h.html#ae14dd7f402beec787a49157ec163b802">rte_rawdev_queue_conf_get()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, raw queue correctly set up.</li>
<li>&lt;0: raw queue configuration failed </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a77">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a17de75b477bde83d40ce300c2aca3fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17de75b477bde83d40ce300c2aca3fbe">&#9670;&nbsp;</a></span>rte_rawdev_queue_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_queue_release </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release and deallocate a raw queue from a raw device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the raw queue to release. The value must be in the range [0, nb_raw_queues - 1] previously supplied to <a class="el" href="rte__rawdev_8h.html#abf894153e16c9403e11c487bcc41b248">rte_rawdev_configure()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="rte__rawdev_8h.html#ae14dd7f402beec787a49157ec163b802">rte_rawdev_queue_conf_get()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, raw queue released.</li>
<li>&lt;0: raw queue configuration failed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0d837c2e95329a73ab050b2eb20266c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d837c2e95329a73ab050b2eb20266c4">&#9670;&nbsp;</a></span>rte_rawdev_queue_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rte_rawdev_queue_count </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of raw queues on a specific raw device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The number of configured raw queues </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af2e470ce565295047c323fd2d8c449ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e470ce565295047c323fd2d8c449ad">&#9670;&nbsp;</a></span>rte_rawdev_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_start </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a raw device.</p>
<p>The device start step is the last one and consists of setting the raw queues to start accepting the raws and schedules to raw ports.</p>
<p>On success, all basic functions exported by the API (raw enqueue, raw dequeue and so on) can be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device started. &lt; 0: Failure </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a46">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a79">examples/ntb/ntb_fwd.c</a>, and <a class="el" href="examples_2vhost_2ioat_8c-example.html#a7">examples/vhost/ioat.c</a>.</dd>
</dl>

</div>
</div>
<a id="a5395321daab8ff98447a296880cc4ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5395321daab8ff98447a296880cc4ae9">&#9670;&nbsp;</a></span>rte_rawdev_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_rawdev_stop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a raw device. The device can be restarted with a call to <a class="el" href="rte__rawdev_8h.html#af2e470ce565295047c323fd2d8c449ad">rte_rawdev_start()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a94">examples/ioat/ioatfwd.c</a>, and <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a10">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="adfa4a26f63848ac2e8162fd2c19b332d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa4a26f63848ac2e8162fd2c19b332d">&#9670;&nbsp;</a></span>rte_rawdev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_close </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close a raw device. The device cannot be restarted after this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on successfully closing device</li>
<li>&lt;0 on failure to close device</li>
<li>(-EAGAIN) if device is busy </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a11">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="acbd447c7b6c831fbf6300b261e62028d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd447c7b6c831fbf6300b261e62028d">&#9670;&nbsp;</a></span>rte_rawdev_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset a raw device. This is different from cycle of rte_rawdev_start-&gt;rte_rawdev_stop in the sense similar to hard or soft reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifiers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for successful reset, !0 for failure in resetting </dd></dl>

</div>
</div>
<a id="a5d33ac52259b50892bd891e229b5b0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d33ac52259b50892bd891e229b5b0d4">&#9670;&nbsp;</a></span>rte_rawdev_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_dump </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump internal information about <em>dev_id</em> to the FILE* provided in <em>f</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device.</td></tr>
    <tr><td class="paramname">f</td><td>A pointer to a file for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: on success</li>
<li>&lt;0: on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a59bb29d3791a9866fab73ab97f44b568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bb29d3791a9866fab73ab97f44b568">&#9670;&nbsp;</a></span>rte_rawdev_get_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_get_attr </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an attribute value from implementation. Attribute is an opaque handle agreed upon between application and PMD.</p>
<p>Implementations are expected to maintain an array of attribute-value pairs based on application calls. Memory management for this structure is shared responsibility of implementation and application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">attr_name</td><td>Opaque object representing an attribute in implementation. </td></tr>
    <tr><td class="paramname">attr_value</td><td>[out] Opaque response to the attribute value. In case of error, this remains untouched. This is double pointer of void type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success !0 Error; attr_value remains untouched in case of error. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a23">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a89055cb62b725345bfd536e608ab939f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89055cb62b725345bfd536e608ab939f">&#9670;&nbsp;</a></span>rte_rawdev_set_attr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_set_attr </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an attribute value. Attribute is an opaque handle agreed upon between application and PMD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">attr_name</td><td>Opaque object representing an attribute in implementation. </td></tr>
    <tr><td class="paramname">attr_value</td><td>Value of the attribute represented by attr_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success !0 Error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a15">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a0bd0c1f93d46bd0de6766ce35438727b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd0c1f93d46bd0de6766ce35438727b">&#9670;&nbsp;</a></span>rte_rawdev_enqueue_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_enqueue_buffers </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_rawdev_buf **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_rawdev_obj_t&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue a stream of buffers to the device.</p>
<p>Rather than specifying a queue, this API passes along an opaque object to the driver implementation. That object can be a queue or any other contextual information necessary for the device to enqueue buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">buffers</td><td>Collection of buffers for enqueuing </td></tr>
    <tr><td class="paramname">count</td><td>Count of buffers to enqueue </td></tr>
    <tr><td class="paramname">context</td><td>Opaque context information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 for buffers enqueued !0 for failure. Whether partial enqueue is failure or success is defined between app and driver implementation. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a20">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a850206928a35e126b04f206294369998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850206928a35e126b04f206294369998">&#9670;&nbsp;</a></span>rte_rawdev_dequeue_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_dequeue_buffers </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_rawdev_buf **&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_rawdev_obj_t&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequeue a stream of buffers from the device.</p>
<p>Rather than specifying a queue, this API passes along an opaque object to the driver implementation. That object can be a queue or any other contextual information necessary for the device to dequeue buffers.</p>
<p>Application should have allocated enough space to store <code>count</code> response buffers. Releasing buffers dequeued is responsibility of the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device to configure. </td></tr>
    <tr><td class="paramname">buffers</td><td>Collection of buffers dequeued </td></tr>
    <tr><td class="paramname">count</td><td>Max buffers expected to be dequeued </td></tr>
    <tr><td class="paramname">context</td><td>Opaque context information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 for buffers dequeued !0 for failure. Whether partial enqueue is failure or success is defined between app and driver implementation. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a24">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="ae293a5d25d141ee348012c140d48b450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae293a5d25d141ee348012c140d48b450">&#9670;&nbsp;</a></span>rte_rawdev_xstats_names_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_xstats_names_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__rawdev__xstats__name.html">rte_rawdev_xstats_name</a> *&#160;</td>
          <td class="paramname"><em>xstats_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve names of extended statistics of a raw device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the raw device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xstats_names</td><td>Block of memory to insert names into. Must be at least size in capacity. If set to NULL, function returns required capacity. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Capacity of xstats_names (number of names). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value lower or equal to size: success. The return value is the number of entries filled in the stats table.</li>
<li>positive value higher than size: error, the given statistics table is too small. The return value corresponds to the size that should be given to succeed. The entries in the table are not valid and shall not be used by the caller.</li>
<li>negative value on error: -ENODEV for invalid <em>dev_id</em> -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a7">examples/ioat/ioatfwd.c</a>, and <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a38">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a23a6cb31d4c8ff7d7f46d9e24aa71230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a6cb31d4c8ff7d7f46d9e24aa71230">&#9670;&nbsp;</a></span>rte_rawdev_xstats_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_xstats_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>values</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve extended statistics of a raw device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ids</td><td>The id numbers of the stats to get. The ids can be got from the stat position in the stat list from rte_rawdev_get_xstats_names(), or by using rte_rawdev_get_xstats_by_name() </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The values for each stats request by ID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>The number of stats requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value: number of stat entries filled into the values array</li>
<li>negative value on error: -ENODEV for invalid <em>dev_id</em> -ENOTSUP if the device doesn't support this function. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a9">examples/ioat/ioatfwd.c</a>, and <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a44">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a36dd705b822ad2193fe25244e8eb1d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dd705b822ad2193fe25244e8eb1d63">&#9670;&nbsp;</a></span>rte_rawdev_xstats_by_name_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t rte_rawdev_xstats_by_name_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the value of a single stat by requesting it by name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The stat name to retrieve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>If non-NULL, the numerical id of the stat will be returned, so that further requests for the stat can be got using rte_rawdev_xstats_get, which will be faster as it doesn't need to scan a list of names for the stat. If the stat cannot be found, the id returned will be (unsigned)-1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>positive value or zero: the stat value</li>
<li>negative value: -EINVAL if stat not found, -ENOTSUP if not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a30147de390b2761c57c33ea52b503983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30147de390b2761c57c33ea52b503983">&#9670;&nbsp;</a></span>rte_rawdev_xstats_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_xstats_reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ids</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nb_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the values of the xstats of the selected component in the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
    <tr><td class="paramname">ids</td><td>Selects specific statistics to be reset. When NULL, all statistics will be reset. If non-NULL, must point to array of at least <em>nb_ids</em> size. </td></tr>
    <tr><td class="paramname">nb_ids</td><td>The number of ids available from the <em>ids</em> array. Ignored when ids is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>zero: successfully reset the statistics to zero</li>
<li>negative value: -EINVAL invalid parameters, -ENOTSUP if not supported. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a39">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a74f5e1bf7b75cfdc565e2f08373a7aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f5e1bf7b75cfdc565e2f08373a7aad">&#9670;&nbsp;</a></span>rte_rawdev_firmware_status_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_firmware_status_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_rawdev_obj_t&#160;</td>
          <td class="paramname"><em>status_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Firmware status of the device.. Returns a memory allocated by driver/implementation containing status information block. It is responsibility of caller to release the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifier </td></tr>
    <tr><td class="paramname">status_info</td><td>Pointer to status information area. Caller is responsible for releasing the memory associated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, !0 for failure, <code>status_info</code> argument state is undefined </dd></dl>

</div>
</div>
<a id="aa264e1f4d4d14b03d4c94b30c96774bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa264e1f4d4d14b03d4c94b30c96774bd">&#9670;&nbsp;</a></span>rte_rawdev_firmware_version_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_firmware_version_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_rawdev_obj_t&#160;</td>
          <td class="paramname"><em>version_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Firmware version of the device. Returns a memory allocated by driver/implementation containing version information block. It is responsibility of caller to release the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifier </td></tr>
    <tr><td class="paramname">version_info</td><td>Pointer to version information area. Caller is responsible for releasing the memory associated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, !0 for failure, <code>version_info</code> argument state is undefined </dd></dl>

</div>
</div>
<a id="a2d6b2738c496bcf86ccf5e8a06367625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6b2738c496bcf86ccf5e8a06367625">&#9670;&nbsp;</a></span>rte_rawdev_firmware_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_firmware_load </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rte_rawdev_obj_t&#160;</td>
          <td class="paramname"><em>firmware_image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load firmware on the device. TODO: In future, methods like directly flashing from file too can be supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifier </td></tr>
    <tr><td class="paramname">firmware_image</td><td>Pointer to buffer containing image binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for successful load !0 for failure to load the provided image, or image incorrect. </dd></dl>

</div>
</div>
<a id="ad8ef8524e162453524b5cfb827661df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ef8524e162453524b5cfb827661df2">&#9670;&nbsp;</a></span>rte_rawdev_firmware_unload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_firmware_unload </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unload firmware from the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>Raw device identifiers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for successful Unload !0 for failure in unloading </dd></dl>

</div>
</div>
<a id="a776edaa7060fc6a9d66e00f84132e140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776edaa7060fc6a9d66e00f84132e140">&#9670;&nbsp;</a></span>rte_rawdev_selftest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rawdev_selftest </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trigger the rawdev self test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_id</td><td>The identifier of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Selftest successful</li>
<li>-ENOTSUP if the device doesn't support selftest</li>
<li>other values &lt; 0 on failure. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
