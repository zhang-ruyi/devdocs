<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_efd/rte_efd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_5dafd97c0d945e0ac41aa1317e88fadc.html">librte_efd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_efd.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="rte__efd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a18b2061d68fcef1c227976180b03d405"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#a18b2061d68fcef1c227976180b03d405">RTE_EFD_VALUE_NUM_BITS</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="separator:a18b2061d68fcef1c227976180b03d405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55598926ba76e0b92197bea26aef12bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#a55598926ba76e0b92197bea26aef12bf">RTE_EFD_BURST_MAX</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="separator:a55598926ba76e0b92197bea26aef12bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20168225a151f0ec353b9f5897241dc5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#a20168225a151f0ec353b9f5897241dc5">RTE_EFD_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a20168225a151f0ec353b9f5897241dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9a2f3dbbb0a47ddc7c2e6beda075f520"><td class="memItemLeft" align="right" valign="top">struct rte_efd_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#a9a2f3dbbb0a47ddc7c2e6beda075f520">rte_efd_create</a> (const char *name, uint32_t max_num_rules, uint32_t key_len, uint8_t online_cpu_socket_bitmask, uint8_t offline_cpu_socket)</td></tr>
<tr class="separator:a9a2f3dbbb0a47ddc7c2e6beda075f520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d25b74d30928848bdd05218ea2fd3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#a9d25b74d30928848bdd05218ea2fd3f8">rte_efd_free</a> (struct rte_efd_table *table)</td></tr>
<tr class="separator:a9d25b74d30928848bdd05218ea2fd3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80106a9376e77552a86505bbf5afc3a2"><td class="memItemLeft" align="right" valign="top">struct rte_efd_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#a80106a9376e77552a86505bbf5afc3a2">rte_efd_find_existing</a> (const char *name)</td></tr>
<tr class="separator:a80106a9376e77552a86505bbf5afc3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51c6724a8c0efca349da307029cd8a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#ab51c6724a8c0efca349da307029cd8a8">rte_efd_update</a> (struct rte_efd_table *table, unsigned int socket_id, const void *key, efd_value_t value)</td></tr>
<tr class="separator:ab51c6724a8c0efca349da307029cd8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6547c1d7f5d48c9e24a96412b80acae9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#a6547c1d7f5d48c9e24a96412b80acae9">rte_efd_delete</a> (struct rte_efd_table *table, unsigned int socket_id, const void *key, efd_value_t *prev_value)</td></tr>
<tr class="separator:a6547c1d7f5d48c9e24a96412b80acae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0c39fb8930781bc2418233e7e33635"><td class="memItemLeft" align="right" valign="top">efd_value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#acd0c39fb8930781bc2418233e7e33635">rte_efd_lookup</a> (const struct rte_efd_table *table, unsigned int socket_id, const void *key)</td></tr>
<tr class="separator:acd0c39fb8930781bc2418233e7e33635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a00b79d1d38d51e899931254cdab23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__efd_8h.html#a41a00b79d1d38d51e899931254cdab23">rte_efd_lookup_bulk</a> (const struct rte_efd_table *table, unsigned int socket_id, int num_keys, const void **key_list, efd_value_t *value_list)</td></tr>
<tr class="separator:a41a00b79d1d38d51e899931254cdab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE EFD Table </p>

<p class="definition">Definition in file <a class="el" href="rte__efd_8h_source.html">rte_efd.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a18b2061d68fcef1c227976180b03d405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b2061d68fcef1c227976180b03d405">&#9670;&nbsp;</a></span>RTE_EFD_VALUE_NUM_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EFD_VALUE_NUM_BITS&#160;&#160;&#160;(8)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>!!! This parameter should be adjusted for your application !!!</p>
<p>This parameter adjusts the number of bits of value that can be stored in the table. For example, setting the number of bits to 3 will allow storing 8 values in the table (between 0 and 7).</p>
<p>This number directly affects the performance of both lookups and insertion. In general, performance decreases as more bits are stored in the table.</p>
<p>This number is directly proportional to the size of the online region used for lookups.</p>
<p>Note that due to the way the CPU operates on memory, best lookup performance will be achieved when RTE_EFD_VALUE_NUM_BITS is a multiple of 8. These values align the hash indexes on 16-byte boundaries. The greatest performance drop is moving from 8-&gt;9 bits, 16-&gt;17 bits, etc.</p>
<p>This value must be between 1 and 32 </p>

<p class="definition">Definition at line <a class="el" href="rte__efd_8h_source.html#l00065">65</a> of file <a class="el" href="rte__efd_8h_source.html">rte_efd.h</a>.</p>

</div>
</div>
<a id="a55598926ba76e0b92197bea26aef12bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55598926ba76e0b92197bea26aef12bf">&#9670;&nbsp;</a></span>RTE_EFD_BURST_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EFD_BURST_MAX&#160;&#160;&#160;(32)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of keys that can be looked up in one call to efd_lookup_bulk </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2server_node_efd_2server_2main_8c-example.html#a11">examples/server_node_efd/server/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__efd_8h_source.html#l00099">99</a> of file <a class="el" href="rte__efd_8h_source.html">rte_efd.h</a>.</p>

</div>
</div>
<a id="a20168225a151f0ec353b9f5897241dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20168225a151f0ec353b9f5897241dc5">&#9670;&nbsp;</a></span>RTE_EFD_NAMESIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_EFD_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of characters in efd name. </p>

<p class="definition">Definition at line <a class="el" href="rte__efd_8h_source.html#l00103">103</a> of file <a class="el" href="rte__efd_8h_source.html">rte_efd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9a2f3dbbb0a47ddc7c2e6beda075f520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2f3dbbb0a47ddc7c2e6beda075f520">&#9670;&nbsp;</a></span>rte_efd_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_efd_table* rte_efd_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_num_rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>online_cpu_socket_bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offline_cpu_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an EFD table with a single offline region and multiple per-socket internally-managed copies of the online table used for lookups</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>EFD table name </td></tr>
    <tr><td class="paramname">max_num_rules</td><td>Minimum number of rules the table should be sized to hold. Will be rounded up to the next smallest valid table size </td></tr>
    <tr><td class="paramname">key_len</td><td>Length of the key </td></tr>
    <tr><td class="paramname">online_cpu_socket_bitmask</td><td>Bitmask specifying which sockets should get a copy of the online table. LSB = socket 0, etc. </td></tr>
    <tr><td class="paramname">offline_cpu_socket</td><td>Identifies the socket where the offline table will be allocated (and most efficiently accessed in the case of updates/insertions)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EFD table, or NULL if table allocation failed or the bitmask is invalid </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2server_node_efd_2server_2init_8c-example.html#a25">examples/server_node_efd/server/init.c</a>.</dd>
</dl>

</div>
</div>
<a id="a9d25b74d30928848bdd05218ea2fd3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d25b74d30928848bdd05218ea2fd3f8">&#9670;&nbsp;</a></span>rte_efd_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_efd_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_efd_table *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the resources from an EFD table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80106a9376e77552a86505bbf5afc3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80106a9376e77552a86505bbf5afc3a2">&#9670;&nbsp;</a></span>rte_efd_find_existing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_efd_table* rte_efd_find_existing </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an existing EFD table object and return a pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the EFD table as passed to <a class="el" href="rte__efd_8h.html#a9a2f3dbbb0a47ddc7c2e6beda075f520">rte_efd_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to EFD table or NULL if object not found with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - value not available for return </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab51c6724a8c0efca349da307029cd8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51c6724a8c0efca349da307029cd8a8">&#9670;&nbsp;</a></span>rte_efd_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_efd_update </td>
          <td>(</td>
          <td class="paramtype">struct rte_efd_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">efd_value_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes an updated table entry for the supplied key/value pair. The update is then immediately applied to the provided table and all socket-local copies of the chunks are updated. This operation is not multi-thread safe and should only be called one from thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>EFD table to reference </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to use to lookup existing value (ideally caller's socket id) </td></tr>
    <tr><td class="paramname">key</td><td>EFD table key to modify </td></tr>
    <tr><td class="paramname">value</td><td>Value to associate with the key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTE_EFD_UPDATE_WARN_GROUP_FULL Operation is insert, and the last available space in the key's group was just used Future inserts may fail as groups fill up This operation was still successful, and entry contains a valid update RTE_EFD_UPDATE_FAILED Either the EFD failed to find a suitable perfect hash or the group was full This is a fatal error, and the table is now in an indeterminate state RTE_EFD_UPDATE_NO_CHANGE Operation resulted in no change to the table (same value already exists) 0 - success </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2server_node_efd_2server_2init_8c-example.html#a27">examples/server_node_efd/server/init.c</a>.</dd>
</dl>

</div>
</div>
<a id="a6547c1d7f5d48c9e24a96412b80acae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6547c1d7f5d48c9e24a96412b80acae9">&#9670;&nbsp;</a></span>rte_efd_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_efd_delete </td>
          <td>(</td>
          <td class="paramtype">struct rte_efd_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">efd_value_t *&#160;</td>
          <td class="paramname"><em>prev_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes any value currently associated with the specified key from the table This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>EFD table to reference </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to use to lookup existing value (ideally caller's socket id) </td></tr>
    <tr><td class="paramname">key</td><td>EFD table key to delete </td></tr>
    <tr><td class="paramname">prev_value</td><td>If not NULL, will store the previous value here before deleting it</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 - successfully found and deleted the key nonzero otherwise </dd></dl>

</div>
</div>
<a id="acd0c39fb8930781bc2418233e7e33635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0c39fb8930781bc2418233e7e33635">&#9670;&nbsp;</a></span>rte_efd_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">efd_value_t rte_efd_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct rte_efd_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the value associated with a key This operation is multi-thread safe.</p>
<p>NOTE: Lookups will <em>always</em> succeed - this is a property of using a perfect hash table. If the specified key was never inserted, a pseudorandom answer will be returned. There is no way to know based on the lookup if the key was ever inserted originally, so this must be tracked elsewhere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>EFD table to reference </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to use to lookup existing value (ideally caller's socket id) </td></tr>
    <tr><td class="paramname">key</td><td>EFD table key to look up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value associated with the key, or random junk if they key was never inserted </dd></dl>

</div>
</div>
<a id="a41a00b79d1d38d51e899931254cdab23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a00b79d1d38d51e899931254cdab23">&#9670;&nbsp;</a></span>rte_efd_lookup_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_efd_lookup_bulk </td>
          <td>(</td>
          <td class="paramtype">const struct rte_efd_table *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>key_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">efd_value_t *&#160;</td>
          <td class="paramname"><em>value_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the value associated with several keys. This operation is multi-thread safe.</p>
<p>NOTE: Lookups will <em>always</em> succeed - this is a property of using a perfect hash table. If the specified key was never inserted, a pseudorandom answer will be returned. There is no way to know based on the lookup if the key was ever inserted originally, so this must be tracked elsewhere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>EFD table to reference </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to use to lookup existing value (ideally caller's socket id) </td></tr>
    <tr><td class="paramname">num_keys</td><td>Number of keys in the key_list array, must be less than RTE_EFD_BURST_MAX </td></tr>
    <tr><td class="paramname">key_list</td><td>Array of num_keys pointers which point to keys to look up </td></tr>
    <tr><td class="paramname">value_list</td><td>Array of size num_keys where lookup values will be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2server_node_efd_2server_2main_8c-example.html#a16">examples/server_node_efd/server/main.c</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
