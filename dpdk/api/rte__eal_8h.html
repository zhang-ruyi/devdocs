<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_eal/include/rte_eal.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_605c07ae6e02b3d13cc3bf92b6c5e54b.html">librte_eal</a></li><li class="navelem"><a class="el" href="dir_53ac78163efee0ea92d7cd5087265064.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_eal.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sched.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;rte_config.h&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__per__lcore_8h_source.html">rte_per_lcore.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__bus_8h_source.html">rte_bus.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__uuid_8h_source.html">rte_uuid.h</a>&gt;</code><br />
<code>#include &lt;rte_pci_dev_feature_defs.h&gt;</code><br />
</div>
<p><a href="rte__eal_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abe2896839491e28d44eb8a0df9dc1c08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#abe2896839491e28d44eb8a0df9dc1c08">RTE_MAGIC</a>&#160;&#160;&#160;19820526</td></tr>
<tr class="separator:abe2896839491e28d44eb8a0df9dc1c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a555fbaac62334805a9af3ba880335cbd"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a555fbaac62334805a9af3ba880335cbd">rte_mp_t</a>) (const struct rte_mp_msg *msg, const void *peer)</td></tr>
<tr class="separator:a555fbaac62334805a9af3ba880335cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bf6c3897cba78d8617bd051d53dba2"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a54bf6c3897cba78d8617bd051d53dba2">rte_mp_async_reply_t</a>) (const struct rte_mp_msg *request, const struct <a class="el" href="rte__eal_8h.html#a8227db7e6dba2f5eae1ba13e3b53c1f9">rte_mp_reply</a> *reply)</td></tr>
<tr class="separator:a54bf6c3897cba78d8617bd051d53dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12c86653412b81c9dddd18cb35843dc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#aa12c86653412b81c9dddd18cb35843dc">rte_usage_hook_t</a>) (const char *prgname)</td></tr>
<tr class="separator:aa12c86653412b81c9dddd18cb35843dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1c1b5d8e30606d1b95f36413c2294d49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a1c1b5d8e30606d1b95f36413c2294d49">rte_proc_type_t</a> </td></tr>
<tr class="separator:a1c1b5d8e30606d1b95f36413c2294d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1280c4f5e0f2082163ecb1f30a968cd9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="rte__eal_8h.html#a1c1b5d8e30606d1b95f36413c2294d49">rte_proc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a1280c4f5e0f2082163ecb1f30a968cd9">rte_eal_process_type</a> (void)</td></tr>
<tr class="separator:a1280c4f5e0f2082163ecb1f30a968cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaaaa5e80f273e15e543b34d62210e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#abdaaaa5e80f273e15e543b34d62210e1">rte_eal_iopl_init</a> (void)</td></tr>
<tr class="separator:abdaaaa5e80f273e15e543b34d62210e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f4dddc25e38c5a186ecd8a69260e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a5c3f4dddc25e38c5a186ecd8a69260e3">rte_eal_init</a> (int argc, char **argv)</td></tr>
<tr class="separator:a5c3f4dddc25e38c5a186ecd8a69260e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a745887f62a82dc83f1524e2ff2a236"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a7a745887f62a82dc83f1524e2ff2a236">rte_eal_cleanup</a> (void)</td></tr>
<tr class="separator:a7a745887f62a82dc83f1524e2ff2a236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25c73ba5b2d220185b612bced32094e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#ab25c73ba5b2d220185b612bced32094e">rte_eal_primary_proc_alive</a> (const char *config_file_path)</td></tr>
<tr class="separator:ab25c73ba5b2d220185b612bced32094e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fddde2042fe0909f625186f2f740af5"><td class="memItemLeft" align="right" valign="top">__rte_experimental bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a6fddde2042fe0909f625186f2f740af5">rte_mp_disable</a> (void)</td></tr>
<tr class="separator:a6fddde2042fe0909f625186f2f740af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0e91ff8994f4ddce209cbec0ee88a9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a9a0e91ff8994f4ddce209cbec0ee88a9">rte_mp_action_register</a> (const char *name, <a class="el" href="rte__eal_8h.html#a555fbaac62334805a9af3ba880335cbd">rte_mp_t</a> action)</td></tr>
<tr class="separator:a9a0e91ff8994f4ddce209cbec0ee88a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e205ed2b3ab467e83216b7d61a25e7"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a61e205ed2b3ab467e83216b7d61a25e7">rte_mp_action_unregister</a> (const char *name)</td></tr>
<tr class="separator:a61e205ed2b3ab467e83216b7d61a25e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9848787b1db7ddd64fb17dc43f3518"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#aff9848787b1db7ddd64fb17dc43f3518">rte_mp_sendmsg</a> (struct rte_mp_msg *msg)</td></tr>
<tr class="separator:aff9848787b1db7ddd64fb17dc43f3518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8d61bd741edb3a41c964935effd3d4"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a4f8d61bd741edb3a41c964935effd3d4">rte_mp_request_sync</a> (struct rte_mp_msg *req, struct <a class="el" href="rte__eal_8h.html#a8227db7e6dba2f5eae1ba13e3b53c1f9">rte_mp_reply</a> *reply, const struct timespec *ts)</td></tr>
<tr class="separator:a4f8d61bd741edb3a41c964935effd3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aeaf5a3b96c9bddb6f939b13e540eb8"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a9aeaf5a3b96c9bddb6f939b13e540eb8">rte_mp_request_async</a> (struct rte_mp_msg *req, const struct timespec *ts, <a class="el" href="rte__eal_8h.html#a54bf6c3897cba78d8617bd051d53dba2">rte_mp_async_reply_t</a> clb)</td></tr>
<tr class="separator:a9aeaf5a3b96c9bddb6f939b13e540eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8227db7e6dba2f5eae1ba13e3b53c1f9"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a8227db7e6dba2f5eae1ba13e3b53c1f9">rte_mp_reply</a> (struct rte_mp_msg *msg, const char *peer)</td></tr>
<tr class="separator:a8227db7e6dba2f5eae1ba13e3b53c1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d22d05e85724b51dd613de4e65f7224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__eal_8h.html#aa12c86653412b81c9dddd18cb35843dc">rte_usage_hook_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a2d22d05e85724b51dd613de4e65f7224">rte_set_application_usage_hook</a> (<a class="el" href="rte__eal_8h.html#aa12c86653412b81c9dddd18cb35843dc">rte_usage_hook_t</a> usage_func)</td></tr>
<tr class="separator:a2d22d05e85724b51dd613de4e65f7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb64f55be76d441d5a74b814c88901ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#adb64f55be76d441d5a74b814c88901ce">rte_eal_has_hugepages</a> (void)</td></tr>
<tr class="separator:adb64f55be76d441d5a74b814c88901ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fee79b0f1004c8fa2cb69e38db55915"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a3fee79b0f1004c8fa2cb69e38db55915">rte_eal_has_pci</a> (void)</td></tr>
<tr class="separator:a3fee79b0f1004c8fa2cb69e38db55915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de60abfc9a89cc1d93c19a3b9c9e9d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a7de60abfc9a89cc1d93c19a3b9c9e9d0">rte_eal_create_uio_dev</a> (void)</td></tr>
<tr class="separator:a7de60abfc9a89cc1d93c19a3b9c9e9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189363c6224e2fa7e6aef23f3c4c6655"><td class="memItemLeft" align="right" valign="top">enum rte_intr_mode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a189363c6224e2fa7e6aef23f3c4c6655">rte_eal_vfio_intr_mode</a> (void)</td></tr>
<tr class="separator:a189363c6224e2fa7e6aef23f3c4c6655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec4e14852581c59b1c64fa979db44ed"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#acec4e14852581c59b1c64fa979db44ed">rte_eal_vfio_get_vf_token</a> (<a class="el" href="rte__uuid_8h.html#a71e32803dea320dc560b1e5e2e9bf73f">rte_uuid_t</a> vf_token)</td></tr>
<tr class="separator:acec4e14852581c59b1c64fa979db44ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29dcb88e6255d122d6ba899d1ffd9f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#ae29dcb88e6255d122d6ba899d1ffd9f0">rte_sys_gettid</a> (void)</td></tr>
<tr class="separator:ae29dcb88e6255d122d6ba899d1ffd9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537d061d8ca3204f536f96b25e7b28e0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a537d061d8ca3204f536f96b25e7b28e0">rte_gettid</a> (void)</td></tr>
<tr class="separator:a537d061d8ca3204f536f96b25e7b28e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1ff16a6096013452673ea31ea16aa8"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="rte__bus_8h.html#a4e9ce018f823fab1634e630143fcdc4a">rte_iova_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a1e1ff16a6096013452673ea31ea16aa8">rte_eal_iova_mode</a> (void)</td></tr>
<tr class="separator:a1e1ff16a6096013452673ea31ea16aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7656b99bbfdf3ec42cf723c265798f75"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a7656b99bbfdf3ec42cf723c265798f75">rte_eal_mbuf_user_pool_ops</a> (void)</td></tr>
<tr class="separator:a7656b99bbfdf3ec42cf723c265798f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adc6f0cfa61a307b7c82d6920ca3933"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__eal_8h.html#a8adc6f0cfa61a307b7c82d6920ca3933">rte_eal_get_runtime_dir</a> (void)</td></tr>
<tr class="separator:a8adc6f0cfa61a307b7c82d6920ca3933"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>EAL Configuration API </p>

<p class="definition">Definition in file <a class="el" href="rte__eal_8h_source.html">rte_eal.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="abe2896839491e28d44eb8a0df9dc1c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2896839491e28d44eb8a0df9dc1c08">&#9670;&nbsp;</a></span>RTE_MAGIC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MAGIC&#160;&#160;&#160;19820526</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Magic number written by the main partition when ready. </p>

<p class="definition">Definition at line <a class="el" href="rte__eal_8h_source.html#l00030">30</a> of file <a class="el" href="rte__eal_8h_source.html">rte_eal.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a555fbaac62334805a9af3ba880335cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555fbaac62334805a9af3ba880335cbd">&#9670;&nbsp;</a></span>rte_mp_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mp_t) (const struct rte_mp_msg *msg, const void *peer)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Action function typedef used by other components.</p>
<p>As we create socket channel for primary/secondary communication, use this function typedef to register action for coming messages.</p>
<dl class="section note"><dt>Note</dt><dd>When handling IPC request callbacks, the reply must be sent even in cases of error handling. Simply returning success or failure will <em>not</em> send a response to the requestor. Implementation of error signalling mechanism is up to the application.</dd>
<dd>
No memory allocations should take place inside the callback. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eal_8h_source.html#l00192">192</a> of file <a class="el" href="rte__eal_8h_source.html">rte_eal.h</a>.</p>

</div>
</div>
<a id="a54bf6c3897cba78d8617bd051d53dba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bf6c3897cba78d8617bd051d53dba2">&#9670;&nbsp;</a></span>rte_mp_async_reply_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mp_async_reply_t) (const struct rte_mp_msg *request, const struct <a class="el" href="rte__eal_8h.html#a8227db7e6dba2f5eae1ba13e3b53c1f9">rte_mp_reply</a> *reply)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronous reply function typedef used by other components.</p>
<p>As we create socket channel for primary/secondary communication, use this function typedef to register action for coming responses to asynchronous requests.</p>
<dl class="section note"><dt>Note</dt><dd>When handling IPC request callbacks, the reply must be sent even in cases of error handling. Simply returning success or failure will <em>not</em> send a response to the requestor. Implementation of error signalling mechanism is up to the application.</dd>
<dd>
No memory allocations should take place inside the callback. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eal_8h_source.html#l00208">208</a> of file <a class="el" href="rte__eal_8h_source.html">rte_eal.h</a>.</p>

</div>
</div>
<a id="aa12c86653412b81c9dddd18cb35843dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12c86653412b81c9dddd18cb35843dc">&#9670;&nbsp;</a></span>rte_usage_hook_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_usage_hook_t) (const char *prgname)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usage function typedef used by the application usage function.</p>
<p>Use this function typedef to define and call <a class="el" href="rte__eal_8h.html#a2d22d05e85724b51dd613de4e65f7224">rte_set_application_usage_hook()</a> routine. </p>

<p class="definition">Definition at line <a class="el" href="rte__eal_8h_source.html#l00379">379</a> of file <a class="el" href="rte__eal_8h_source.html">rte_eal.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1c1b5d8e30606d1b95f36413c2294d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1b5d8e30606d1b95f36413c2294d49">&#9670;&nbsp;</a></span>rte_proc_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__eal_8h.html#a1c1b5d8e30606d1b95f36413c2294d49">rte_proc_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of process in a linux, multi-process setup </p>

<p class="definition">Definition at line <a class="el" href="rte__eal_8h_source.html#l00038">38</a> of file <a class="el" href="rte__eal_8h_source.html">rte_eal.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1280c4f5e0f2082163ecb1f30a968cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1280c4f5e0f2082163ecb1f30a968cd9">&#9670;&nbsp;</a></span>rte_eal_process_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__eal_8h.html#a1c1b5d8e30606d1b95f36413c2294d49">rte_proc_type_t</a> rte_eal_process_type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the process type in a multi-process setup</p>
<dl class="section return"><dt>Returns</dt><dd>The process type </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2multi_process_2simple_mp_2main_8c-example.html#a9">examples/multi_process/simple_mp/main.c</a>, and <a class="el" href="examples_2multi_process_2symmetric_mp_2main_8c-example.html#a1">examples/multi_process/symmetric_mp/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="abdaaaa5e80f273e15e543b34d62210e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdaaaa5e80f273e15e543b34d62210e1">&#9670;&nbsp;</a></span>rte_eal_iopl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eal_iopl_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request iopl privilege for all RPL.</p>
<p>This function should be called by pmds which need access to ioports.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, returns 0.</li>
<li>On failure, returns -1. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5c3f4dddc25e38c5a186ecd8a69260e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3f4dddc25e38c5a186ecd8a69260e3">&#9670;&nbsp;</a></span>rte_eal_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eal_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the Environment Abstraction Layer (EAL).</p>
<p>This function is to be executed on the MAIN lcore only, as soon as possible in the application's main() function. It puts the WORKER lcores in the WAIT state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>A non-negative value. If it is greater than 0, the array members for argv[0] through argv[argc] (non-inclusive) shall contain pointers to strings. </td></tr>
    <tr><td class="paramname">argv</td><td>An array of strings. The contents of the array, as well as the strings which are pointed to by the array, may be modified by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, the number of parsed arguments, which is greater or equal to zero. After the call to <a class="el" href="rte__eal_8h.html#a5c3f4dddc25e38c5a186ecd8a69260e3">rte_eal_init()</a>, all arguments argv[x] with x &lt; ret may have been modified by this function call and should not be further interpreted by the application. The EAL does not take any ownership of the memory used for either the argv array, or its members.</li>
<li>On failure, -1 and rte_errno is set to a value indicating the cause for failure. In some instances, the application will need to be restarted as part of clearing the issue.</li>
</ul>
</dd></dl>
<p>Error codes returned via rte_errno: EACCES indicates a permissions issue.</p>
<p>EAGAIN indicates either a bus or system resource was not available, setup may be attempted again.</p>
<p>EALREADY indicates that the rte_eal_init function has already been called, and cannot be called again.</p>
<p>EFAULT indicates the tailq configuration name was not found in memory configuration.</p>
<p>EINVAL indicates invalid parameters were passed as argv/argc.</p>
<p>ENOMEM indicates failure likely caused by an out-of-memory condition.</p>
<p>ENODEV indicates memory setup issues.</p>
<p>ENOTSUP indicates that the EAL cannot initialize on this system.</p>
<p>EPROTO indicates that the PCI bus is either not present, or is not readable by the eal.</p>
<p>ENOEXEC indicates that a service core failed to launch successfully. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a110">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2bond_2main_8c-example.html#a83">examples/bond/main.c</a>, <a class="el" href="examples_2cmdline_2main_8c-example.html#a0">examples/cmdline/main.c</a>, <a class="el" href="examples_2distributor_2main_8c-example.html#a61">examples/distributor/main.c</a>, <a class="el" href="examples_2ethtool_2ethtool-app_2main_8c-example.html#a32">examples/ethtool/ethtool-app/main.c</a>, <a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a17">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2fips_validation_2main_8c-example.html#a34">examples/fips_validation/main.c</a>, <a class="el" href="examples_2flow_classify_2flow_classify_8c-example.html#a81">examples/flow_classify/flow_classify.c</a>, <a class="el" href="examples_2flow_filtering_2main_8c-example.html#a38">examples/flow_filtering/main.c</a>, <a class="el" href="examples_2helloworld_2main_8c-example.html#a2">examples/helloworld/main.c</a>, <a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a87">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2ip_fragmentation_2main_8c-example.html#a82">examples/ip_fragmentation/main.c</a>, <a class="el" href="examples_2ip_pipeline_2main_8c-example.html#a0">examples/ip_pipeline/main.c</a>, <a class="el" href="examples_2ip_reassembly_2main_8c-example.html#a82">examples/ip_reassembly/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a196">examples/ipsec-secgw/ipsec-secgw.c</a>, <a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a63">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2kni_2main_8c-example.html#a66">examples/kni/main.c</a>, <a class="el" href="examples_2l2fwd-cat_2l2fwd-cat_8c-example.html#a25">examples/l2fwd-cat/l2fwd-cat.c</a>, <a class="el" href="examples_2l2fwd-crypto_2main_8c-example.html#a145">examples/l2fwd-crypto/main.c</a>, <a class="el" href="examples_2l2fwd-event_2main_8c-example.html#a20">examples/l2fwd-event/main.c</a>, <a class="el" href="examples_2l2fwd-jobstats_2main_8c-example.html#a44">examples/l2fwd-jobstats/main.c</a>, <a class="el" href="examples_2l2fwd-keepalive_2main_8c-example.html#a39">examples/l2fwd-keepalive/main.c</a>, <a class="el" href="examples_2l2fwd_2main_8c-example.html#a36">examples/l2fwd/main.c</a>, <a class="el" href="examples_2l3fwd-acl_2main_8c-example.html#a94">examples/l3fwd-acl/main.c</a>, <a class="el" href="examples_2l3fwd-graph_2main_8c-example.html#a48">examples/l3fwd-graph/main.c</a>, <a class="el" href="examples_2l3fwd-power_2main_8c-example.html#a142">examples/l3fwd-power/main.c</a>, <a class="el" href="examples_2l3fwd_2main_8c-example.html#a64">examples/l3fwd/main.c</a>, <a class="el" href="examples_2link_status_interrupt_2main_8c-example.html#a36">examples/link_status_interrupt/main.c</a>, <a class="el" href="examples_2multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a14">examples/multi_process/client_server_mp/mp_client/client.c</a>, <a class="el" href="examples_2multi_process_2client_server_mp_2mp_server_2init_8c-example.html#a27">examples/multi_process/client_server_mp/mp_server/init.c</a>, <a class="el" href="examples_2multi_process_2hotplug_mp_2main_8c-example.html#a0">examples/multi_process/hotplug_mp/main.c</a>, <a class="el" href="examples_2multi_process_2simple_mp_2main_8c-example.html#a7">examples/multi_process/simple_mp/main.c</a>, <a class="el" href="examples_2multi_process_2symmetric_mp_2main_8c-example.html#a43">examples/multi_process/symmetric_mp/main.c</a>, <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a73">examples/ntb/ntb_fwd.c</a>, <a class="el" href="examples_2packet_ordering_2main_8c-example.html#a51">examples/packet_ordering/main.c</a>, <a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a116">examples/performance-thread/l3fwd-thread/main.c</a>, <a class="el" href="examples_2performance-thread_2pthread_shim_2main_8c-example.html#a3">examples/performance-thread/pthread_shim/main.c</a>, <a class="el" href="examples_2pipeline_2main_8c-example.html#a0">examples/pipeline/main.c</a>, <a class="el" href="examples_2ptpclient_2ptpclient_8c-example.html#a54">examples/ptpclient/ptpclient.c</a>, <a class="el" href="examples_2qos_meter_2main_8c-example.html#a29">examples/qos_meter/main.c</a>, <a class="el" href="examples_2qos_sched_2args_8c-example.html#a4">examples/qos_sched/args.c</a>, <a class="el" href="examples_2rxtx_callbacks_2main_8c-example.html#a46">examples/rxtx_callbacks/main.c</a>, <a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a31">examples/server_node_efd/node/node.c</a>, <a class="el" href="examples_2server_node_efd_2server_2init_8c-example.html#a36">examples/server_node_efd/server/init.c</a>, <a class="el" href="examples_2service_cores_2main_8c-example.html#a10">examples/service_cores/main.c</a>, <a class="el" href="examples_2skeleton_2basicfwd_8c-example.html#a31">examples/skeleton/basicfwd.c</a>, <a class="el" href="examples_2timer_2main_8c-example.html#a10">examples/timer/main.c</a>, <a class="el" href="examples_2vdpa_2main_8c-example.html#a29">examples/vdpa/main.c</a>, <a class="el" href="examples_2vhost_2main_8c-example.html#a107">examples/vhost/main.c</a>, <a class="el" href="examples_2vhost_blk_2vhost_blk_8c-example.html#a25">examples/vhost_blk/vhost_blk.c</a>, <a class="el" href="examples_2vhost_crypto_2main_8c-example.html#a24">examples/vhost_crypto/main.c</a>, <a class="el" href="examples_2vm_power_manager_2guest_cli_2main_8c-example.html#a2">examples/vm_power_manager/guest_cli/main.c</a>, <a class="el" href="examples_2vm_power_manager_2main_8c-example.html#a30">examples/vm_power_manager/main.c</a>, <a class="el" href="examples_2vmdq_2main_8c-example.html#a51">examples/vmdq/main.c</a>, and <a class="el" href="examples_2vmdq_dcb_2main_8c-example.html#a59">examples/vmdq_dcb/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a7a745887f62a82dc83f1524e2ff2a236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a745887f62a82dc83f1524e2ff2a236">&#9670;&nbsp;</a></span>rte_eal_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eal_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up the Environment Abstraction Layer (EAL)</p>
<p>This function must be called to release any internal resources that EAL has allocated during <a class="el" href="rte__eal_8h.html#a5c3f4dddc25e38c5a186ecd8a69260e3">rte_eal_init()</a>. After this call, no DPDK function calls may be made. It is expected that common usage of this function is to call it just before terminating the process.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 Successfully released all internal EAL resources.</li>
<li>-EFAULT There was an error in releasing all resources. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2eventdev_pipeline_2main_8c-example.html#a31">examples/eventdev_pipeline/main.c</a>, <a class="el" href="examples_2l3fwd-power_2main_8c-example.html#a180">examples/l3fwd-power/main.c</a>, and <a class="el" href="examples_2multi_process_2hotplug_mp_2main_8c-example.html#a2">examples/multi_process/hotplug_mp/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="ab25c73ba5b2d220185b612bced32094e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25c73ba5b2d220185b612bced32094e">&#9670;&nbsp;</a></span>rte_eal_primary_proc_alive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eal_primary_proc_alive </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>config_file_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a primary process is currently alive</p>
<p>This function returns true when a primary process is currently active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_file_path</td><td>The config_file_path argument provided should point at the location that the primary process will create its config file. If NULL, the default config file path is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>If alive, returns 1.</li>
<li>If dead, returns 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6fddde2042fe0909f625186f2f740af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fddde2042fe0909f625186f2f740af5">&#9670;&nbsp;</a></span>rte_mp_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental bool rte_mp_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable multiprocess.</p>
<p>This function can be called to indicate that multiprocess won't be used for the rest of the application life.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>true if called from a primary process that had no secondary processes attached,</li>
<li>false, otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9a0e91ff8994f4ddce209cbec0ee88a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0e91ff8994f4ddce209cbec0ee88a9">&#9670;&nbsp;</a></span>rte_mp_action_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mp_action_register </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__eal_8h.html#a555fbaac62334805a9af3ba880335cbd">rte_mp_t</a>&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Register an action function for primary/secondary communication.</p>
<p>Call this function to register an action, if the calling component wants to response the messages from the corresponding component in its primary process or secondary processes.</p>
<dl class="section note"><dt>Note</dt><dd>IPC may be unsupported in certain circumstances, so caller should check for ENOTSUP error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name argument plays as the nonredundant key to find the action.</td></tr>
    <tr><td class="paramname">action</td><td>The action argument is the function pointer to the action function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 on success.</li>
<li>(&lt;0) on failure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a61e205ed2b3ab467e83216b7d61a25e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e205ed2b3ab467e83216b7d61a25e7">&#9670;&nbsp;</a></span>rte_mp_action_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_mp_action_unregister </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Unregister an action function for primary/secondary communication.</p>
<p>Call this function to unregister an action if the calling component does not want to response the messages from the corresponding component in its primary process or secondary processes.</p>
<dl class="section note"><dt>Note</dt><dd>IPC may be unsupported in certain circumstances, so caller should check for ENOTSUP error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name argument plays as the nonredundant key to find the action. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff9848787b1db7ddd64fb17dc43f3518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9848787b1db7ddd64fb17dc43f3518">&#9670;&nbsp;</a></span>rte_mp_sendmsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mp_sendmsg </td>
          <td>(</td>
          <td class="paramtype">struct rte_mp_msg *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Send a message to the peer process.</p>
<p>This function will send a message which will be responded by the action identified by name in the peer process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The msg argument contains the customized message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return 0.</li>
<li>On failure, return -1, and the reason will be stored in rte_errno. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4f8d61bd741edb3a41c964935effd3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8d61bd741edb3a41c964935effd3d4">&#9670;&nbsp;</a></span>rte_mp_request_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mp_request_sync </td>
          <td>(</td>
          <td class="paramtype">struct rte_mp_msg *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="rte__eal_8h.html#a8227db7e6dba2f5eae1ba13e3b53c1f9">rte_mp_reply</a> *&#160;</td>
          <td class="paramname"><em>reply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Send a request to the peer process and expect a reply.</p>
<p>This function sends a request message to the peer process, and will block until receiving reply message from the peer process.</p>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible to free reply-&gt;replies.</dd>
<dd>
This API must not be used inside memory-related or IPC callbacks, and no memory allocations should take place inside such callback.</dd>
<dd>
IPC may be unsupported in certain circumstances, so caller should check for ENOTSUP error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The req argument contains the customized request message.</td></tr>
    <tr><td class="paramname">reply</td><td>The reply argument will be for storing all the replied messages; the caller is responsible for free reply-&gt;msgs.</td></tr>
    <tr><td class="paramname">ts</td><td>The ts argument specifies how long we can wait for the peer(s) to reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return 0.</li>
<li>On failure, return -1, and the reason will be stored in rte_errno. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9aeaf5a3b96c9bddb6f939b13e540eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aeaf5a3b96c9bddb6f939b13e540eb8">&#9670;&nbsp;</a></span>rte_mp_request_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mp_request_async </td>
          <td>(</td>
          <td class="paramtype">struct rte_mp_msg *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__eal_8h.html#a54bf6c3897cba78d8617bd051d53dba2">rte_mp_async_reply_t</a>&#160;</td>
          <td class="paramname"><em>clb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Send a request to the peer process and expect a reply in a separate callback.</p>
<p>This function sends a request message to the peer process, and will not block. Instead, reply will be received in a separate callback.</p>
<dl class="section note"><dt>Note</dt><dd>IPC may be unsupported in certain circumstances, so caller should check for ENOTSUP error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The req argument contains the customized request message.</td></tr>
    <tr><td class="paramname">ts</td><td>The ts argument specifies how long we can wait for the peer(s) to reply.</td></tr>
    <tr><td class="paramname">clb</td><td>The callback to trigger when all responses for this request have arrived.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return 0.</li>
<li>On failure, return -1, and the reason will be stored in rte_errno. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8227db7e6dba2f5eae1ba13e3b53c1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8227db7e6dba2f5eae1ba13e3b53c1f9">&#9670;&nbsp;</a></span>rte_mp_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mp_reply </td>
          <td>(</td>
          <td class="paramtype">struct rte_mp_msg *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Send a reply to the peer process.</p>
<p>This function will send a reply message in response to a request message received previously.</p>
<dl class="section note"><dt>Note</dt><dd>When handling IPC request callbacks, the reply must be sent even in cases of error handling. Simply returning success or failure will <em>not</em> send a response to the requestor. Implementation of error signalling mechanism is up to the application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The msg argument contains the customized message.</td></tr>
    <tr><td class="paramname">peer</td><td>The peer argument is the pointer to the peer socket path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return 0.</li>
<li>On failure, return -1, and the reason will be stored in rte_errno. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2d22d05e85724b51dd613de4e65f7224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d22d05e85724b51dd613de4e65f7224">&#9670;&nbsp;</a></span>rte_set_application_usage_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__eal_8h.html#aa12c86653412b81c9dddd18cb35843dc">rte_usage_hook_t</a> rte_set_application_usage_hook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__eal_8h.html#aa12c86653412b81c9dddd18cb35843dc">rte_usage_hook_t</a>&#160;</td>
          <td class="paramname"><em>usage_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add application usage routine callout from the eal_usage() routine.</p>
<p>This function allows the application to include its usage message in the EAL system usage message. The routine <a class="el" href="rte__eal_8h.html#a2d22d05e85724b51dd613de4e65f7224">rte_set_application_usage_hook()</a> needs to be called before the <a class="el" href="rte__eal_8h.html#a5c3f4dddc25e38c5a186ecd8a69260e3">rte_eal_init()</a> routine in the application.</p>
<p>This routine is optional for the application and will behave as if the set routine was never called as the default behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usage_func</td><td>The func argument is a function pointer to the application usage routine. Called function is defined using rte_usage_hook_t typedef, which is of the form void rte_usage_func(const char * prgname).</td></tr>
  </table>
  </dd>
</dl>
<p>Calling this routine with a NULL value will reset the usage hook routine and return the current value, which could be NULL. </p><dl class="section return"><dt>Returns</dt><dd><ul>
<li>Returns the current value of the rte_application_usage pointer to allow the caller to daisy chain the usage routines if needing more then one. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adb64f55be76d441d5a74b814c88901ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb64f55be76d441d5a74b814c88901ce">&#9670;&nbsp;</a></span>rte_eal_has_hugepages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eal_has_hugepages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether EAL is using huge pages (disabled by &ndash;no-huge option). The no-huge mode is not compatible with all drivers or features.</p>
<dl class="section return"><dt>Returns</dt><dd>Nonzero if hugepages are enabled. </dd></dl>

</div>
</div>
<a id="a3fee79b0f1004c8fa2cb69e38db55915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fee79b0f1004c8fa2cb69e38db55915">&#9670;&nbsp;</a></span>rte_eal_has_pci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eal_has_pci </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether EAL is using PCI bus. Disabled by &ndash;no-pci option.</p>
<dl class="section return"><dt>Returns</dt><dd>Nonzero if the PCI bus is enabled. </dd></dl>

</div>
</div>
<a id="a7de60abfc9a89cc1d93c19a3b9c9e9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de60abfc9a89cc1d93c19a3b9c9e9d0">&#9670;&nbsp;</a></span>rte_eal_create_uio_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eal_create_uio_dev </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether the EAL was asked to create UIO device.</p>
<dl class="section return"><dt>Returns</dt><dd>Nonzero if true. </dd></dl>

</div>
</div>
<a id="a189363c6224e2fa7e6aef23f3c4c6655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189363c6224e2fa7e6aef23f3c4c6655">&#9670;&nbsp;</a></span>rte_eal_vfio_intr_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum rte_intr_mode rte_eal_vfio_intr_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user-configured vfio interrupt mode.</p>
<dl class="section return"><dt>Returns</dt><dd>Interrupt mode configured with the command line, RTE_INTR_MODE_NONE by default. </dd></dl>

</div>
</div>
<a id="acec4e14852581c59b1c64fa979db44ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec4e14852581c59b1c64fa979db44ed">&#9670;&nbsp;</a></span>rte_eal_vfio_get_vf_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_eal_vfio_get_vf_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__uuid_8h.html#a71e32803dea320dc560b1e5e2e9bf73f">rte_uuid_t</a>&#160;</td>
          <td class="paramname"><em>vf_token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Copy the user-configured vfio VF token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vf_token</td><td>vfio VF token configured with the command line is copied into this parameter, zero uuid by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae29dcb88e6255d122d6ba899d1ffd9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29dcb88e6255d122d6ba899d1ffd9f0">&#9670;&nbsp;</a></span>rte_sys_gettid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_sys_gettid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrap API for syscall gettid.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the thread ID of calling process. It is always successful. </dd></dl>

</div>
</div>
<a id="a537d061d8ca3204f536f96b25e7b28e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537d061d8ca3204f536f96b25e7b28e0">&#9670;&nbsp;</a></span>rte_gettid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_gettid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get system unique thread id.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns the thread ID of calling process. It is always successful. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__eal_8h_source.html#l00471">471</a> of file <a class="el" href="rte__eal_8h_source.html">rte_eal.h</a>.</p>

</div>
</div>
<a id="a1e1ff16a6096013452673ea31ea16aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1ff16a6096013452673ea31ea16aa8">&#9670;&nbsp;</a></span>rte_eal_iova_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__bus_8h.html#a4e9ce018f823fab1634e630143fcdc4a">rte_iova_mode</a> rte_eal_iova_mode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the iova mode</p>
<dl class="section return"><dt>Returns</dt><dd>enum rte_iova_mode value. </dd></dl>

</div>
</div>
<a id="a7656b99bbfdf3ec42cf723c265798f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7656b99bbfdf3ec42cf723c265798f75">&#9670;&nbsp;</a></span>rte_eal_mbuf_user_pool_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_eal_mbuf_user_pool_ops </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get user provided pool ops name for mbuf</p>
<dl class="section return"><dt>Returns</dt><dd>returns user provided pool ops name. </dd></dl>

</div>
</div>
<a id="a8adc6f0cfa61a307b7c82d6920ca3933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adc6f0cfa61a307b7c82d6920ca3933">&#9670;&nbsp;</a></span>rte_eal_get_runtime_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_eal_get_runtime_dir </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the runtime directory of DPDK</p>
<dl class="section return"><dt>Returns</dt><dd>The runtime directory path of DPDK </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
