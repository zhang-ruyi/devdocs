<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_hash/rte_hash.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_5e14993b9b1571024c777dcdb495ae81.html">librte_hash</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_hash.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>&gt;</code><br />
</div>
<p><a href="rte__hash_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__hash__rcu__config.html">rte_hash_rcu_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a080e28e97cdd08dddfee7fc49084c0f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a080e28e97cdd08dddfee7fc49084c0f4">RTE_HASH_ENTRIES_MAX</a>&#160;&#160;&#160;(1 &lt;&lt; 30)</td></tr>
<tr class="separator:a080e28e97cdd08dddfee7fc49084c0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2eca61b3180fccd47b5170fa115d48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a6f2eca61b3180fccd47b5170fa115d48">RTE_HASH_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a6f2eca61b3180fccd47b5170fa115d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d9cbb1b31cf0a18427128378bc94ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a40d9cbb1b31cf0a18427128378bc94ec">RTE_HASH_LOOKUP_BULK_MAX</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a40d9cbb1b31cf0a18427128378bc94ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd61e2408201c3640614d663c26ca832"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#afd61e2408201c3640614d663c26ca832">RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:afd61e2408201c3640614d663c26ca832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537987573df8a66b3779a79a06ee6b53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a537987573df8a66b3779a79a06ee6b53">RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a537987573df8a66b3779a79a06ee6b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fe04975134a68fd36ed9007d3da2c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#ab6fe04975134a68fd36ed9007d3da2c3">RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ab6fe04975134a68fd36ed9007d3da2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833e09a559b3d97ed9ebb0d8cccad35a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a833e09a559b3d97ed9ebb0d8cccad35a">RTE_HASH_EXTRA_FLAGS_EXT_TABLE</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:a833e09a559b3d97ed9ebb0d8cccad35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6665149d7d36473ed2ff1175a7c56d02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a6665149d7d36473ed2ff1175a7c56d02">RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a6665149d7d36473ed2ff1175a7c56d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eec3dcb6fdf3b0cbbd2438bc9cc9584"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a1eec3dcb6fdf3b0cbbd2438bc9cc9584">RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:a1eec3dcb6fdf3b0cbbd2438bc9cc9584"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab9cf833d6d86f042b9ac01ae2e5b998f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a></td></tr>
<tr class="separator:ab9cf833d6d86f042b9ac01ae2e5b998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b12fdd40a9aa9aa254d45b052e57350"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a1b12fdd40a9aa9aa254d45b052e57350">rte_hash_function</a>) (const void *key, uint32_t key_len, uint32_t init_val)</td></tr>
<tr class="separator:a1b12fdd40a9aa9aa254d45b052e57350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed92c81ca3a2c3496ef666a48540941a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aed92c81ca3a2c3496ef666a48540941a">rte_hash_cmp_eq_t</a>) (const void *key1, const void *key2, size_t key_len)</td></tr>
<tr class="separator:aed92c81ca3a2c3496ef666a48540941a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503330274b0fdf2daec32e62d9da8ca3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a503330274b0fdf2daec32e62d9da8ca3">rte_hash_free_key_data</a>) (void *p, void *key_data)</td></tr>
<tr class="separator:a503330274b0fdf2daec32e62d9da8ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4b65a3539271784a096faaf5ade7c10e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a4b65a3539271784a096faaf5ade7c10e">rte_hash_qsbr_mode</a> { <a class="el" href="rte__hash_8h.html#a4b65a3539271784a096faaf5ade7c10eac68b8b493267c0e79f5a1867155e50a6">RTE_HASH_QSBR_MODE_DQ</a> = 0, 
<a class="el" href="rte__hash_8h.html#a4b65a3539271784a096faaf5ade7c10ea30a4d0655c340220ca7f31dfd0d6bdaa">RTE_HASH_QSBR_MODE_SYNC</a>
 }</td></tr>
<tr class="separator:a4b65a3539271784a096faaf5ade7c10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5afbd2564f738149a241bc22b2428612"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a5afbd2564f738149a241bc22b2428612">rte_hash_create</a> (const struct <a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a> *params)</td></tr>
<tr class="separator:a5afbd2564f738149a241bc22b2428612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cf154793d40409002d04f3e6d115d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#ad9cf154793d40409002d04f3e6d115d7">rte_hash_set_cmp_func</a> (struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, <a class="el" href="rte__hash_8h.html#aed92c81ca3a2c3496ef666a48540941a">rte_hash_cmp_eq_t</a> func)</td></tr>
<tr class="separator:ad9cf154793d40409002d04f3e6d115d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c3876597e47c045c945d78e0e1d332"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a04c3876597e47c045c945d78e0e1d332">rte_hash_find_existing</a> (const char *name)</td></tr>
<tr class="separator:a04c3876597e47c045c945d78e0e1d332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b82800460ad6918b822db30d1c21f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a2b82800460ad6918b822db30d1c21f77">rte_hash_free</a> (struct <a class="el" href="structrte__hash.html">rte_hash</a> *h)</td></tr>
<tr class="separator:a2b82800460ad6918b822db30d1c21f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4facc8e4c8a90695d23c8b00e864147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#ae4facc8e4c8a90695d23c8b00e864147">rte_hash_reset</a> (struct <a class="el" href="structrte__hash.html">rte_hash</a> *h)</td></tr>
<tr class="separator:ae4facc8e4c8a90695d23c8b00e864147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37751461f37a094a65e99c42a7d9e7ad"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a37751461f37a094a65e99c42a7d9e7ad">rte_hash_count</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h)</td></tr>
<tr class="separator:a37751461f37a094a65e99c42a7d9e7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db6ace28c517321f89e746255177928"><td class="memItemLeft" align="right" valign="top">__rte_experimental int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a9db6ace28c517321f89e746255177928">rte_hash_max_key_id</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h)</td></tr>
<tr class="separator:a9db6ace28c517321f89e746255177928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fbd5835f9ed6ff92e052a79f905237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a31fbd5835f9ed6ff92e052a79f905237">rte_hash_add_key_data</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, void *data)</td></tr>
<tr class="separator:a31fbd5835f9ed6ff92e052a79f905237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35eab0eba6576917e179532b0a768a40"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a35eab0eba6576917e179532b0a768a40">rte_hash_add_key_with_hash_data</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig, void *data)</td></tr>
<tr class="separator:a35eab0eba6576917e179532b0a768a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0247f58baa6cbf614e5b729ff0baf27e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a0247f58baa6cbf614e5b729ff0baf27e">rte_hash_add_key</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key)</td></tr>
<tr class="separator:a0247f58baa6cbf614e5b729ff0baf27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa426cfe49f1b6750cf35e932bb55067"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aaa426cfe49f1b6750cf35e932bb55067">rte_hash_add_key_with_hash</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:aaa426cfe49f1b6750cf35e932bb55067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa125f9c9f57ea5fdf2752bcb506a058"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aaa125f9c9f57ea5fdf2752bcb506a058">rte_hash_del_key</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key)</td></tr>
<tr class="separator:aaa125f9c9f57ea5fdf2752bcb506a058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da9abc1a395e6891d5f5d0f2ac69cf7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a0da9abc1a395e6891d5f5d0f2ac69cf7">rte_hash_del_key_with_hash</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:a0da9abc1a395e6891d5f5d0f2ac69cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8929e5161b2911bb6d8757bf4622470c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a8929e5161b2911bb6d8757bf4622470c">rte_hash_get_key_with_position</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const int32_t position, void **key)</td></tr>
<tr class="separator:a8929e5161b2911bb6d8757bf4622470c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44d7803e75cd3bba2e28677208fa8cc"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aa44d7803e75cd3bba2e28677208fa8cc">rte_hash_free_key_with_position</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const int32_t position)</td></tr>
<tr class="separator:aa44d7803e75cd3bba2e28677208fa8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd8f85b9c99eea0a619acc1d6ce2b2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a1bd8f85b9c99eea0a619acc1d6ce2b2c">rte_hash_lookup_data</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, void **data)</td></tr>
<tr class="separator:a1bd8f85b9c99eea0a619acc1d6ce2b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a201074d14a769bbd24888d881d879"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a61a201074d14a769bbd24888d881d879">rte_hash_lookup_with_hash_data</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig, void **data)</td></tr>
<tr class="separator:a61a201074d14a769bbd24888d881d879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ff0b837d39bbff00863feabf15e224"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a62ff0b837d39bbff00863feabf15e224">rte_hash_lookup</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key)</td></tr>
<tr class="separator:a62ff0b837d39bbff00863feabf15e224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf0a56da3a957a113ea1bfedd78c7e6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a8bf0a56da3a957a113ea1bfedd78c7e6">rte_hash_lookup_with_hash</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:a8bf0a56da3a957a113ea1bfedd78c7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade102f06405468de55ba865e139ad9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aade102f06405468de55ba865e139ad9f">rte_hash_hash</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key)</td></tr>
<tr class="separator:aade102f06405468de55ba865e139ad9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf63604a14912474cdb00ca3c014cd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#afbf63604a14912474cdb00ca3c014cd1">rte_hash_lookup_bulk_data</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void **keys, uint32_t num_keys, uint64_t *hit_mask, void *data[])</td></tr>
<tr class="separator:afbf63604a14912474cdb00ca3c014cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820274aa5c291043130daba602d97ce3"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a820274aa5c291043130daba602d97ce3">rte_hash_lookup_with_hash_bulk</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void **keys, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> *sig, uint32_t num_keys, int32_t *positions)</td></tr>
<tr class="separator:a820274aa5c291043130daba602d97ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd06d622d8168641857af4d7c8e24b4"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a7cd06d622d8168641857af4d7c8e24b4">rte_hash_lookup_with_hash_bulk_data</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void **keys, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> *sig, uint32_t num_keys, uint64_t *hit_mask, void *data[])</td></tr>
<tr class="separator:a7cd06d622d8168641857af4d7c8e24b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420dedbd249c73bbb94a98e10a87b088"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a420dedbd249c73bbb94a98e10a87b088">rte_hash_lookup_bulk</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void **keys, uint32_t num_keys, int32_t *positions)</td></tr>
<tr class="separator:a420dedbd249c73bbb94a98e10a87b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422544187ab0adad6f12e339bfb2b83f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a422544187ab0adad6f12e339bfb2b83f">rte_hash_iterate</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void **key, void **data, uint32_t *next)</td></tr>
<tr class="separator:a422544187ab0adad6f12e339bfb2b83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fd52e0236521cb0e3fa539457ff27d"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a08fd52e0236521cb0e3fa539457ff27d">rte_hash_rcu_qsbr_add</a> (struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, struct <a class="el" href="structrte__hash__rcu__config.html">rte_hash_rcu_config</a> *cfg)</td></tr>
<tr class="separator:a08fd52e0236521cb0e3fa539457ff27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Hash Table </p>

<p class="definition">Definition in file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a080e28e97cdd08dddfee7fc49084c0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080e28e97cdd08dddfee7fc49084c0f4">&#9670;&nbsp;</a></span>RTE_HASH_ENTRIES_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_ENTRIES_MAX&#160;&#160;&#160;(1 &lt;&lt; 30)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum size of hash table that can be created. </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00025">25</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="a6f2eca61b3180fccd47b5170fa115d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2eca61b3180fccd47b5170fa115d48">&#9670;&nbsp;</a></span>RTE_HASH_NAMESIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of characters in hash name. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a11">examples/server_node_efd/node/node.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00028">28</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="a40d9cbb1b31cf0a18427128378bc94ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d9cbb1b31cf0a18427128378bc94ec">&#9670;&nbsp;</a></span>RTE_HASH_LOOKUP_BULK_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_LOOKUP_BULK_MAX&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of keys that can be searched for using rte_hash_lookup_bulk. </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00031">31</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="afd61e2408201c3640614d663c26ca832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd61e2408201c3640614d663c26ca832">&#9670;&nbsp;</a></span>RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_EXTRA_FLAGS_TRANS_MEM_SUPPORT&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable Hardware transactional memory support. </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00035">35</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="a537987573df8a66b3779a79a06ee6b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537987573df8a66b3779a79a06ee6b53">&#9670;&nbsp;</a></span>RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default behavior of insertion, single writer/multi writer </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00038">38</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="ab6fe04975134a68fd36ed9007d3da2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fe04975134a68fd36ed9007d3da2c3">&#9670;&nbsp;</a></span>RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to support reader writer concurrency </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00041">41</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="a833e09a559b3d97ed9ebb0d8cccad35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833e09a559b3d97ed9ebb0d8cccad35a">&#9670;&nbsp;</a></span>RTE_HASH_EXTRA_FLAGS_EXT_TABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_EXTRA_FLAGS_EXT_TABLE&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to indicate the extendable bucket table feature should be used </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00044">44</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="a6665149d7d36473ed2ff1175a7c56d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6665149d7d36473ed2ff1175a7c56d02">&#9670;&nbsp;</a></span>RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to disable freeing of key index on hash delete. Refer to rte_hash_del_xxx APIs for more details. This is enabled by default when RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled. However, if internal RCU is enabled, freeing of internal memory/index is done on delete </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00052">52</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="a1eec3dcb6fdf3b0cbbd2438bc9cc9584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eec3dcb6fdf3b0cbbd2438bc9cc9584">&#9670;&nbsp;</a></span>RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to support lock free reader writer concurrency. Both single writer and multi writer use cases are supported. </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00057">57</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab9cf833d6d86f042b9ac01ae2e5b998f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cf833d6d86f042b9ac01ae2e5b998f">&#9670;&nbsp;</a></span>hash_sig_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of hash value of a key. It should be a value of at least 32bit with fully random pattern. </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00063">63</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="a1b12fdd40a9aa9aa254d45b052e57350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b12fdd40a9aa9aa254d45b052e57350">&#9670;&nbsp;</a></span>rte_hash_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* rte_hash_function) (const void *key, uint32_t key_len, uint32_t init_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function that can be used for calculating the hash value. </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00066">66</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="aed92c81ca3a2c3496ef666a48540941a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed92c81ca3a2c3496ef666a48540941a">&#9670;&nbsp;</a></span>rte_hash_cmp_eq_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_hash_cmp_eq_t) (const void *key1, const void *key2, size_t key_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function used to compare the hash key. </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00070">70</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<a id="a503330274b0fdf2daec32e62d9da8ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503330274b0fdf2daec32e62d9da8ca3">&#9670;&nbsp;</a></span>rte_hash_free_key_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_hash_free_key_data) (void *p, void *key_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function used to free data stored in the key. Required when using internal RCU to allow application to free key-data once the key is returned to the ring of free key-slots. </p>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00077">77</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4b65a3539271784a096faaf5ade7c10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b65a3539271784a096faaf5ade7c10e">&#9670;&nbsp;</a></span>rte_hash_qsbr_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__hash_8h.html#a4b65a3539271784a096faaf5ade7c10e">rte_hash_qsbr_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RCU reclamation modes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4b65a3539271784a096faaf5ade7c10eac68b8b493267c0e79f5a1867155e50a6"></a>RTE_HASH_QSBR_MODE_DQ&#160;</td><td class="fielddoc"><p>Create defer queue for reclaim. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4b65a3539271784a096faaf5ade7c10ea30a4d0655c340220ca7f31dfd0d6bdaa"></a>RTE_HASH_QSBR_MODE_SYNC&#160;</td><td class="fielddoc"><p>Use blocking mode reclaim. No defer queue created. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__hash_8h_source.html#l00094">94</a> of file <a class="el" href="rte__hash_8h_source.html">rte_hash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5afbd2564f738149a241bc22b2428612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afbd2564f738149a241bc22b2428612">&#9670;&nbsp;</a></span>rte_hash_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__hash.html">rte_hash</a>* rte_hash_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Parameters used to create and initialise the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to hash table structure that is used in future hash table operations, or NULL on error, with error code set in rte_errno. Possible rte_errno errors include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to rte_config structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>ENOENT - missing entry</li>
<li>EINVAL - invalid parameter passed to function</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a122">examples/ipsec-secgw/ipsec-secgw.c</a>, <a class="el" href="examples_2l3fwd-power_2main_8c-example.html#a105">examples/l3fwd-power/main.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_em_8c-example.html#a57">examples/l3fwd/l3fwd_em.c</a>, <a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a98">examples/performance-thread/l3fwd-thread/main.c</a>, and <a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a17">examples/server_node_efd/node/node.c</a>.</dd>
</dl>

</div>
</div>
<a id="ad9cf154793d40409002d04f3e6d115d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cf154793d40409002d04f3e6d115d7">&#9670;&nbsp;</a></span>rte_hash_set_cmp_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_hash_set_cmp_func </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#aed92c81ca3a2c3496ef666a48540941a">rte_hash_cmp_eq_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a new hash compare function other than the default one.</p>
<dl class="section note"><dt>Note</dt><dd>Function pointer does not work with multi-process, so do not use it in multi-process mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table for which the function is to be changed </td></tr>
    <tr><td class="paramname">func</td><td>New compare function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04c3876597e47c045c945d78e0e1d332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c3876597e47c045c945d78e0e1d332">&#9670;&nbsp;</a></span>rte_hash_find_existing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__hash.html">rte_hash</a>* rte_hash_find_existing </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an existing hash table object and return a pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the hash table as passed to <a class="el" href="rte__hash_8h.html#a5afbd2564f738149a241bc22b2428612">rte_hash_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to hash table or NULL if object not found with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - value not available for return </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2b82800460ad6918b822db30d1c21f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b82800460ad6918b822db30d1c21f77">&#9670;&nbsp;</a></span>rte_hash_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_hash_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-allocate all memory used by hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4facc8e4c8a90695d23c8b00e864147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4facc8e4c8a90695d23c8b00e864147">&#9670;&nbsp;</a></span>rte_hash_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_hash_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all hash structure, by zeroing all entries. When RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled, it is application's responsibility to make sure that none of the readers are referencing the hash table while calling this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37751461f37a094a65e99c42a7d9e7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37751461f37a094a65e99c42a7d9e7ad">&#9670;&nbsp;</a></span>rte_hash_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of keys in the hash table </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to query from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if parameters are invalid</li>
<li>A value indicating how many keys were inserted in the table. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9db6ace28c517321f89e746255177928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db6ace28c517321f89e746255177928">&#9670;&nbsp;</a></span>rte_hash_max_key_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int32_t rte_hash_max_key_id </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Return the maximum key value ID that could possibly be returned by rte_hash_add_key function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to query from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if parameters are invalid</li>
<li>A value indicating the max key ID of key slots present in the table. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a31fbd5835f9ed6ff92e052a79f905237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fbd5835f9ed6ff92e052a79f905237">&#9670;&nbsp;</a></span>rte_hash_add_key_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_add_key_data </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key-value pair to an existing hash table. This operation is not multi-thread safe and should only be called from one thread by default. Thread safety can be enabled by setting flag during table creation. If the key exists already in the table, this API updates its value with 'data' passed in this API. It is the responsibility of the application to manage any memory associated with the old value. The readers might still be using the old value even after this API has returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
    <tr><td class="paramname">data</td><td>Data to add to the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if added successfully</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a98">examples/ipsec-secgw/ipsec-secgw.c</a>.</dd>
</dl>

</div>
</div>
<a id="a35eab0eba6576917e179532b0a768a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35eab0eba6576917e179532b0a768a40">&#9670;&nbsp;</a></span>rte_hash_add_key_with_hash_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_add_key_with_hash_data </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key-value pair with a pre-computed hash value to an existing hash table. This operation is not multi-thread safe and should only be called from one thread by default. Thread safety can be enabled by setting flag during table creation. If the key exists already in the table, this API updates its value with 'data' passed in this API. It is the responsibility of the application to manage any memory associated with the old value. The readers might still be using the old value even after this API has returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key' </td></tr>
    <tr><td class="paramname">data</td><td>Data to add to the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if added successfully</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0247f58baa6cbf614e5b729ff0baf27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0247f58baa6cbf614e5b729ff0baf27e">&#9670;&nbsp;</a></span>rte_hash_add_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_add_key </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key to an existing hash table. This operation is not multi-thread safe and should only be called from one thread by default. Thread safety can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key. This unique key id may be larger than the user specified entry count when RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD flag is set. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2l3fwd-power_2main_8c-example.html#a107">examples/l3fwd-power/main.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_em_8c-example.html#a14">examples/l3fwd/l3fwd_em.c</a>, <a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a94">examples/performance-thread/l3fwd-thread/main.c</a>, and <a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a19">examples/server_node_efd/node/node.c</a>.</dd>
</dl>

</div>
</div>
<a id="aaa426cfe49f1b6750cf35e932bb55067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa426cfe49f1b6750cf35e932bb55067">&#9670;&nbsp;</a></span>rte_hash_add_key_with_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_add_key_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key to an existing hash table. This operation is not multi-thread safe and should only be called from one thread by default. Thread safety can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key. This unique key ID may be larger than the user specified entry count when RTE_HASH_EXTRA_FLAGS_MULTI_WRITER_ADD flag is set. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaa125f9c9f57ea5fdf2752bcb506a058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa125f9c9f57ea5fdf2752bcb506a058">&#9670;&nbsp;</a></span>rte_hash_del_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_del_key </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a key from an existing hash table. This operation is not multi-thread safe and should only be called from one thread by default. Thread safety can be enabled by setting flag during table creation. If RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL or RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled and internal RCU is NOT enabled, the key index returned by rte_hash_add_key_xxx APIs will not be freed by this API. rte_hash_free_key_with_position API must be called additionally to free the index associated with the key. rte_hash_free_key_with_position API should be called after all the readers have stopped referencing the entry corresponding to this key. RCU mechanisms could be used to determine such a state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to remove the key from. </td></tr>
    <tr><td class="paramname">key</td><td>Key to remove from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a0da9abc1a395e6891d5f5d0f2ac69cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da9abc1a395e6891d5f5d0f2ac69cf7">&#9670;&nbsp;</a></span>rte_hash_del_key_with_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_del_key_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a key from an existing hash table. This operation is not multi-thread safe and should only be called from one thread by default. Thread safety can be enabled by setting flag during table creation. If RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL or RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled and internal RCU is NOT enabled, the key index returned by rte_hash_add_key_xxx APIs will not be freed by this API. rte_hash_free_key_with_position API must be called additionally to free the index associated with the key. rte_hash_free_key_with_position API should be called after all the readers have stopped referencing the entry corresponding to this key. RCU mechanisms could be used to determine such a state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to remove the key from. </td></tr>
    <tr><td class="paramname">key</td><td>Key to remove from the hash table. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8929e5161b2911bb6d8757bf4622470c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8929e5161b2911bb6d8757bf4622470c">&#9670;&nbsp;</a></span>rte_hash_get_key_with_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_get_key_with_position </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key in the hash table given the position. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to get the key from. </td></tr>
    <tr><td class="paramname">position</td><td>Position returned when the key was inserted. </td></tr>
    <tr><td class="paramname">key</td><td>Output containing a pointer to the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if retrieved successfully</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if no valid key is found in the given position. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa44d7803e75cd3bba2e28677208fa8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44d7803e75cd3bba2e28677208fa8cc">&#9670;&nbsp;</a></span>rte_hash_free_key_with_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_hash_free_key_with_position </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Free a hash key in the hash table given the position of the key. This operation is not multi-thread safe and should only be called from one thread by default. Thread safety can be enabled by setting flag during table creation. If RTE_HASH_EXTRA_FLAGS_NO_FREE_ON_DEL or RTE_HASH_EXTRA_FLAGS_RW_CONCURRENCY_LF is enabled and internal RCU is NOT enabled, the key index returned by rte_hash_del_key_xxx APIs must be freed using this API. This API should be called after all the readers have stopped referencing the entry corresponding to this key. RCU mechanisms could be used to determine such a state. This API does not validate if the key is already freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to free the key from. </td></tr>
    <tr><td class="paramname">position</td><td>Position returned when the key was deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if freed successfully</li>
<li>-EINVAL if the parameters are invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1bd8f85b9c99eea0a619acc1d6ce2b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd8f85b9c99eea0a619acc1d6ce2b2c">&#9670;&nbsp;</a></span>rte_hash_lookup_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_data </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key-value pair in the hash table. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
    <tr><td class="paramname">data</td><td>Output with pointer to data returned from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added.</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipsec-secgw_2ipsec_8c-example.html#a17">examples/ipsec-secgw/ipsec.c</a>.</dd>
</dl>

</div>
</div>
<a id="a61a201074d14a769bbd24888d881d879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a201074d14a769bbd24888d881d879">&#9670;&nbsp;</a></span>rte_hash_lookup_with_hash_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_with_hash_data </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key-value pair with a pre-computed hash value to an existing hash table. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key' </td></tr>
    <tr><td class="paramname">data</td><td>Output with pointer to data returned from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added.</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a62ff0b837d39bbff00863feabf15e224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ff0b837d39bbff00863feabf15e224">&#9670;&nbsp;</a></span>rte_hash_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key in the hash table. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a97">examples/ipsec-secgw/ipsec-secgw.c</a>, <a class="el" href="examples_2l3fwd-power_2main_8c-example.html#a40">examples/l3fwd-power/main.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_em_8c-example.html#a10">examples/l3fwd/l3fwd_em.c</a>, and <a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a44">examples/performance-thread/l3fwd-thread/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a8bf0a56da3a957a113ea1bfedd78c7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf0a56da3a957a113ea1bfedd78c7e6">&#9670;&nbsp;</a></span>rte_hash_lookup_with_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_lookup_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key in the hash table. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
    <tr><td class="paramname">sig</td><td>Precomputed hash value for 'key'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aade102f06405468de55ba865e139ad9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade102f06405468de55ba865e139ad9f">&#9670;&nbsp;</a></span>rte_hash_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> rte_hash_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calc a hash value by key. This operation is not multi-process safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>hash value </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afbf63604a14912474cdb00ca3c014cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf63604a14912474cdb00ca3c014cd1">&#9670;&nbsp;</a></span>rte_hash_lookup_bulk_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_bulk_data </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>hit_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find multiple keys in the hash table. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">keys</td><td>A pointer to a list of keys to look for. </td></tr>
    <tr><td class="paramname">num_keys</td><td>How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX). </td></tr>
    <tr><td class="paramname">hit_mask</td><td>Output containing a bitmask with all successful lookups. </td></tr>
    <tr><td class="paramname">data</td><td>Output containing array of data returned from all the successful lookups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if there's an error, otherwise number of successful lookups. </dd></dl>

</div>
</div>
<a id="a820274aa5c291043130daba602d97ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820274aa5c291043130daba602d97ce3">&#9670;&nbsp;</a></span>rte_hash_lookup_with_hash_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_hash_lookup_with_hash_bulk </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Find multiple keys in the hash table with precomputed hash value array. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">keys</td><td>A pointer to a list of keys to look for. </td></tr>
    <tr><td class="paramname">sig</td><td>A pointer to a list of precomputed hash values for keys. </td></tr>
    <tr><td class="paramname">num_keys</td><td>How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX). </td></tr>
    <tr><td class="paramname">positions</td><td>Output containing a list of values, corresponding to the list of keys that can be used by the caller as an offset into an array of user data. These values are unique for each key, and are the same values that were returned when each key was added. If a key in the list was not found, then -ENOENT will be the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if there's an error, otherwise 0. </dd></dl>

</div>
</div>
<a id="a7cd06d622d8168641857af4d7c8e24b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd06d622d8168641857af4d7c8e24b4">&#9670;&nbsp;</a></span>rte_hash_lookup_with_hash_bulk_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_hash_lookup_with_hash_bulk_data </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> *&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>hit_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Find multiple keys in the hash table with precomputed hash value array. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">keys</td><td>A pointer to a list of keys to look for. </td></tr>
    <tr><td class="paramname">sig</td><td>A pointer to a list of precomputed hash values for keys. </td></tr>
    <tr><td class="paramname">num_keys</td><td>How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX). </td></tr>
    <tr><td class="paramname">hit_mask</td><td>Output containing a bitmask with all successful lookups. </td></tr>
    <tr><td class="paramname">data</td><td>Output containing array of data returned from all the successful lookups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if there's an error, otherwise number of successful lookups. </dd></dl>

</div>
</div>
<a id="a420dedbd249c73bbb94a98e10a87b088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420dedbd249c73bbb94a98e10a87b088">&#9670;&nbsp;</a></span>rte_hash_lookup_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_bulk </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find multiple keys in the hash table. This operation is multi-thread safe with regarding to other lookup threads. Read-write concurrency can be enabled by setting flag during table creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">keys</td><td>A pointer to a list of keys to look for. </td></tr>
    <tr><td class="paramname">num_keys</td><td>How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX). </td></tr>
    <tr><td class="paramname">positions</td><td>Output containing a list of values, corresponding to the list of keys that can be used by the caller as an offset into an array of user data. These values are unique for each key, and are the same values that were returned when each key was added. If a key in the list was not found, then -ENOENT will be the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if there's an error, otherwise 0. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a50">examples/performance-thread/l3fwd-thread/main.c</a>, and <a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a26">examples/server_node_efd/node/node.c</a>.</dd>
</dl>

</div>
</div>
<a id="a422544187ab0adad6f12e339bfb2b83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422544187ab0adad6f12e339bfb2b83f">&#9670;&nbsp;</a></span>rte_hash_iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_iterate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate through the hash table, returning key-value pairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to iterate </td></tr>
    <tr><td class="paramname">key</td><td>Output containing the key where current iterator was pointing at </td></tr>
    <tr><td class="paramname">data</td><td>Output containing the data associated with key. Returns NULL if data was not stored. </td></tr>
    <tr><td class="paramname">next</td><td>Pointer to iterator. Should be 0 to start iterating the hash table. Iterator is incremented after each call of this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position where key was stored, if successful.<ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if end of the hash table. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a08fd52e0236521cb0e3fa539457ff27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fd52e0236521cb0e3fa539457ff27d">&#9670;&nbsp;</a></span>rte_hash_rcu_qsbr_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_hash_rcu_qsbr_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__hash__rcu__config.html">rte_hash_rcu_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Associate RCU QSBR variable with a Hash object. This API should be called to enable the integrated RCU QSBR support and should be called immediately after creating the Hash object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the hash object to add RCU QSBR </td></tr>
    <tr><td class="paramname">cfg</td><td>RCU QSBR configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success - 0 On error - 1 with error code set in rte_errno. Possible rte_errno codes are:<ul>
<li>EINVAL - invalid pointer</li>
<li>EEXIST - already added QSBR</li>
<li>ENOMEM - memory allocation failure </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
