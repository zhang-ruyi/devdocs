<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_mbuf/rte_mbuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a914dcfab5ff2d1bc9dd6b873a7b604d.html">librte_mbuf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_mbuf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;rte_compat.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;rte_config.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__prefetch_8h_source.html">rte_prefetch.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__branch__prediction_8h_source.html">rte_branch_prediction.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__byteorder_8h_source.html">rte_byteorder.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mbuf__ptype_8h_source.html">rte_mbuf_ptype.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mbuf__core_8h_source.html">rte_mbuf_core.h</a>&gt;</code><br />
</div>
<p><a href="rte__mbuf_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pktmbuf__pool__private.html">rte_pktmbuf_pool_private</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pktmbuf__extmem.html">rte_pktmbuf_extmem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad74a45d25f3f42703c512a5033766efd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad74a45d25f3f42703c512a5033766efd">RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:ad74a45d25f3f42703c512a5033766efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c05466e9783feaf5018a43bb333fad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ac1c05466e9783feaf5018a43bb333fad">RTE_MBUF_HAS_PINNED_EXTBUF</a>(mb)&#160;&#160;&#160;	(<a class="el" href="rte__mbuf_8h.html#a750883ecd0b60655c5c2a267c08608a3">rte_pktmbuf_priv_flags</a>(mb-&gt;pool) &amp; <a class="el" href="rte__mbuf_8h.html#ad74a45d25f3f42703c512a5033766efd">RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF</a>)</td></tr>
<tr class="separator:ac1c05466e9783feaf5018a43bb333fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93da89e4fcf908c0615bcc71c2998413"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a93da89e4fcf908c0615bcc71c2998413">__rte_mbuf_sanity_check</a>(m,  is_h)&#160;&#160;&#160;do { } while (0)</td></tr>
<tr class="separator:a93da89e4fcf908c0615bcc71c2998413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c79f6cb6bdeae531469d0a648d7771"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a01c79f6cb6bdeae531469d0a648d7771">RTE_MBUF_PREFETCH_TO_FREE</a>(m)</td></tr>
<tr class="separator:a01c79f6cb6bdeae531469d0a648d7771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09724c82461ae2f23559f604d070899a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a09724c82461ae2f23559f604d070899a">MBUF_RAW_ALLOC_CHECK</a>(m)&#160;&#160;&#160;<a class="el" href="rte__mbuf_8h.html#af539f24e5db12e9a1bfa38445157ab2f">__rte_mbuf_raw_sanity_check</a>(m)</td></tr>
<tr class="separator:a09724c82461ae2f23559f604d070899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ca163847af218fe9e314679d8810f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a66ca163847af218fe9e314679d8810f1">rte_pktmbuf_detach_extbuf</a>(m)&#160;&#160;&#160;<a class="el" href="rte__mbuf_8h.html#a6c4a685c7386d442b658db0a6edacb43">rte_pktmbuf_detach</a>(m)</td></tr>
<tr class="separator:a66ca163847af218fe9e314679d8810f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7ea614c79d5b9ed790a56c1c79189d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a7a7ea614c79d5b9ed790a56c1c79189d">rte_pktmbuf_pkt_len</a>(m)&#160;&#160;&#160;((m)-&gt;pkt_len)</td></tr>
<tr class="separator:a7a7ea614c79d5b9ed790a56c1c79189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1e1b30162161ed11d3ba2faf7bbf13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a2a1e1b30162161ed11d3ba2faf7bbf13">rte_pktmbuf_data_len</a>(m)&#160;&#160;&#160;((m)-&gt;data_len)</td></tr>
<tr class="separator:a2a1e1b30162161ed11d3ba2faf7bbf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8a7ea94222787cc7c03ae887c8bac759"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a8a7ea94222787cc7c03ae887c8bac759">rte_get_rx_ol_flag_name</a> (uint64_t mask)</td></tr>
<tr class="separator:a8a7ea94222787cc7c03ae887c8bac759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8cccd2201125c34dbe5bae0a5af123"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a0b8cccd2201125c34dbe5bae0a5af123">rte_get_rx_ol_flag_list</a> (uint64_t mask, char *buf, size_t buflen)</td></tr>
<tr class="separator:a0b8cccd2201125c34dbe5bae0a5af123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced30b3b2643f8a2d33ef66c5c9fe175"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aced30b3b2643f8a2d33ef66c5c9fe175">rte_get_tx_ol_flag_name</a> (uint64_t mask)</td></tr>
<tr class="separator:aced30b3b2643f8a2d33ef66c5c9fe175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ead1fd4005a6d29351d555e0f6e38c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a25ead1fd4005a6d29351d555e0f6e38c">rte_get_tx_ol_flag_list</a> (uint64_t mask, char *buf, size_t buflen)</td></tr>
<tr class="separator:a25ead1fd4005a6d29351d555e0f6e38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d28b8e4843825772945ad95f8f255e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a2d28b8e4843825772945ad95f8f255e9">rte_mbuf_prefetch_part1</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a2d28b8e4843825772945ad95f8f255e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e75f18703d94db97f61db2e1fce51e8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a0e75f18703d94db97f61db2e1fce51e8">rte_mbuf_prefetch_part2</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a0e75f18703d94db97f61db2e1fce51e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc63705bb85669e2a1ea17e3279d59ce"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#afc63705bb85669e2a1ea17e3279d59ce">rte_pktmbuf_priv_size</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:afc63705bb85669e2a1ea17e3279d59ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23efdded80d0c361e4fd9bd1809ce3b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a23efdded80d0c361e4fd9bd1809ce3b0">rte_mbuf_data_iova</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mb)</td></tr>
<tr class="separator:a23efdded80d0c361e4fd9bd1809ce3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a886974bb05fd2a54432961051cd54d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1a886974bb05fd2a54432961051cd54d">rte_mbuf_data_iova_default</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mb)</td></tr>
<tr class="separator:a1a886974bb05fd2a54432961051cd54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ed1e332f10aa98e4f700bd8ea0ae3c"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ae4ed1e332f10aa98e4f700bd8ea0ae3c">rte_mbuf_from_indirect</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mi)</td></tr>
<tr class="separator:ae4ed1e332f10aa98e4f700bd8ea0ae3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0f1ba5e1f64ffba761e67f7eee02a"><td class="memItemLeft" align="right" valign="top">static __rte_experimental char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad2d0f1ba5e1f64ffba761e67f7eee02a">rte_mbuf_buf_addr</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mb, struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:ad2d0f1ba5e1f64ffba761e67f7eee02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2082785390c527e10c1d5c6e82349034"><td class="memItemLeft" align="right" valign="top">static __rte_experimental char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a2082785390c527e10c1d5c6e82349034">rte_mbuf_data_addr_default</a> (<a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mb)</td></tr>
<tr class="separator:a2082785390c527e10c1d5c6e82349034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4a6a2a711b320dd16652ca839feab"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1cb4a6a2a711b320dd16652ca839feab">rte_mbuf_to_baddr</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *md)</td></tr>
<tr class="separator:a1cb4a6a2a711b320dd16652ca839feab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099fd78d1517875e7a9dc2c723b5696e"><td class="memItemLeft" align="right" valign="top">static __rte_experimental void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a099fd78d1517875e7a9dc2c723b5696e">rte_mbuf_to_priv</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a099fd78d1517875e7a9dc2c723b5696e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750883ecd0b60655c5c2a267c08608a3"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a750883ecd0b60655c5c2a267c08608a3">rte_pktmbuf_priv_flags</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a750883ecd0b60655c5c2a267c08608a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7eb5fa1599b7f6237040b95d8893de"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#abb7eb5fa1599b7f6237040b95d8893de">rte_mbuf_refcnt_update</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, int16_t value)</td></tr>
<tr class="separator:abb7eb5fa1599b7f6237040b95d8893de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cad099c1aedd46af38588ad97dabd65"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a9cad099c1aedd46af38588ad97dabd65">rte_mbuf_refcnt_read</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a9cad099c1aedd46af38588ad97dabd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86233fc739e93e6d0136034ea7066e69"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a86233fc739e93e6d0136034ea7066e69">rte_mbuf_refcnt_set</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t new_value)</td></tr>
<tr class="separator:a86233fc739e93e6d0136034ea7066e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba580ac0f20bb904f271baa02c256785"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aba580ac0f20bb904f271baa02c256785">rte_mbuf_ext_refcnt_read</a> (const struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *shinfo)</td></tr>
<tr class="separator:aba580ac0f20bb904f271baa02c256785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1ca0a95c2dc87a4a01d14cd6edb052"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aab1ca0a95c2dc87a4a01d14cd6edb052">rte_mbuf_ext_refcnt_set</a> (struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *shinfo, uint16_t new_value)</td></tr>
<tr class="separator:aab1ca0a95c2dc87a4a01d14cd6edb052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2d5b153fda4d1bdf49adc1f424f8f7"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a8f2d5b153fda4d1bdf49adc1f424f8f7">rte_mbuf_ext_refcnt_update</a> (struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *shinfo, int16_t value)</td></tr>
<tr class="separator:a8f2d5b153fda4d1bdf49adc1f424f8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab874199ad183c4720ef5fd198d5159a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ab874199ad183c4720ef5fd198d5159a5">rte_mbuf_sanity_check</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, int is_header)</td></tr>
<tr class="separator:ab874199ad183c4720ef5fd198d5159a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92bbae2f79a5cec5364a58285304e7f"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad92bbae2f79a5cec5364a58285304e7f">rte_mbuf_check</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, int is_header, const char **reason)</td></tr>
<tr class="separator:ad92bbae2f79a5cec5364a58285304e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af539f24e5db12e9a1bfa38445157ab2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#af539f24e5db12e9a1bfa38445157ab2f">__rte_mbuf_raw_sanity_check</a> (<a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:af539f24e5db12e9a1bfa38445157ab2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008287388f5c32ebc812eaa166017a50"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a008287388f5c32ebc812eaa166017a50">rte_mbuf_raw_alloc</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a008287388f5c32ebc812eaa166017a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f188d53834978aca01ea101576d7432"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a9f188d53834978aca01ea101576d7432">rte_mbuf_raw_free</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a9f188d53834978aca01ea101576d7432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d0b427cb071856f2ff0805d608e35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a7c0d0b427cb071856f2ff0805d608e35">rte_pktmbuf_init</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque_arg, void *m, unsigned i)</td></tr>
<tr class="separator:a7c0d0b427cb071856f2ff0805d608e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af714a7341cb37bc2530ac07c84c829b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#af714a7341cb37bc2530ac07c84c829b6">rte_pktmbuf_pool_init</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque_arg)</td></tr>
<tr class="separator:af714a7341cb37bc2530ac07c84c829b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593921f13307803b94bbb4e0932db962"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a593921f13307803b94bbb4e0932db962">rte_pktmbuf_pool_create</a> (const char *name, unsigned n, unsigned cache_size, uint16_t priv_size, uint16_t data_room_size, int socket_id)</td></tr>
<tr class="separator:a593921f13307803b94bbb4e0932db962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4bd0ae9e01d0f4dfe7d27cfb0d9a7f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a9e4bd0ae9e01d0f4dfe7d27cfb0d9a7f">rte_pktmbuf_pool_create_by_ops</a> (const char *name, unsigned int n, unsigned int cache_size, uint16_t priv_size, uint16_t data_room_size, int socket_id, const char *ops_name)</td></tr>
<tr class="separator:a9e4bd0ae9e01d0f4dfe7d27cfb0d9a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf64e19be766dd80c7a247d45ab5ef2"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#acaf64e19be766dd80c7a247d45ab5ef2">rte_pktmbuf_pool_create_extbuf</a> (const char *name, unsigned int n, unsigned int cache_size, uint16_t priv_size, uint16_t data_room_size, int socket_id, const struct <a class="el" href="structrte__pktmbuf__extmem.html">rte_pktmbuf_extmem</a> *ext_mem, unsigned int ext_num)</td></tr>
<tr class="separator:acaf64e19be766dd80c7a247d45ab5ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fe14dae4b72eeecadcb684af5a9703"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ac8fe14dae4b72eeecadcb684af5a9703">rte_pktmbuf_data_room_size</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:ac8fe14dae4b72eeecadcb684af5a9703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8043f0dba7b6a56674e109ace99f206"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ae8043f0dba7b6a56674e109ace99f206">rte_pktmbuf_reset_headroom</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:ae8043f0dba7b6a56674e109ace99f206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84d82d50361f568dd1d3a0e95d4aa4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#afc84d82d50361f568dd1d3a0e95d4aa4">rte_pktmbuf_reset</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:afc84d82d50361f568dd1d3a0e95d4aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d1c289d8cffc831dfb77c64f52447b"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad4d1c289d8cffc831dfb77c64f52447b">rte_pktmbuf_alloc</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:ad4d1c289d8cffc831dfb77c64f52447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d2aeb7f1189a3a6c33c861391cb16b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ae3d2aeb7f1189a3a6c33c861391cb16b">rte_pktmbuf_alloc_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *pool, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **mbufs, unsigned count)</td></tr>
<tr class="separator:ae3d2aeb7f1189a3a6c33c861391cb16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0801d15a3929289f2c197fdc64b8e6b9"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a0801d15a3929289f2c197fdc64b8e6b9">rte_pktmbuf_ext_shinfo_init_helper</a> (void *buf_addr, uint16_t *buf_len, <a class="el" href="rte__mbuf__core_8h.html#ad2189b043c406c250028c4b53aa3e71c">rte_mbuf_extbuf_free_callback_t</a> free_cb, void *fcb_opaque)</td></tr>
<tr class="separator:a0801d15a3929289f2c197fdc64b8e6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd5c42be5bb286c178165dacc6602fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#adfd5c42be5bb286c178165dacc6602fd">rte_pktmbuf_attach_extbuf</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, void *buf_addr, <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> buf_iova, uint16_t buf_len, struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *shinfo)</td></tr>
<tr class="separator:adfd5c42be5bb286c178165dacc6602fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb8b1ca240cc3417bed163a0d1394b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a4eb8b1ca240cc3417bed163a0d1394b6">rte_mbuf_dynfield_copy</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mdst, const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *msrc)</td></tr>
<tr class="separator:a4eb8b1ca240cc3417bed163a0d1394b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd14156493e5a1de3b036188862cbfd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#afdd14156493e5a1de3b036188862cbfd">rte_pktmbuf_attach</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mi, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:afdd14156493e5a1de3b036188862cbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4a685c7386d442b658db0a6edacb43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a6c4a685c7386d442b658db0a6edacb43">rte_pktmbuf_detach</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a6c4a685c7386d442b658db0a6edacb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb42cfdbd709af24932b116b6bccd6d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a6eb42cfdbd709af24932b116b6bccd6d">rte_pktmbuf_prefree_seg</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a6eb42cfdbd709af24932b116b6bccd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006ee80357a78fbb9ada2b0432f82f37"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a006ee80357a78fbb9ada2b0432f82f37">rte_pktmbuf_free_seg</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a006ee80357a78fbb9ada2b0432f82f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1215458932900b7cd5192326fa4a6902"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1215458932900b7cd5192326fa4a6902">rte_pktmbuf_free</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a1215458932900b7cd5192326fa4a6902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870d6b87464bbc3a6514f7edf1386a09"><td class="memItemLeft" align="right" valign="top">__rte_experimental void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a870d6b87464bbc3a6514f7edf1386a09">rte_pktmbuf_free_bulk</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **mbufs, unsigned int count)</td></tr>
<tr class="separator:a870d6b87464bbc3a6514f7edf1386a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1a5320fb96ff8c1a44be0aaec93856"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a5f1a5320fb96ff8c1a44be0aaec93856">rte_pktmbuf_clone</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *md, struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a5f1a5320fb96ff8c1a44be0aaec93856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f6ba3f0f9afe72e21e3a3f8908e6ae"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a04f6ba3f0f9afe72e21e3a3f8908e6ae">rte_pktmbuf_copy</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, uint32_t offset, uint32_t length)</td></tr>
<tr class="separator:a04f6ba3f0f9afe72e21e3a3f8908e6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac5629940550649a2ef40029f5ad21a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a7ac5629940550649a2ef40029f5ad21a">rte_pktmbuf_refcnt_update</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, int16_t v)</td></tr>
<tr class="separator:a7ac5629940550649a2ef40029f5ad21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a67c1b6a6b7c07e488d5fed7b03502d"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a2a67c1b6a6b7c07e488d5fed7b03502d">rte_pktmbuf_headroom</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a2a67c1b6a6b7c07e488d5fed7b03502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bc8af3e8fde7eb6603bdf4ae0528e"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a257bc8af3e8fde7eb6603bdf4ae0528e">rte_pktmbuf_tailroom</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a257bc8af3e8fde7eb6603bdf4ae0528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2d001cd113362dd123d663210afcbb"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a0c2d001cd113362dd123d663210afcbb">rte_pktmbuf_lastseg</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a0c2d001cd113362dd123d663210afcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5bef4ceb0b76dfafff0895f285ab0"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aadf5bef4ceb0b76dfafff0895f285ab0">rte_pktmbuf_prepend</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t len)</td></tr>
<tr class="separator:aadf5bef4ceb0b76dfafff0895f285ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b0cd686ad3bcbb83416ca8395a080b"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad5b0cd686ad3bcbb83416ca8395a080b">rte_pktmbuf_append</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t len)</td></tr>
<tr class="separator:ad5b0cd686ad3bcbb83416ca8395a080b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbd752194759ce7b419c4998f2e8651"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1bbd752194759ce7b419c4998f2e8651">rte_pktmbuf_adj</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t len)</td></tr>
<tr class="separator:a1bbd752194759ce7b419c4998f2e8651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1bed439015acec170d1342e8dabb3b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#abe1bed439015acec170d1342e8dabb3b">rte_pktmbuf_trim</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t len)</td></tr>
<tr class="separator:abe1bed439015acec170d1342e8dabb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511a116ae4822037d4f1fb561aa4ffcf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a511a116ae4822037d4f1fb561aa4ffcf">rte_pktmbuf_is_contiguous</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a511a116ae4822037d4f1fb561aa4ffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f96a031626331434a041ea2a694c3a9"><td class="memItemLeft" align="right" valign="top">static const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1f96a031626331434a041ea2a694c3a9">rte_pktmbuf_read</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint32_t off, uint32_t len, void *buf)</td></tr>
<tr class="separator:a1f96a031626331434a041ea2a694c3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52dbeb3951f5b90259d3760128ee139"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#af52dbeb3951f5b90259d3760128ee139">rte_pktmbuf_chain</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *head, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *tail)</td></tr>
<tr class="separator:af52dbeb3951f5b90259d3760128ee139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0bad278c24fa14a0013d3b135305cc"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#adc0bad278c24fa14a0013d3b135305cc">rte_validate_tx_offload</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:adc0bad278c24fa14a0013d3b135305cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbca9abd7fb09025afa5d39195ed92f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a9cbca9abd7fb09025afa5d39195ed92f">rte_pktmbuf_linearize</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mbuf)</td></tr>
<tr class="separator:a9cbca9abd7fb09025afa5d39195ed92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92788c9769a5561814c77ae2e6f65e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a92788c9769a5561814c77ae2e6f65e7e">rte_pktmbuf_dump</a> (FILE *f, const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, unsigned dump_len)</td></tr>
<tr class="separator:a92788c9769a5561814c77ae2e6f65e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce660cdc41182fb90a773afbe01c3a2"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a2ce660cdc41182fb90a773afbe01c3a2">rte_mbuf_sched_queue_get</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a2ce660cdc41182fb90a773afbe01c3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab925c715105cfd2642c77c02d51ae652"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ab925c715105cfd2642c77c02d51ae652">rte_mbuf_sched_traffic_class_get</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:ab925c715105cfd2642c77c02d51ae652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1af0267951d4e655098e32f8a1c9299"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#af1af0267951d4e655098e32f8a1c9299">rte_mbuf_sched_color_get</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:af1af0267951d4e655098e32f8a1c9299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c580502fb09bbb9483cb929d588d9a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a68c580502fb09bbb9483cb929d588d9a">rte_mbuf_sched_get</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint32_t *queue_id, uint8_t *traffic_class, uint8_t *color)</td></tr>
<tr class="separator:a68c580502fb09bbb9483cb929d588d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42323fb1b451b4916459234fb090a5a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ac42323fb1b451b4916459234fb090a5a">rte_mbuf_sched_queue_set</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint32_t queue_id)</td></tr>
<tr class="separator:ac42323fb1b451b4916459234fb090a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c3400feaf54325b0d6232b94397fe7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad2c3400feaf54325b0d6232b94397fe7">rte_mbuf_sched_traffic_class_set</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint8_t traffic_class)</td></tr>
<tr class="separator:ad2c3400feaf54325b0d6232b94397fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d2b8433bf0499911ec438a912cfcba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a50d2b8433bf0499911ec438a912cfcba">rte_mbuf_sched_color_set</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint8_t color)</td></tr>
<tr class="separator:a50d2b8433bf0499911ec438a912cfcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6c4280b6708d3fef269a0992930885"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a4a6c4280b6708d3fef269a0992930885">rte_mbuf_sched_set</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint32_t queue_id, uint8_t traffic_class, uint8_t color)</td></tr>
<tr class="separator:a4a6c4280b6708d3fef269a0992930885"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Mbuf</p>
<p>The mbuf library provides the ability to create and destroy buffers that may be used by the RTE application to store message buffers. The message buffers are stored in a mempool, using the RTE mempool library.</p>
<p>The preferred way to create a mbuf pool is to use <a class="el" href="rte__mbuf_8h.html#a593921f13307803b94bbb4e0932db962">rte_pktmbuf_pool_create()</a>. However, in some situations, an application may want to have more control (ex: populate the pool with specific memory), in this case it is possible to use functions from <a class="el" href="structrte__mempool.html">rte_mempool</a>. See how <a class="el" href="rte__mbuf_8h.html#a593921f13307803b94bbb4e0932db962">rte_pktmbuf_pool_create()</a> is implemented for details.</p>
<p>This library provides an API to allocate/free packet mbufs, which are used to carry network packets.</p>
<p>To understand the concepts of packet buffers or mbufs, you should read "TCP/IP Illustrated, Volume 2: The Implementation,
Addison-Wesley, 1995, ISBN 0-201-63354-X from Richard Stevens" <a href="http://www.kohala.com/start/tcpipiv2.html">http://www.kohala.com/start/tcpipiv2.html</a> </p>

<p class="definition">Definition in file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad74a45d25f3f42703c512a5033766efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74a45d25f3f42703c512a5033766efd">&#9670;&nbsp;</a></span>RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When set, pktmbuf mempool will hold only mbufs with pinned external buffer. The external buffer will be attached to the mbuf at the memory pool creation and will never be detached by the mbuf free calls. mbuf should not contain any room for data after the mbuf structure. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00317">317</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ac1c05466e9783feaf5018a43bb333fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c05466e9783feaf5018a43bb333fad">&#9670;&nbsp;</a></span>RTE_MBUF_HAS_PINNED_EXTBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MBUF_HAS_PINNED_EXTBUF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mb</td><td>)</td>
          <td>&#160;&#160;&#160;	(<a class="el" href="rte__mbuf_8h.html#a750883ecd0b60655c5c2a267c08608a3">rte_pktmbuf_priv_flags</a>(mb-&gt;pool) &amp; <a class="el" href="rte__mbuf_8h.html#ad74a45d25f3f42703c512a5033766efd">RTE_PKTMBUF_POOL_F_PINNED_EXT_BUF</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns non zero if given mbuf has a pinned external buffer, or zero otherwise. The pinned external buffer is allocated at pool creation time and should not be freed on mbuf freeing.</p>
<p>External buffer is a user-provided anonymous buffer. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00326">326</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a93da89e4fcf908c0615bcc71c2998413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93da89e4fcf908c0615bcc71c2998413">&#9670;&nbsp;</a></span>__rte_mbuf_sanity_check</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __rte_mbuf_sanity_check</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_h&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;do { } while (0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check mbuf type in debug mode </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a23">examples/ipv4_multicast/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00337">337</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a01c79f6cb6bdeae531469d0a648d7771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c79f6cb6bdeae531469d0a648d7771">&#9670;&nbsp;</a></span>RTE_MBUF_PREFETCH_TO_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MBUF_PREFETCH_TO_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keywordflow">do</span> {       \</div>
<div class="line">    if ((m) != NULL)                        \</div>
<div class="line">        rte_prefetch0(m);               \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Mbuf prefetch </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00499">499</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a09724c82461ae2f23559f604d070899a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09724c82461ae2f23559f604d070899a">&#9670;&nbsp;</a></span>MBUF_RAW_ALLOC_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBUF_RAW_ALLOC_CHECK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="rte__mbuf_8h.html#af539f24e5db12e9a1bfa38445157ab2f">__rte_mbuf_raw_sanity_check</a>(m)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For backwards compatibility. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00565">565</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a66ca163847af218fe9e314679d8810f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ca163847af218fe9e314679d8810f1">&#9670;&nbsp;</a></span>rte_pktmbuf_detach_extbuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rte_pktmbuf_detach_extbuf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="rte__mbuf_8h.html#a6c4a685c7386d442b658db0a6edacb43">rte_pktmbuf_detach</a>(m)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach the external buffer attached to a mbuf, same as <code><a class="el" href="rte__mbuf_8h.html#a6c4a685c7386d442b658db0a6edacb43">rte_pktmbuf_detach()</a></code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mbuf having external buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01097">1097</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a7a7ea614c79d5b9ed790a56c1c79189d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7ea614c79d5b9ed790a56c1c79189d">&#9670;&nbsp;</a></span>rte_pktmbuf_pkt_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rte_pktmbuf_pkt_len</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;((m)-&gt;pkt_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro that returns the length of the packet.</p>
<p>The value can be read or assigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2fips_validation_2main_8c-example.html#a100">examples/fips_validation/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2esp_8c-example.html#a7">examples/ipsec-secgw/esp.c</a>, <a class="el" href="examples_2l2fwd-crypto_2main_8c-example.html#a41">examples/l2fwd-crypto/main.c</a>, and <a class="el" href="examples_2qos_meter_2main_8c-example.html#a16">examples/qos_meter/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01545">1545</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a2a1e1b30162161ed11d3ba2faf7bbf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1e1b30162161ed11d3ba2faf7bbf13">&#9670;&nbsp;</a></span>rte_pktmbuf_data_len</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rte_pktmbuf_data_len</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;((m)-&gt;data_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro that returns the length of the segment.</p>
<p>The value can be read or assigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a34">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2fips_validation_2main_8c-example.html#a101">examples/fips_validation/main.c</a>, <a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a24">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2ipsec-secgw_2esp_8c-example.html#a45">examples/ipsec-secgw/esp.c</a>, <a class="el" href="examples_2l2fwd-crypto_2main_8c-example.html#a29">examples/l2fwd-crypto/main.c</a>, and <a class="el" href="examples_2vhost_2virtio_net_8c-example.html#a12">examples/vhost/virtio_net.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01555">1555</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8a7ea94222787cc7c03ae887c8bac759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7ea94222787cc7c03ae887c8bac759">&#9670;&nbsp;</a></span>rte_get_rx_ol_flag_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_get_rx_ol_flag_name </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a RX offload flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The mask describing the flag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of this flag, or NULL if it's not a valid RX flag. </dd></dl>

</div>
</div>
<a id="a0b8cccd2201125c34dbe5bae0a5af123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8cccd2201125c34dbe5bae0a5af123">&#9670;&nbsp;</a></span>rte_get_rx_ol_flag_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_get_rx_ol_flag_list </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the list of RX offload flags in a buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The mask describing the RX flags. </td></tr>
    <tr><td class="paramname">buf</td><td>The output buffer. </td></tr>
    <tr><td class="paramname">buflen</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, (-1) on error. </dd></dl>

</div>
</div>
<a id="aced30b3b2643f8a2d33ef66c5c9fe175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced30b3b2643f8a2d33ef66c5c9fe175">&#9670;&nbsp;</a></span>rte_get_tx_ol_flag_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* rte_get_tx_ol_flag_name </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a TX offload flag</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The mask describing the flag. Usually only one bit must be set. Several bits can be given if they belong to the same mask. Ex: PKT_TX_L4_MASK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of this flag, or NULL if it's not a valid TX flag. </dd></dl>

</div>
</div>
<a id="a25ead1fd4005a6d29351d555e0f6e38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ead1fd4005a6d29351d555e0f6e38c">&#9670;&nbsp;</a></span>rte_get_tx_ol_flag_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_get_tx_ol_flag_list </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the list of TX offload flags in a buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The mask describing the TX flags. </td></tr>
    <tr><td class="paramname">buf</td><td>The output buffer. </td></tr>
    <tr><td class="paramname">buflen</td><td>The length of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, (-1) on error. </dd></dl>

</div>
</div>
<a id="a2d28b8e4843825772945ad95f8f255e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d28b8e4843825772945ad95f8f255e9">&#9670;&nbsp;</a></span>rte_mbuf_prefetch_part1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_prefetch_part1 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefetch the first part of the mbuf</p>
<p>The first 64 bytes of the mbuf corresponds to fields that are used early in the receive path. If the cache line of the architecture is higher than 64B, the second part will also be prefetched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pointer to the mbuf. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00111">111</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a0e75f18703d94db97f61db2e1fce51e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e75f18703d94db97f61db2e1fce51e8">&#9670;&nbsp;</a></span>rte_mbuf_prefetch_part2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_prefetch_part2 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefetch the second part of the mbuf</p>
<p>The next 64 bytes of the mbuf corresponds to fields that are used in the transmit path. If the cache line of the architecture is higher than 64B, this function does nothing as it is expected that the full mbuf is already in cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pointer to the mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a58">examples/ipsec-secgw/ipsec-secgw.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00128">128</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="afc63705bb85669e2a1ea17e3279d59ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc63705bb85669e2a1ea17e3279d59ce">&#9670;&nbsp;</a></span>rte_pktmbuf_priv_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_pktmbuf_priv_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the application private size of mbufs stored in a pktmbuf_pool</p>
<p>The private size of mbuf is a zone located between the <a class="el" href="structrte__mbuf.html">rte_mbuf</a> structure and the data buffer where an application can store data associated to a packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The packet mbuf pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The private size of mbufs stored in this mempool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00831">831</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a23efdded80d0c361e4fd9bd1809ce3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23efdded80d0c361e4fd9bd1809ce3b0">&#9670;&nbsp;</a></span>rte_mbuf_data_iova()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> rte_mbuf_data_iova </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the IO address of the beginning of the mbuf data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>The pointer to the mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IO address of the beginning of the mbuf data </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00149">149</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a1a886974bb05fd2a54432961051cd54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a886974bb05fd2a54432961051cd54d">&#9670;&nbsp;</a></span>rte_mbuf_data_iova_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> rte_mbuf_data_iova_default </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the default IO address of the beginning of the mbuf data</p>
<p>This function is used by drivers in their receive function, as it returns the location where data should be written by the NIC, taking the default headroom in account.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>The pointer to the mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IO address of the beginning of the mbuf data </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00167">167</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ae4ed1e332f10aa98e4f700bd8ea0ae3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ed1e332f10aa98e4f700bd8ea0ae3c">&#9670;&nbsp;</a></span>rte_mbuf_from_indirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_mbuf_from_indirect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mbuf owning the data buffer address of an indirect mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>The pointer to the indirect mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the direct mbuf corresponding to buffer_addr. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00181">181</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ad2d0f1ba5e1f64ffba761e67f7eee02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d0f1ba5e1f64ffba761e67f7eee02a">&#9670;&nbsp;</a></span>rte_mbuf_buf_addr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental char* rte_mbuf_buf_addr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return address of buffer embedded in the given mbuf.</p>
<p>The return value shall be same as mb-&gt;buf_addr if the mbuf is already initialized and direct. However, this API is useful if mempool of the mbuf is already known because it doesn't need to access mbuf contents in order to get the mempool pointer.</p>
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> This API may change without prior notice. This will be used by <a class="el" href="rte__mbuf_8h.html#a1cb4a6a2a711b320dd16652ca839feab">rte_mbuf_to_baddr()</a> which has redundant code once experimental tag is removed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>The pointer to the mbuf. </td></tr>
    <tr><td class="paramname">mp</td><td>The pointer to the mempool of the mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer of the mbuf buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00208">208</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a2082785390c527e10c1d5c6e82349034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2082785390c527e10c1d5c6e82349034">&#9670;&nbsp;</a></span>rte_mbuf_data_addr_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental char* rte_mbuf_data_addr_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the default address of the beginning of the mbuf data.</p>
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> This API may change without prior notice.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb</td><td>The pointer to the mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer of the beginning of the mbuf data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00226">226</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a1cb4a6a2a711b320dd16652ca839feab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb4a6a2a711b320dd16652ca839feab">&#9670;&nbsp;</a></span>rte_mbuf_to_baddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* rte_mbuf_to_baddr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>md</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return address of buffer embedded in the given mbuf.</p>
<dl class="section note"><dt>Note</dt><dd>: Accessing mempool pointer of a mbuf is expensive because the pointer is stored in the 2nd cache line of mbuf. If mempool is known, it is better not to reference the mempool pointer in mbuf but calling <a class="el" href="rte__mbuf_8h.html#ad2d0f1ba5e1f64ffba761e67f7eee02a">rte_mbuf_buf_addr()</a> would be more efficient.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">md</td><td>The pointer to the mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the data buffer owned by the mbuf. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00252">252</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a099fd78d1517875e7a9dc2c723b5696e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099fd78d1517875e7a9dc2c723b5696e">&#9670;&nbsp;</a></span>rte_mbuf_to_priv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __rte_experimental void* rte_mbuf_to_priv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the starting address of the private data area embedded in the given mbuf.</p>
<p>Note that no check is made to ensure that a private data area actually exists in the supplied mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pointer to the mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The starting address of the private data area of the given mbuf. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00277">277</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a750883ecd0b60655c5c2a267c08608a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750883ecd0b60655c5c2a267c08608a3">&#9670;&nbsp;</a></span>rte_pktmbuf_priv_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t rte_pktmbuf_priv_flags </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the flags from private data in an mempool structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flags from the private data structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00303">303</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="abb7eb5fa1599b7f6237040b95d8893de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7eb5fa1599b7f6237040b95d8893de">&#9670;&nbsp;</a></span>rte_mbuf_refcnt_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_mbuf_refcnt_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds given value to an mbuf's refcnt and returns its new value. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00419">419</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a9cad099c1aedd46af38588ad97dabd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cad099c1aedd46af38588ad97dabd65">&#9670;&nbsp;</a></span>rte_mbuf_refcnt_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_mbuf_refcnt_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the value of an mbuf's refcnt. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00428">428</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a86233fc739e93e6d0136034ea7066e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86233fc739e93e6d0136034ea7066e69">&#9670;&nbsp;</a></span>rte_mbuf_refcnt_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_refcnt_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets an mbuf's refcnt to the defined value. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00437">437</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="aba580ac0f20bb904f271baa02c256785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba580ac0f20bb904f271baa02c256785">&#9670;&nbsp;</a></span>rte_mbuf_ext_refcnt_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_mbuf_ext_refcnt_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *&#160;</td>
          <td class="paramname"><em>shinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the refcnt of an external buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shinfo</td><td>Shared data of the external buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference count number. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00453">453</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="aab1ca0a95c2dc87a4a01d14cd6edb052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1ca0a95c2dc87a4a01d14cd6edb052">&#9670;&nbsp;</a></span>rte_mbuf_ext_refcnt_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_ext_refcnt_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *&#160;</td>
          <td class="paramname"><em>shinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set refcnt of an external buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shinfo</td><td>Shared data of the external buffer. </td></tr>
    <tr><td class="paramname">new_value</td><td>Value set </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00467">467</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a8f2d5b153fda4d1bdf49adc1f424f8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2d5b153fda4d1bdf49adc1f424f8f7">&#9670;&nbsp;</a></span>rte_mbuf_ext_refcnt_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_mbuf_ext_refcnt_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *&#160;</td>
          <td class="paramname"><em>shinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add given value to refcnt of an external buffer and return its new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shinfo</td><td>Shared data of the external buffer. </td></tr>
    <tr><td class="paramname">value</td><td>Value to add/subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated value </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00485">485</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ab874199ad183c4720ef5fd198d5159a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab874199ad183c4720ef5fd198d5159a5">&#9670;&nbsp;</a></span>rte_mbuf_sanity_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mbuf_sanity_check </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sanity checks on an mbuf.</p>
<p>Check the consistency of the given mbuf. The function will cause a panic if corruption is detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mbuf to be checked. </td></tr>
    <tr><td class="paramname">is_header</td><td>True if the mbuf is a packet header, false if it is a sub-segment of a packet (in this case, some fields like nb_segs are not checked) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad92bbae2f79a5cec5364a58285304e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92bbae2f79a5cec5364a58285304e7f">&#9670;&nbsp;</a></span>rte_mbuf_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_mbuf_check </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sanity checks on a mbuf.</p>
<p>Almost like <a class="el" href="rte__mbuf_8h.html#ab874199ad183c4720ef5fd198d5159a5">rte_mbuf_sanity_check()</a>, but this function gives the reason if corruption is detected rather than panic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mbuf to be checked. </td></tr>
    <tr><td class="paramname">is_header</td><td>True if the mbuf is a packet header, false if it is a sub-segment of a packet (in this case, some fields like nb_segs are not checked) </td></tr>
    <tr><td class="paramname">reason</td><td>A reference to a string pointer where to store the reason why a mbuf is considered invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if no issue has been found, reason is left untouched.</li>
<li>-1 if a problem is detected, reason then points to a string describing the reason why the mbuf is deemed invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af539f24e5db12e9a1bfa38445157ab2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af539f24e5db12e9a1bfa38445157ab2f">&#9670;&nbsp;</a></span>__rte_mbuf_raw_sanity_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void __rte_mbuf_raw_sanity_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sanity checks on a reinitialized mbuf in debug mode.</p>
<p>Check the consistency of the given reinitialized mbuf. The function will cause a panic if corruption is detected.</p>
<p>Check that the mbuf is properly reinitialized (refcnt=1, next=NULL, nb_segs=1), as done by <a class="el" href="rte__mbuf_8h.html#a6eb42cfdbd709af24932b116b6bccd6d">rte_pktmbuf_prefree_seg()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mbuf to be checked. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00556">556</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a008287388f5c32ebc812eaa166017a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008287388f5c32ebc812eaa166017a50">&#9670;&nbsp;</a></span>rte_mbuf_raw_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_mbuf_raw_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate an uninitialized mbuf from mempool <em>mp</em>.</p>
<p>This function can be used by PMDs (especially in RX functions) to allocate an uninitialized mbuf. The driver is responsible of initializing all the required fields. See <a class="el" href="rte__mbuf_8h.html#afc84d82d50361f568dd1d3a0e95d4aa4">rte_pktmbuf_reset()</a>. For standard needs, prefer <a class="el" href="rte__mbuf_8h.html#ad4d1c289d8cffc831dfb77c64f52447b">rte_pktmbuf_alloc()</a>.</p>
<p>The caller can expect that the following fields of the mbuf structure are initialized: buf_addr, buf_iova, buf_len, refcnt=1, nb_segs=1, next=NULL, pool, priv_size. The other fields must be initialized by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which mbuf is allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The pointer to the new mbuf on success.</li>
<li>NULL if allocation failed. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a19">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00586">586</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a9f188d53834978aca01ea101576d7432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f188d53834978aca01ea101576d7432">&#9670;&nbsp;</a></span>rte_mbuf_raw_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_mbuf_raw_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put mbuf back into its original mempool.</p>
<p>The caller must ensure that the mbuf is direct and properly reinitialized (refcnt=1, next=NULL, nb_segs=1), as done by <a class="el" href="rte__mbuf_8h.html#a6eb42cfdbd709af24932b116b6bccd6d">rte_pktmbuf_prefree_seg()</a>.</p>
<p>This function should be used with care, when optimization is required. For standard needs, prefer <a class="el" href="rte__mbuf_8h.html#a1215458932900b7cd5192326fa4a6902">rte_pktmbuf_free()</a> or <a class="el" href="rte__mbuf_8h.html#a006ee80357a78fbb9ada2b0432f82f37">rte_pktmbuf_free_seg()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mbuf to be freed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00611">611</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a7c0d0b427cb071856f2ff0805d608e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0d0b427cb071856f2ff0805d608e35">&#9670;&nbsp;</a></span>rte_pktmbuf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_pktmbuf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The packet mbuf constructor.</p>
<p>This function initializes some fields in the mbuf structure that are not modified by the user once created (origin pool, buffer start address, and so on). This function is given as a callback function to <a class="el" href="rte__mempool_8h.html#abd4bec335c01bac3d695beffb5a28690">rte_mempool_obj_iter()</a> or <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> at pool creation time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which mbufs originate. </td></tr>
    <tr><td class="paramname">opaque_arg</td><td>A pointer that can be used by the user to retrieve useful information for mbuf initialization. This pointer is the opaque argument passed to <a class="el" href="rte__mempool_8h.html#abd4bec335c01bac3d695beffb5a28690">rte_mempool_obj_iter()</a> or <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a>. </td></tr>
    <tr><td class="paramname">m</td><td>The mbuf to initialize. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the mbuf in the pool table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a69">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="af714a7341cb37bc2530ac07c84c829b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af714a7341cb37bc2530ac07c84c829b6">&#9670;&nbsp;</a></span>rte_pktmbuf_pool_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_pktmbuf_pool_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A packet mbuf pool constructor.</p>
<p>This function initializes the mempool private data in the case of a pktmbuf pool. This private data is needed by the driver. The function must be called on the mempool before it is used, or it can be given as a callback function to <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> at pool creation. It can be extended by the user, for example, to provide another packet size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which mbufs originate. </td></tr>
    <tr><td class="paramname">opaque_arg</td><td>A pointer that can be used by the user to retrieve useful information for mbuf initialization. This pointer is the opaque argument passed to <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a56">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a593921f13307803b94bbb4e0932db962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593921f13307803b94bbb4e0932db962">&#9670;&nbsp;</a></span>rte_pktmbuf_pool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_pktmbuf_pool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>priv_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data_room_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a mbuf pool.</p>
<p>This function creates and initializes a packet mbuf pool. It is a wrapper to <a class="el" href="structrte__mempool.html">rte_mempool</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mbuf pool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mbuf pool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">cache_size</td><td>Size of the per-core object cache. See <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> for details. </td></tr>
    <tr><td class="paramname">priv_size</td><td>Size of application private are between the <a class="el" href="structrte__mbuf.html">rte_mbuf</a> structure and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN. </td></tr>
    <tr><td class="paramname">data_room_size</td><td>Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The socket identifier where the memory should be allocated. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to rte_config structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - cache size provided is too large, or priv_size is not aligned.</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a119">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2bond_2main_8c-example.html#a86">examples/bond/main.c</a>, <a class="el" href="examples_2distributor_2main_8c-example.html#a63">examples/distributor/main.c</a>, <a class="el" href="examples_2ethtool_2ethtool-app_2main_8c-example.html#a11">examples/ethtool/ethtool-app/main.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_generic_8c-example.html#a71">examples/eventdev_pipeline/pipeline_worker_generic.c</a>, <a class="el" href="examples_2eventdev_pipeline_2pipeline_worker_tx_8c-example.html#a78">examples/eventdev_pipeline/pipeline_worker_tx.c</a>, <a class="el" href="examples_2fips_validation_2fips_dev_self_test_8c-example.html#a95">examples/fips_validation/fips_dev_self_test.c</a>, <a class="el" href="examples_2fips_validation_2main_8c-example.html#a14">examples/fips_validation/main.c</a>, <a class="el" href="examples_2flow_classify_2flow_classify_8c-example.html#a83">examples/flow_classify/flow_classify.c</a>, <a class="el" href="examples_2flow_filtering_2main_8c-example.html#a40">examples/flow_filtering/main.c</a>, <a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a90">examples/ioat/ioatfwd.c</a>, <a class="el" href="examples_2ip_fragmentation_2main_8c-example.html#a77">examples/ip_fragmentation/main.c</a>, <a class="el" href="examples_2ip_pipeline_2mempool_8c-example.html#a2">examples/ip_pipeline/mempool.c</a>, <a class="el" href="examples_2ip_reassembly_2main_8c-example.html#a73">examples/ip_reassembly/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a161">examples/ipsec-secgw/ipsec-secgw.c</a>, <a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a65">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2kni_2main_8c-example.html#a67">examples/kni/main.c</a>, <a class="el" href="examples_2l2fwd-cat_2l2fwd-cat_8c-example.html#a28">examples/l2fwd-cat/l2fwd-cat.c</a>, <a class="el" href="examples_2l2fwd-crypto_2main_8c-example.html#a146">examples/l2fwd-crypto/main.c</a>, <a class="el" href="examples_2l2fwd-event_2main_8c-example.html#a24">examples/l2fwd-event/main.c</a>, <a class="el" href="examples_2l2fwd-jobstats_2main_8c-example.html#a48">examples/l2fwd-jobstats/main.c</a>, <a class="el" href="examples_2l2fwd-keepalive_2main_8c-example.html#a41">examples/l2fwd-keepalive/main.c</a>, <a class="el" href="examples_2l2fwd_2main_8c-example.html#a42">examples/l2fwd/main.c</a>, <a class="el" href="examples_2l3fwd-acl_2main_8c-example.html#a82">examples/l3fwd-acl/main.c</a>, <a class="el" href="examples_2l3fwd-graph_2main_8c-example.html#a26">examples/l3fwd-graph/main.c</a>, <a class="el" href="examples_2l3fwd-power_2main_8c-example.html#a112">examples/l3fwd-power/main.c</a>, <a class="el" href="examples_2l3fwd_2main_8c-example.html#a24">examples/l3fwd/main.c</a>, <a class="el" href="examples_2link_status_interrupt_2main_8c-example.html#a38">examples/link_status_interrupt/main.c</a>, <a class="el" href="examples_2multi_process_2client_server_mp_2mp_server_2init_8c-example.html#a1">examples/multi_process/client_server_mp/mp_server/init.c</a>, <a class="el" href="examples_2multi_process_2symmetric_mp_2main_8c-example.html#a47">examples/multi_process/symmetric_mp/main.c</a>, <a class="el" href="examples_2packet_ordering_2main_8c-example.html#a53">examples/packet_ordering/main.c</a>, <a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a105">examples/performance-thread/l3fwd-thread/main.c</a>, <a class="el" href="examples_2pipeline_2obj_8c-example.html#a3">examples/pipeline/obj.c</a>, <a class="el" href="examples_2ptpclient_2ptpclient_8c-example.html#a57">examples/ptpclient/ptpclient.c</a>, <a class="el" href="examples_2qos_meter_2main_8c-example.html#a32">examples/qos_meter/main.c</a>, <a class="el" href="examples_2qos_sched_2init_8c-example.html#a41">examples/qos_sched/init.c</a>, <a class="el" href="examples_2rxtx_callbacks_2main_8c-example.html#a49">examples/rxtx_callbacks/main.c</a>, <a class="el" href="examples_2server_node_efd_2server_2init_8c-example.html#a1">examples/server_node_efd/server/init.c</a>, <a class="el" href="examples_2skeleton_2basicfwd_8c-example.html#a34">examples/skeleton/basicfwd.c</a>, <a class="el" href="examples_2vhost_2main_8c-example.html#a104">examples/vhost/main.c</a>, <a class="el" href="examples_2vm_power_manager_2main_8c-example.html#a33">examples/vm_power_manager/main.c</a>, <a class="el" href="examples_2vmdq_2main_8c-example.html#a55">examples/vmdq/main.c</a>, and <a class="el" href="examples_2vmdq_dcb_2main_8c-example.html#a62">examples/vmdq_dcb/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a9e4bd0ae9e01d0f4dfe7d27cfb0d9a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4bd0ae9e01d0f4dfe7d27cfb0d9a7f">&#9670;&nbsp;</a></span>rte_pktmbuf_pool_create_by_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_pktmbuf_pool_create_by_ops </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>priv_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data_room_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ops_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a mbuf pool with a given mempool ops name</p>
<p>This function creates and initializes a packet mbuf pool. It is a wrapper to <a class="el" href="structrte__mempool.html">rte_mempool</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mbuf pool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mbuf pool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">cache_size</td><td>Size of the per-core object cache. See <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> for details. </td></tr>
    <tr><td class="paramname">priv_size</td><td>Size of application private are between the <a class="el" href="structrte__mbuf.html">rte_mbuf</a> structure and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN. </td></tr>
    <tr><td class="paramname">data_room_size</td><td>Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The socket identifier where the memory should be allocated. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">ops_name</td><td>The mempool ops name to be used for this mempool instead of default mempool. The value can be <em>NULL</em> to use default mempool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to rte_config structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - cache size provided is too large, or priv_size is not aligned.</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>

</div>
</div>
<a id="acaf64e19be766dd80c7a247d45ab5ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf64e19be766dd80c7a247d45ab5ef2">&#9670;&nbsp;</a></span>rte_pktmbuf_pool_create_extbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_pktmbuf_pool_create_extbuf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>priv_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data_room_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__pktmbuf__extmem.html">rte_pktmbuf_extmem</a> *&#160;</td>
          <td class="paramname"><em>ext_mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ext_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a mbuf pool with external pinned data buffers.</p>
<p>This function creates and initializes a packet mbuf pool that contains only mbufs with external buffer. It is a wrapper to <a class="el" href="structrte__mempool.html">rte_mempool</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mbuf pool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mbuf pool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">cache_size</td><td>Size of the per-core object cache. See <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> for details. </td></tr>
    <tr><td class="paramname">priv_size</td><td>Size of application private are between the <a class="el" href="structrte__mbuf.html">rte_mbuf</a> structure and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN. </td></tr>
    <tr><td class="paramname">data_room_size</td><td>Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The socket identifier where the memory should be allocated. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">ext_mem</td><td>Pointer to the array of structures describing the external memory for data buffers. It is caller responsibility to register this memory with <a class="el" href="rte__memory_8h.html#aab8198657eaa2ab71f82ea8f2abd8b94">rte_extmem_register()</a> (if needed), map this memory to appropriate physical device, etc. </td></tr>
    <tr><td class="paramname">ext_num</td><td>Number of elements in the ext_mem array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to rte_config structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - cache size provided is too large, or priv_size is not aligned.</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ac8fe14dae4b72eeecadcb684af5a9703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fe14dae4b72eeecadcb684af5a9703">&#9670;&nbsp;</a></span>rte_pktmbuf_data_room_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_pktmbuf_data_room_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the data room size of mbufs stored in a pktmbuf_pool</p>
<p>The data room size is the amount of data that can be stored in a mbuf including the headroom (RTE_PKTMBUF_HEADROOM).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The packet mbuf pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data room size of mbufs stored in this mempool. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00810">810</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ae8043f0dba7b6a56674e109ace99f206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8043f0dba7b6a56674e109ace99f206">&#9670;&nbsp;</a></span>rte_pktmbuf_reset_headroom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_reset_headroom </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the data_off field of a packet mbuf to its default value.</p>
<p>The given mbuf must have only one segment, which should be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf's data_off field has to be reset. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00847">847</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="afc84d82d50361f568dd1d3a0e95d4aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc84d82d50361f568dd1d3a0e95d4aa4">&#9670;&nbsp;</a></span>rte_pktmbuf_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the fields of a packet mbuf to their default values.</p>
<p>The given mbuf must have only one segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf to be reset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a59">examples/bbdev_app/main.c</a>, and <a class="el" href="examples_2fips_validation_2fips_dev_self_test_8c-example.html#a70">examples/fips_validation/fips_dev_self_test.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00861">861</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ad4d1c289d8cffc831dfb77c64f52447b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d1c289d8cffc831dfb77c64f52447b">&#9670;&nbsp;</a></span>rte_pktmbuf_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pktmbuf_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a new mbuf from a mempool.</p>
<p>This new mbuf contains one segment, which has a length of 0. The pointer to data is initialized to have some bytes of headroom in the buffer (if buffer size allows).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which the mbuf is allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The pointer to the new mbuf on success.</li>
<li>NULL if allocation failed. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bond_2main_8c-example.html#a68">examples/bond/main.c</a>, <a class="el" href="examples_2fips_validation_2fips_dev_self_test_8c-example.html#a103">examples/fips_validation/fips_dev_self_test.c</a>, <a class="el" href="examples_2fips_validation_2main_8c-example.html#a38">examples/fips_validation/main.c</a>, <a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a17">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a30">examples/ntb/ntb_fwd.c</a>, <a class="el" href="examples_2ptpclient_2ptpclient_8c-example.html#a35">examples/ptpclient/ptpclient.c</a>, and <a class="el" href="examples_2vhost_2virtio_net_8c-example.html#a21">examples/vhost/virtio_net.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00892">892</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ae3d2aeb7f1189a3a6c33c861391cb16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d2aeb7f1189a3a6c33c861391cb16b">&#9670;&nbsp;</a></span>rte_pktmbuf_alloc_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_pktmbuf_alloc_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>mbufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a bulk of mbufs, initialize refcnt and reset the fields to default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The mempool from which mbufs are allocated. </td></tr>
    <tr><td class="paramname">mbufs</td><td>Array of pointers to mbufs </td></tr>
    <tr><td class="paramname">count</td><td>Array size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success</li>
<li>-ENOENT: Not enough entries in the mempool; no mbufs are retrieved. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00914">914</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a0801d15a3929289f2c197fdc64b8e6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0801d15a3929289f2c197fdc64b8e6b9">&#9670;&nbsp;</a></span>rte_pktmbuf_ext_shinfo_init_helper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a>* rte_pktmbuf_ext_shinfo_init_helper </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mbuf__core_8h.html#ad2189b043c406c250028c4b53aa3e71c">rte_mbuf_extbuf_free_callback_t</a>&#160;</td>
          <td class="paramname"><em>free_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fcb_opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize shared data at the end of an external buffer before attaching to a mbuf by <code><a class="el" href="rte__mbuf_8h.html#adfd5c42be5bb286c178165dacc6602fd">rte_pktmbuf_attach_extbuf()</a></code>. This is not a mandatory initialization but a helper function to simply spare a few bytes at the end of the buffer for shared data. If shared data is allocated separately, this should not be called but application has to properly initialize the shared data according to its need.</p>
<p>Free callback and its argument is saved and the refcnt is set to 1.</p>
<dl class="section warning"><dt>Warning</dt><dd>The value of buf_len will be reduced to <a class="el" href="rte__common_8h.html#a59dd2418e7278f66471590e1fc8aa3cf">RTE_PTR_DIFF(shinfo, buf_addr)</a> after this initialization. This shall be used for <code><a class="el" href="rte__mbuf_8h.html#adfd5c42be5bb286c178165dacc6602fd">rte_pktmbuf_attach_extbuf()</a></code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buf_addr</td><td>The pointer to the external buffer. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_len</td><td>The pointer to length of the external buffer. Input value must be larger than the size of <code>struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a></code> and padding for alignment. If not enough, this function will return NULL. Adjusted buffer length will be returned through this pointer. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">free_cb</td><td>Free callback function to call when the external buffer needs to be freed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fcb_opaque</td><td>Argument for the free callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the initialized shared data on success, return NULL otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l00989">989</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="adfd5c42be5bb286c178165dacc6602fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd5c42be5bb286c178165dacc6602fd">&#9670;&nbsp;</a></span>rte_pktmbuf_attach_extbuf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_attach_extbuf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td>
          <td class="paramname"><em>buf_iova</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *&#160;</td>
          <td class="paramname"><em>shinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attach an external buffer to a mbuf.</p>
<p>User-managed anonymous buffer can be attached to an mbuf. When attaching it, corresponding free callback function and its argument should be provided via shinfo. This callback function will be called once all the mbufs are detached from the buffer (refcnt becomes zero).</p>
<p>The headroom length of the attaching mbuf will be set to zero and this can be properly adjusted after attachment. For example, <code><a class="el" href="rte__mbuf_8h.html#a1bbd752194759ce7b419c4998f2e8651">rte_pktmbuf_adj()</a></code> or <code><a class="el" href="rte__mbuf_8h.html#ae8043f0dba7b6a56674e109ace99f206">rte_pktmbuf_reset_headroom()</a></code> might be used.</p>
<p>Similarly, the packet length is initialized to 0. If the buffer contains data, the user has to adjust <code>data_len</code> and the <code>pkt_len</code> field of the mbuf accordingly.</p>
<p>More mbufs can be attached to the same external buffer by <code><a class="el" href="rte__mbuf_8h.html#afdd14156493e5a1de3b036188862cbfd">rte_pktmbuf_attach()</a></code> once the external buffer has been attached by this API.</p>
<p>Detachment can be done by either <code><a class="el" href="rte__mbuf_8h.html#a66ca163847af218fe9e314679d8810f1">rte_pktmbuf_detach_extbuf()</a></code> or <code><a class="el" href="rte__mbuf_8h.html#a6c4a685c7386d442b658db0a6edacb43">rte_pktmbuf_detach()</a></code>.</p>
<p>Memory for shared data must be provided and user must initialize all of the content properly, especially free callback and refcnt. The pointer of shared data will be stored in m-&gt;shinfo. <code>rte_pktmbuf_ext_shinfo_init_helper</code> can help to simply spare a few bytes at the end of buffer for the shared data, store free callback and its argument and set the refcnt to 1. The following is an example:</p>
<p>struct <a class="el" href="structrte__mbuf__ext__shared__info.html">rte_mbuf_ext_shared_info</a> *shinfo = rte_pktmbuf_ext_shinfo_init_helper(buf_addr, &amp;buf_len, free_cb, fcb_arg); rte_pktmbuf_attach_extbuf(m, buf_addr, buf_iova, buf_len, shinfo); rte_pktmbuf_reset_headroom(m); rte_pktmbuf_adj(m, data_len);</p>
<p>Attaching an external buffer is quite similar to mbuf indirection in replacing buffer addresses and length of a mbuf, but a few differences:</p><ul>
<li>When an indirect mbuf is attached, refcnt of the direct mbuf would be 2 as long as the direct mbuf itself isn't freed after the attachment. In such cases, the buffer area of a direct mbuf must be read-only. But external buffer has its own refcnt and it starts from 1. Unless multiple mbufs are attached to a mbuf having an external buffer, the external buffer is writable.</li>
<li>There's no need to allocate buffer from a mempool. Any buffer can be attached with appropriate free callback and its IO address.</li>
<li>Smaller metadata is required to maintain shared data such as refcnt.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pointer to the mbuf. </td></tr>
    <tr><td class="paramname">buf_addr</td><td>The pointer to the external buffer. </td></tr>
    <tr><td class="paramname">buf_iova</td><td>IO address of the external buffer. </td></tr>
    <tr><td class="paramname">buf_len</td><td>The size of the external buffer. </td></tr>
    <tr><td class="paramname">shinfo</td><td>User-provided memory for shared data of the external buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01071">1071</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a4eb8b1ca240cc3417bed163a0d1394b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb8b1ca240cc3417bed163a0d1394b6">&#9670;&nbsp;</a></span>rte_mbuf_dynfield_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_dynfield_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mdst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>msrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy dynamic fields from msrc to mdst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mdst</td><td>The destination mbuf. </td></tr>
    <tr><td class="paramname">msrc</td><td>The source mbuf. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01108">1108</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="afdd14156493e5a1de3b036188862cbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd14156493e5a1de3b036188862cbfd">&#9670;&nbsp;</a></span>rte_pktmbuf_attach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attach packet mbuf to another packet mbuf.</p>
<p>If the mbuf we are attaching to isn't a direct buffer and is attached to an external buffer, the mbuf being attached will be attached to the external buffer instead of mbuf indirection.</p>
<p>Otherwise, the mbuf will be indirectly attached. After attachment we refer the mbuf we attached as 'indirect', while mbuf we attached to as 'direct'. The direct mbuf's reference counter is incremented.</p>
<p>Right now, not supported:</p><ul>
<li>attachment for already indirect mbuf (e.g. - mi has to be direct).</li>
<li>mbuf we trying to attach (mi) is used by someone else e.g. it's reference counter is greater then 1.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>The indirect packet mbuf. </td></tr>
    <tr><td class="paramname">m</td><td>The packet mbuf we're attaching to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01147">1147</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a6c4a685c7386d442b658db0a6edacb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4a685c7386d442b658db0a6edacb43">&#9670;&nbsp;</a></span>rte_pktmbuf_detach()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_detach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detach a packet mbuf from external buffer or direct buffer.</p>
<ul>
<li>decrement refcnt and free the external/direct buffer if refcnt becomes zero.</li>
<li>restore original mbuf address and length values.</li>
<li>reset pktmbuf data and data_len to their default values.</li>
</ul>
<p>All other fields of the given packet mbuf will be left intact.</p>
<p>If the packet mbuf was allocated from the pool with pinned external buffers the rte_pktmbuf_detach does nothing with the mbuf of this kind, because the pinned buffers are not supposed to be detached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The indirect attached packet mbuf. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01237">1237</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a6eb42cfdbd709af24932b116b6bccd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb42cfdbd709af24932b116b6bccd6d">&#9670;&nbsp;</a></span>rte_pktmbuf_prefree_seg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pktmbuf_prefree_seg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decrease reference counter and unlink a mbuf segment</p>
<p>This function does the same than a free, except that it does not return the segment to its pool. It decreases the reference counter, and if it reaches 0, it is detached from its parent for an indirect mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mbuf to be unlinked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(m) if it is the last reference. It can be recycled or freed.</li>
<li>(NULL) if the mbuf still has remaining references on it. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01329">1329</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a006ee80357a78fbb9ada2b0432f82f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006ee80357a78fbb9ada2b0432f82f37">&#9670;&nbsp;</a></span>rte_pktmbuf_free_seg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_pktmbuf_free_seg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a segment of a packet mbuf into its original mempool.</p>
<p>Free an mbuf, without parsing other segments in case of chained buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf segment to be freed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01381">1381</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a1215458932900b7cd5192326fa4a6902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1215458932900b7cd5192326fa4a6902">&#9670;&nbsp;</a></span>rte_pktmbuf_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a packet mbuf back into its original mempool.</p>
<p>Free an mbuf, and all its segments in case of chained buffers. Each segment is added back into its original mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf to be freed. If NULL, the function does nothing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a21">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2bond_2main_8c-example.html#a51">examples/bond/main.c</a>, <a class="el" href="examples_2distributor_2main_8c-example.html#a44">examples/distributor/main.c</a>, <a class="el" href="examples_2fips_validation_2fips_dev_self_test_8c-example.html#a80">examples/fips_validation/fips_dev_self_test.c</a>, <a class="el" href="examples_2fips_validation_2main_8c-example.html#a24">examples/fips_validation/main.c</a>, <a class="el" href="examples_2flow_classify_2flow_classify_8c-example.html#a51">examples/flow_classify/flow_classify.c</a>, <a class="el" href="examples_2flow_filtering_2main_8c-example.html#a10">examples/flow_filtering/main.c</a>, <a class="el" href="examples_2ip_fragmentation_2main_8c-example.html#a15">examples/ip_fragmentation/main.c</a>, <a class="el" href="examples_2ip_reassembly_2main_8c-example.html#a18">examples/ip_reassembly/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec_process_8c-example.html#a1">examples/ipsec-secgw/ipsec_process.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec_worker_8c-example.html#a33">examples/ipsec-secgw/ipsec_worker.c</a>, <a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a16">examples/ipv4_multicast/main.c</a>, <a class="el" href="examples_2kni_2main_8c-example.html#a10">examples/kni/main.c</a>, <a class="el" href="examples_2l2fwd-cat_2l2fwd-cat_8c-example.html#a24">examples/l2fwd-cat/l2fwd-cat.c</a>, <a class="el" href="examples_2l2fwd-crypto_2main_8c-example.html#a15">examples/l2fwd-crypto/main.c</a>, <a class="el" href="examples_2l3fwd-acl_2main_8c-example.html#a39">examples/l3fwd-acl/main.c</a>, <a class="el" href="examples_2l3fwd-power_2main_8c-example.html#a60">examples/l3fwd-power/main.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_em_8c-example.html#a47">examples/l3fwd/l3fwd_em.c</a>, <a class="el" href="examples_2l3fwd_2l3fwd_lpm_8c-example.html#a31">examples/l3fwd/l3fwd_lpm.c</a>, <a class="el" href="examples_2multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a2">examples/multi_process/client_server_mp/mp_client/client.c</a>, <a class="el" href="examples_2multi_process_2client_server_mp_2mp_server_2main_8c-example.html#a11">examples/multi_process/client_server_mp/mp_server/main.c</a>, <a class="el" href="examples_2multi_process_2symmetric_mp_2main_8c-example.html#a35">examples/multi_process/symmetric_mp/main.c</a>, <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a21">examples/ntb/ntb_fwd.c</a>, <a class="el" href="examples_2packet_ordering_2main_8c-example.html#a6">examples/packet_ordering/main.c</a>, <a class="el" href="examples_2performance-thread_2l3fwd-thread_2main_8c-example.html#a37">examples/performance-thread/l3fwd-thread/main.c</a>, <a class="el" href="examples_2ptpclient_2ptpclient_8c-example.html#a53">examples/ptpclient/ptpclient.c</a>, <a class="el" href="examples_2qos_meter_2main_8c-example.html#a24">examples/qos_meter/main.c</a>, <a class="el" href="examples_2qos_sched_2app_thread_8c-example.html#a10">examples/qos_sched/app_thread.c</a>, <a class="el" href="examples_2rxtx_callbacks_2main_8c-example.html#a42">examples/rxtx_callbacks/main.c</a>, <a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a2">examples/server_node_efd/node/node.c</a>, <a class="el" href="examples_2server_node_efd_2server_2main_8c-example.html#a10">examples/server_node_efd/server/main.c</a>, <a class="el" href="examples_2skeleton_2basicfwd_8c-example.html#a30">examples/skeleton/basicfwd.c</a>, <a class="el" href="examples_2vhost_2main_8c-example.html#a55">examples/vhost/main.c</a>, <a class="el" href="examples_2vhost_2virtio_net_8c-example.html#a24">examples/vhost/virtio_net.c</a>, <a class="el" href="examples_2vmdq_2main_8c-example.html#a50">examples/vmdq/main.c</a>, and <a class="el" href="examples_2vmdq_dcb_2main_8c-example.html#a58">examples/vmdq_dcb/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01397">1397</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a870d6b87464bbc3a6514f7edf1386a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870d6b87464bbc3a6514f7edf1386a09">&#9670;&nbsp;</a></span>rte_pktmbuf_free_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental void rte_pktmbuf_free_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>mbufs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a bulk of packet mbufs back into their original mempools.</p>
<p>Free a bulk of mbufs, and all their segments in case of chained buffers. Each segment is added back into its original mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mbufs</td><td>Array of pointers to packet mbufs. The array may contain NULL pointers. </td></tr>
    <tr><td class="paramname">count</td><td>Array size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f1a5320fb96ff8c1a44be0aaec93856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1a5320fb96ff8c1a44be0aaec93856">&#9670;&nbsp;</a></span>rte_pktmbuf_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pktmbuf_clone </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>md</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a "clone" of the given packet mbuf.</p>
<p>Walks through all segments of the given packet mbuf, and for each of them:</p><ul>
<li>Creates a new packet mbuf from the given pool.</li>
<li>Attaches newly created mbuf to the segment. Then updates pkt_len and nb_segs of the "clone" packet mbuf to match values from the original packet mbuf.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">md</td><td>The packet mbuf to be cloned. </td></tr>
    <tr><td class="paramname">mp</td><td>The mempool from which the "clone" mbufs are allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The pointer to the new "clone" mbuf on success.</li>
<li>NULL if allocation fails. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a18">examples/ipv4_multicast/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a04f6ba3f0f9afe72e21e3a3f8908e6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f6ba3f0f9afe72e21e3a3f8908e6ae">&#9670;&nbsp;</a></span>rte_pktmbuf_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pktmbuf_copy </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a full copy of a given packet mbuf.</p>
<p>Copies all the data from a given packet mbuf to a newly allocated set of mbufs. The private data are is not copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf to be copiedd. </td></tr>
    <tr><td class="paramname">mp</td><td>The mempool from which the "clone" mbufs are allocated. </td></tr>
    <tr><td class="paramname">offset</td><td>The number of bytes to skip before copying. If the mbuf does not have that many bytes, it is an error and NULL is returned. </td></tr>
    <tr><td class="paramname">length</td><td>The upper limit on bytes to copy. Passing UINT32_MAX means all data (after offset). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The pointer to the new "clone" mbuf on success.</li>
<li>NULL if allocation fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7ac5629940550649a2ef40029f5ad21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac5629940550649a2ef40029f5ad21a">&#9670;&nbsp;</a></span>rte_pktmbuf_refcnt_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_refcnt_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds given value to the refcnt of all packet mbuf segments.</p>
<p>Walks through all segments of given packet mbuf and for each of them invokes <a class="el" href="rte__mbuf_8h.html#abb7eb5fa1599b7f6237040b95d8893de">rte_mbuf_refcnt_update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf whose refcnt to be updated. </td></tr>
    <tr><td class="paramname">v</td><td>The value to add to the mbuf's segments refcnt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a38">examples/ipv4_multicast/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01483">1483</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a2a67c1b6a6b7c07e488d5fed7b03502d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a67c1b6a6b7c07e488d5fed7b03502d">&#9670;&nbsp;</a></span>rte_pktmbuf_headroom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_pktmbuf_headroom </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the headroom in a packet mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the headroom. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01500">1500</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a257bc8af3e8fde7eb6603bdf4ae0528e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257bc8af3e8fde7eb6603bdf4ae0528e">&#9670;&nbsp;</a></span>rte_pktmbuf_tailroom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_pktmbuf_tailroom </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the tailroom of a packet mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the tailroom. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2vhost_2main_8c-example.html#a82">examples/vhost/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01514">1514</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a0c2d001cd113362dd123d663210afcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2d001cd113362dd123d663210afcbb">&#9670;&nbsp;</a></span>rte_pktmbuf_lastseg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pktmbuf_lastseg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the last segment of the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last segment of the given mbuf. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01529">1529</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="aadf5bef4ceb0b76dfafff0895f285ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf5bef4ceb0b76dfafff0895f285ab0">&#9670;&nbsp;</a></span>rte_pktmbuf_prepend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* rte_pktmbuf_prepend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepend len bytes to an mbuf data area.</p>
<p>Returns a pointer to the new data start address. If there is not enough headroom in the first segment, the function will return NULL, without modifying the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pkt mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data to prepend (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the start of the newly prepended data, or NULL if there is not enough headroom space in the first segment </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ip_fragmentation_2main_8c-example.html#a37">examples/ip_fragmentation/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2esp_8c-example.html#a50">examples/ipsec-secgw/esp.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a52">examples/ipsec-secgw/ipsec-secgw.c</a>, and <a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a25">examples/ipv4_multicast/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01572">1572</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ad5b0cd686ad3bcbb83416ca8395a080b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b0cd686ad3bcbb83416ca8395a080b">&#9670;&nbsp;</a></span>rte_pktmbuf_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* rte_pktmbuf_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append len bytes to an mbuf.</p>
<p>Append len bytes to an mbuf and return a pointer to the start address of the added data. If there is not enough tailroom in the last segment, the function will return NULL, without modifying the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data to append (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the start of the newly appended data, or NULL if there is not enough tailroom space in the last segment </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a35">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2fips_validation_2fips_dev_self_test_8c-example.html#a56">examples/fips_validation/fips_dev_self_test.c</a>, <a class="el" href="examples_2fips_validation_2main_8c-example.html#a40">examples/fips_validation/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2esp_8c-example.html#a48">examples/ipsec-secgw/esp.c</a>, and <a class="el" href="examples_2l2fwd-crypto_2main_8c-example.html#a35">examples/l2fwd-crypto/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01605">1605</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a1bbd752194759ce7b419c4998f2e8651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbd752194759ce7b419c4998f2e8651">&#9670;&nbsp;</a></span>rte_pktmbuf_adj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* rte_pktmbuf_adj </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove len bytes at the beginning of an mbuf.</p>
<p>Returns a pointer to the start address of the new data area. If the length is greater than the length of the first segment, then the function will fail and return NULL, without modifying the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data to remove (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new start of the data. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ip_fragmentation_2main_8c-example.html#a20">examples/ip_fragmentation/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2esp_8c-example.html#a44">examples/ipsec-secgw/esp.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a29">examples/ipsec-secgw/ipsec-secgw.c</a>, and <a class="el" href="examples_2ipv4_multicast_2main_8c-example.html#a33">examples/ipv4_multicast/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01636">1636</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="abe1bed439015acec170d1342e8dabb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1bed439015acec170d1342e8dabb3b">&#9670;&nbsp;</a></span>rte_pktmbuf_trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_pktmbuf_trim </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove len bytes of data at the end of the mbuf.</p>
<p>If the length is greater than the length of the last segment, the function will fail and return -1 without modifying the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data to remove (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: On success.</li>
<li>-1: On error. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a65">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2ipsec-secgw_2esp_8c-example.html#a42">examples/ipsec-secgw/esp.c</a>, and <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a18">examples/ipsec-secgw/ipsec-secgw.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01666">1666</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a511a116ae4822037d4f1fb561aa4ffcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511a116ae4822037d4f1fb561aa4ffcf">&#9670;&nbsp;</a></span>rte_pktmbuf_is_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_pktmbuf_is_contiguous </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if mbuf data is contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1, if all data is contiguous (one segment).</li>
<li>0, if there is several segments. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01690">1690</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a1f96a031626331434a041ea2a694c3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f96a031626331434a041ea2a694c3a9">&#9670;&nbsp;</a></span>rte_pktmbuf_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const void* rte_pktmbuf_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read len data bytes in a mbuf at specified offset.</p>
<p>If the data is contiguous, return the pointer in the mbuf data, else copy the data in the buffer provided by the user and return its pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pointer to the mbuf. </td></tr>
    <tr><td class="paramname">off</td><td>The offset of the data in the mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of bytes to read. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer where data is copied if it is not contiguous in mbuf data. Its length should be at least equal to the len parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the data, either in the mbuf if it is contiguous, or in the user buffer. If mbuf is too small, NULL is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01722">1722</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="af52dbeb3951f5b90259d3760128ee139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52dbeb3951f5b90259d3760128ee139">&#9670;&nbsp;</a></span>rte_pktmbuf_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_pktmbuf_chain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Chain an mbuf to another, thereby creating a segmented packet.</p>
<p>Note: The implementation will do a linear walk over the segments to find the tail entry. For cases when there are many segments, it's better to chain the entries manually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>The head of the mbuf chain (the first packet) </td></tr>
    <tr><td class="paramname">tail</td><td>The mbuf to put last in the chain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0, on success.</li>
<li>-EOVERFLOW, if the chain segment limit exceeded </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2fips_validation_2main_8c-example.html#a41">examples/fips_validation/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01747">1747</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="adc0bad278c24fa14a0013d3b135305cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0bad278c24fa14a0013d3b135305cc">&#9670;&nbsp;</a></span>rte_validate_tx_offload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_validate_tx_offload </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Validate general requirements for Tx offload in mbuf.</p>
<p>This function checks correctness and completeness of Tx offload settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf to be validated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if packet is valid </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01820">1820</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a9cbca9abd7fb09025afa5d39195ed92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbca9abd7fb09025afa5d39195ed92f">&#9670;&nbsp;</a></span>rte_pktmbuf_linearize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_pktmbuf_linearize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mbuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Linearize data in mbuf.</p>
<p>This function moves the mbuf data in the first segment if there is enough tailroom. The subsequent segments are unchained and freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mbuf</td><td>mbuf to linearize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0, on success</li>
<li>-1, on error </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01870">1870</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a92788c9769a5561814c77ae2e6f65e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92788c9769a5561814c77ae2e6f65e7e">&#9670;&nbsp;</a></span>rte_pktmbuf_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_pktmbuf_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dump_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump an mbuf structure to a file.</p>
<p>Dump all fields for the given packet mbuf and all its associated segments (in the case of a chained buffer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">dump_len</td><td>If dump_len != 0, also dump the "dump_len" first data bytes of the packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bpf_2t3_8c-example.html#a0">examples/bpf/t3.c</a>.</dd>
</dl>

</div>
</div>
<a id="a2ce660cdc41182fb90a773afbe01c3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce660cdc41182fb90a773afbe01c3a2">&#9670;&nbsp;</a></span>rte_mbuf_sched_queue_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t rte_mbuf_sched_queue_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value of mbuf sched queue_id field. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01897">1897</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ab925c715105cfd2642c77c02d51ae652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab925c715105cfd2642c77c02d51ae652">&#9670;&nbsp;</a></span>rte_mbuf_sched_traffic_class_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t rte_mbuf_sched_traffic_class_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value of mbuf sched traffic_class field. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01906">1906</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="af1af0267951d4e655098e32f8a1c9299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1af0267951d4e655098e32f8a1c9299">&#9670;&nbsp;</a></span>rte_mbuf_sched_color_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t rte_mbuf_sched_color_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value of mbuf sched color field. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01915">1915</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a68c580502fb09bbb9483cb929d588d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c580502fb09bbb9483cb929d588d9a">&#9670;&nbsp;</a></span>rte_mbuf_sched_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_sched_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>traffic_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the values of mbuf sched queue_id, traffic_class and color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Mbuf to read </td></tr>
    <tr><td class="paramname">queue_id</td><td>Returns the queue id </td></tr>
    <tr><td class="paramname">traffic_class</td><td>Returns the traffic class id </td></tr>
    <tr><td class="paramname">color</td><td>Returns the colour id </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01933">1933</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ac42323fb1b451b4916459234fb090a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42323fb1b451b4916459234fb090a5a">&#9670;&nbsp;</a></span>rte_mbuf_sched_queue_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_sched_queue_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mbuf sched queue_id to the defined value. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01948">1948</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="ad2c3400feaf54325b0d6232b94397fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c3400feaf54325b0d6232b94397fe7">&#9670;&nbsp;</a></span>rte_mbuf_sched_traffic_class_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_sched_traffic_class_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>traffic_class</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mbuf sched traffic_class id to the defined value. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01957">1957</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a50d2b8433bf0499911ec438a912cfcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d2b8433bf0499911ec438a912cfcba">&#9670;&nbsp;</a></span>rte_mbuf_sched_color_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_sched_color_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mbuf sched color id to the defined value. </p>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01966">1966</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
<a id="a4a6c4280b6708d3fef269a0992930885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6c4280b6708d3fef269a0992930885">&#9670;&nbsp;</a></span>rte_mbuf_sched_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_sched_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>traffic_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mbuf sched queue_id, traffic_class and color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Mbuf to set </td></tr>
    <tr><td class="paramname">queue_id</td><td>Queue id value to be set </td></tr>
    <tr><td class="paramname">traffic_class</td><td>Traffic class id value to be set </td></tr>
    <tr><td class="paramname">color</td><td>Color id to be set </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mbuf_8h_source.html#l01984">1984</a> of file <a class="el" href="rte__mbuf_8h_source.html">rte_mbuf.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
