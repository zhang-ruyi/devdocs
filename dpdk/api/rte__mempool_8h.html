<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_mempool/rte_mempool.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_ede7e24c7966ae13eacb9e9d5c8994f5.html">librte_mempool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rte_mempool.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;sys/queue.h&gt;</code><br />
<code>#include &lt;rte_config.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__spinlock_8h_source.html">rte_spinlock.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__log_8h_source.html">rte_log.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__debug_8h_source.html">rte_debug.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__lcore_8h_source.html">rte_lcore.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__branch__prediction_8h_source.html">rte_branch_prediction.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memcpy_8h_source.html">rte_memcpy.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__mempool__trace__fp_8h_source.html">rte_mempool_trace_fp.h</a>&quot;</code><br />
</div>
<p><a href="rte__mempool_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__objsz.html">rte_mempool_objsz</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__objhdr.html">rte_mempool_objhdr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__memhdr.html">rte_mempool_memhdr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__info.html">rte_mempool_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool.html">rte_mempool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__ops.html">rte_mempool_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool__ops__table.html">rte_mempool_ops_table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ace39cb6a7415a12e81e534c084eaffae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ace39cb6a7415a12e81e534c084eaffae">RTE_MEMPOOL_HEADER_COOKIE1</a>&#160;&#160;&#160;0xbadbadbadadd2e55ULL</td></tr>
<tr class="separator:ace39cb6a7415a12e81e534c084eaffae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734531a6320af1bd65287929672b5dd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a734531a6320af1bd65287929672b5dd7">RTE_MEMPOOL_HEADER_COOKIE2</a>&#160;&#160;&#160;0xf2eef2eedadd2e55ULL</td></tr>
<tr class="separator:a734531a6320af1bd65287929672b5dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6419c9ccd761d970b756c37e25d72dd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6419c9ccd761d970b756c37e25d72dd7">RTE_MEMPOOL_TRAILER_COOKIE</a>&#160;&#160;&#160;0xadd2e55badbadbadULL</td></tr>
<tr class="separator:a6419c9ccd761d970b756c37e25d72dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0648fad3d8d844ccf917cbebe9f741"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a2f0648fad3d8d844ccf917cbebe9f741">MEMPOOL_PG_NUM_DEFAULT</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a2f0648fad3d8d844ccf917cbebe9f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac889c96bedc6bf9b1e228a111a679d59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ac889c96bedc6bf9b1e228a111a679d59">RTE_MEMPOOL_ALIGN</a>&#160;&#160;&#160;RTE_CACHE_LINE_SIZE</td></tr>
<tr class="separator:ac889c96bedc6bf9b1e228a111a679d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2274675362f7964be2bc499e55782eb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a2274675362f7964be2bc499e55782eb5">MEMPOOL_F_NO_SPREAD</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a2274675362f7964be2bc499e55782eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b50b6c6c3a097d768c8337d146caa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a7f4b50b6c6c3a097d768c8337d146caa">MEMPOOL_F_NO_CACHE_ALIGN</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a7f4b50b6c6c3a097d768c8337d146caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee48ca768ddf8494f6618ca54e2e84e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aee48ca768ddf8494f6618ca54e2e84e9">MEMPOOL_F_SP_PUT</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:aee48ca768ddf8494f6618ca54e2e84e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08a019547fb3968e73aab0dafefc069"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ab08a019547fb3968e73aab0dafefc069">MEMPOOL_F_SC_GET</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:ab08a019547fb3968e73aab0dafefc069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021f350ce257925be709ff73d2cbeac5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a021f350ce257925be709ff73d2cbeac5">MEMPOOL_F_POOL_CREATED</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="separator:a021f350ce257925be709ff73d2cbeac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dd9389dfa42c8020b1b469d2fe45ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aa0dd9389dfa42c8020b1b469d2fe45ae">MEMPOOL_F_NO_IOVA_CONTIG</a>&#160;&#160;&#160;0x0020</td></tr>
<tr class="separator:aa0dd9389dfa42c8020b1b469d2fe45ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf26ef1d39214774aaa353c85c26378d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#abf26ef1d39214774aaa353c85c26378d">MEMPOOL_HEADER_SIZE</a>(mp,  cs)</td></tr>
<tr class="separator:abf26ef1d39214774aaa353c85c26378d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d198cc75927ad4b9aafb6943ebc455"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aa1d198cc75927ad4b9aafb6943ebc455">RTE_MEMPOOL_OPS_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:aa1d198cc75927ad4b9aafb6943ebc455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa2d00b15fbdf7cf5433f23681dc168"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#acaa2d00b15fbdf7cf5433f23681dc168">RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:acaa2d00b15fbdf7cf5433f23681dc168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a6f557bd89248b41b088b22af83e3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ad2a6f557bd89248b41b088b22af83e3b">RTE_MEMPOOL_MAX_OPS_IDX</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ad2a6f557bd89248b41b088b22af83e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134755e2933fe944f5e45a2f7855af48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a134755e2933fe944f5e45a2f7855af48">MEMPOOL_REGISTER_OPS</a>(ops)</td></tr>
<tr class="separator:a134755e2933fe944f5e45a2f7855af48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a024fe092ff5209fbb37e15197b12628e"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a024fe092ff5209fbb37e15197b12628e">rte_mempool_memchunk_free_cb_t</a>(struct <a class="el" href="structrte__mempool__memhdr.html">rte_mempool_memhdr</a> *memhdr, void *opaque)</td></tr>
<tr class="separator:a024fe092ff5209fbb37e15197b12628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889a701bfd28d316cc37bad4370577ac"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a889a701bfd28d316cc37bad4370577ac">rte_mempool_alloc_t</a>) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a889a701bfd28d316cc37bad4370577ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e11016030c9e1ebe4b6beaf0c5f224"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a58e11016030c9e1ebe4b6beaf0c5f224">rte_mempool_free_t</a>) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a58e11016030c9e1ebe4b6beaf0c5f224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2aa01871366bf7c6c36ded20ac12d4"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a1b2aa01871366bf7c6c36ded20ac12d4">rte_mempool_enqueue_t</a>) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *const *obj_table, unsigned int n)</td></tr>
<tr class="separator:a1b2aa01871366bf7c6c36ded20ac12d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddcd76bd4cc7a950787abaa71536cea"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a2ddcd76bd4cc7a950787abaa71536cea">rte_mempool_dequeue_t</a>) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_table, unsigned int n)</td></tr>
<tr class="separator:a2ddcd76bd4cc7a950787abaa71536cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585600ff1c0f2b874f636774b0417d70"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a585600ff1c0f2b874f636774b0417d70">rte_mempool_dequeue_contig_blocks_t</a>) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **first_obj_table, unsigned int n)</td></tr>
<tr class="separator:a585600ff1c0f2b874f636774b0417d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca98d81d5a0cdcf4fdf38f42bebb67"><td class="memItemLeft" align="right" valign="top">typedef unsigned(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a39ca98d81d5a0cdcf4fdf38f42bebb67">rte_mempool_get_count</a>) (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a39ca98d81d5a0cdcf4fdf38f42bebb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba877885cd822800f774204536d5495"><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aaba877885cd822800f774204536d5495">rte_mempool_calc_mem_size_t</a>) (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, uint32_t obj_num, uint32_t pg_shift, size_t *min_chunk_size, size_t *align)</td></tr>
<tr class="separator:aaba877885cd822800f774204536d5495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b33d8ef0ee40e9fb64fec3924bf8539"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a3b33d8ef0ee40e9fb64fec3924bf8539">rte_mempool_populate_obj_cb_t</a>(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque, void *vaddr, <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> iova)</td></tr>
<tr class="separator:a3b33d8ef0ee40e9fb64fec3924bf8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd42fb234bcce98f482034ab1fbf1e4"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aecd42fb234bcce98f482034ab1fbf1e4">rte_mempool_populate_t</a>) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, unsigned int max_objs, void *vaddr, <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> iova, size_t len, <a class="el" href="rte__mempool_8h.html#a3b33d8ef0ee40e9fb64fec3924bf8539">rte_mempool_populate_obj_cb_t</a> *obj_cb, void *obj_cb_arg)</td></tr>
<tr class="separator:aecd42fb234bcce98f482034ab1fbf1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbf16bfdfda24d9ebbfc19047d15012"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#afcbf16bfdfda24d9ebbfc19047d15012">rte_mempool_get_info_t</a>) (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, struct <a class="el" href="structrte__mempool__info.html">rte_mempool_info</a> *info)</td></tr>
<tr class="separator:afcbf16bfdfda24d9ebbfc19047d15012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127321ad7ff30d88414f6943a857ae3d"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a127321ad7ff30d88414f6943a857ae3d">rte_mempool_obj_cb_t</a>(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque, void *obj, unsigned obj_idx)</td></tr>
<tr class="separator:a127321ad7ff30d88414f6943a857ae3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57a7bf9eb8320cf38377d192a2ffb90"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aa57a7bf9eb8320cf38377d192a2ffb90">rte_mempool_mem_cb_t</a>(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque, struct <a class="el" href="structrte__mempool__memhdr.html">rte_mempool_memhdr</a> *memhdr, unsigned mem_idx)</td></tr>
<tr class="separator:aa57a7bf9eb8320cf38377d192a2ffb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29fcb33f12181ad2cb0729dfd547736"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aa29fcb33f12181ad2cb0729dfd547736">rte_mempool_ctor_t</a>(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *)</td></tr>
<tr class="separator:aa29fcb33f12181ad2cb0729dfd547736"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5ce49691d0b20e30b530abf468632d20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a5ce49691d0b20e30b530abf468632d20">STAILQ_HEAD</a> (rte_mempool_objhdr_list, <a class="el" href="structrte__mempool__objhdr.html">rte_mempool_objhdr</a>)</td></tr>
<tr class="separator:a5ce49691d0b20e30b530abf468632d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc480abc8d46500a80241926f53d897a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#afc480abc8d46500a80241926f53d897a">STAILQ_HEAD</a> (rte_mempool_memhdr_list, <a class="el" href="structrte__mempool__memhdr.html">rte_mempool_memhdr</a>)</td></tr>
<tr class="separator:afc480abc8d46500a80241926f53d897a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1ffc62a2fcc1ac728158ad2b177d0a"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a9b1ffc62a2fcc1ac728158ad2b177d0a">rte_mempool_from_obj</a> (void *obj)</td></tr>
<tr class="separator:a9b1ffc62a2fcc1ac728158ad2b177d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6febb6f6c1468c055210f257363bc3f4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6febb6f6c1468c055210f257363bc3f4">rte_mempool_op_calc_mem_size_default</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, uint32_t obj_num, uint32_t pg_shift, size_t *min_chunk_size, size_t *align)</td></tr>
<tr class="separator:a6febb6f6c1468c055210f257363bc3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108419b63ad6476c47d87ea5e20f0925"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a108419b63ad6476c47d87ea5e20f0925">rte_mempool_op_populate_default</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, unsigned int max_objs, void *vaddr, <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> iova, size_t len, <a class="el" href="rte__mempool_8h.html#a3b33d8ef0ee40e9fb64fec3924bf8539">rte_mempool_populate_obj_cb_t</a> *obj_cb, void *obj_cb_arg)</td></tr>
<tr class="separator:a108419b63ad6476c47d87ea5e20f0925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ed5da907156a7a63569512f5b9e04d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ab2ed5da907156a7a63569512f5b9e04d">rte_mempool_ops_get_info</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, struct <a class="el" href="structrte__mempool__info.html">rte_mempool_info</a> *info)</td></tr>
<tr class="separator:ab2ed5da907156a7a63569512f5b9e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d43951645ad4c11a3d88e3d7664aa9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a04d43951645ad4c11a3d88e3d7664aa9">rte_mempool_set_ops_byname</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, const char *name, void *pool_config)</td></tr>
<tr class="separator:a04d43951645ad4c11a3d88e3d7664aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6365f00c9b5f23dedcc585b6fa8354e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6365f00c9b5f23dedcc585b6fa8354e8">rte_mempool_register_ops</a> (const struct <a class="el" href="structrte__mempool__ops.html">rte_mempool_ops</a> *ops)</td></tr>
<tr class="separator:a6365f00c9b5f23dedcc585b6fa8354e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503f2f889043a48ca9995878846db2fd"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create</a> (const char *name, unsigned n, unsigned elt_size, unsigned cache_size, unsigned private_data_size, <a class="el" href="rte__mempool_8h.html#aa29fcb33f12181ad2cb0729dfd547736">rte_mempool_ctor_t</a> *mp_init, void *mp_init_arg, <a class="el" href="rte__mempool_8h.html#a127321ad7ff30d88414f6943a857ae3d">rte_mempool_obj_cb_t</a> *obj_init, void *obj_init_arg, int socket_id, unsigned flags)</td></tr>
<tr class="separator:a503f2f889043a48ca9995878846db2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542ec0f29072e7f1cfdb5c150f57b236"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a542ec0f29072e7f1cfdb5c150f57b236">rte_mempool_create_empty</a> (const char *name, unsigned n, unsigned elt_size, unsigned cache_size, unsigned private_data_size, int socket_id, unsigned flags)</td></tr>
<tr class="separator:a542ec0f29072e7f1cfdb5c150f57b236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35271bce2d546e116074803fd69376e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a35271bce2d546e116074803fd69376e9">rte_mempool_free</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a35271bce2d546e116074803fd69376e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3522d5f027567081122f31e4d4cfe3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ac3522d5f027567081122f31e4d4cfe3b">rte_mempool_populate_iova</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, char *vaddr, <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> iova, size_t len, <a class="el" href="rte__mempool_8h.html#a024fe092ff5209fbb37e15197b12628e">rte_mempool_memchunk_free_cb_t</a> *free_cb, void *opaque)</td></tr>
<tr class="separator:ac3522d5f027567081122f31e4d4cfe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cafcc36eef66ff8ccc3300c3bd92cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a64cafcc36eef66ff8ccc3300c3bd92cf">rte_mempool_populate_virt</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, char *addr, size_t len, size_t pg_sz, <a class="el" href="rte__mempool_8h.html#a024fe092ff5209fbb37e15197b12628e">rte_mempool_memchunk_free_cb_t</a> *free_cb, void *opaque)</td></tr>
<tr class="separator:a64cafcc36eef66ff8ccc3300c3bd92cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e463ccfc2e40cca2836137ea737d8a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a4e463ccfc2e40cca2836137ea737d8a8">rte_mempool_populate_default</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a4e463ccfc2e40cca2836137ea737d8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7101e2157c9082f095d2ed5993e42117"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a7101e2157c9082f095d2ed5993e42117">rte_mempool_populate_anon</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a7101e2157c9082f095d2ed5993e42117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4bec335c01bac3d695beffb5a28690"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#abd4bec335c01bac3d695beffb5a28690">rte_mempool_obj_iter</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, <a class="el" href="rte__mempool_8h.html#a127321ad7ff30d88414f6943a857ae3d">rte_mempool_obj_cb_t</a> *obj_cb, void *obj_cb_arg)</td></tr>
<tr class="separator:abd4bec335c01bac3d695beffb5a28690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7641e4bb5161d53543d3bd4c3d9e85a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ad7641e4bb5161d53543d3bd4c3d9e85a">rte_mempool_mem_iter</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, <a class="el" href="rte__mempool_8h.html#aa57a7bf9eb8320cf38377d192a2ffb90">rte_mempool_mem_cb_t</a> *mem_cb, void *mem_cb_arg)</td></tr>
<tr class="separator:ad7641e4bb5161d53543d3bd4c3d9e85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dd70a2377f35d89b046655ba5c6cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a89dd70a2377f35d89b046655ba5c6cf9">rte_mempool_dump</a> (FILE *f, struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a89dd70a2377f35d89b046655ba5c6cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9029f1e9d69b5e0105ab597225ee3f2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ab9029f1e9d69b5e0105ab597225ee3f2">rte_mempool_cache_create</a> (uint32_t size, int socket_id)</td></tr>
<tr class="separator:ab9029f1e9d69b5e0105ab597225ee3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84393d11b18ee2aa436ca856ad10ecca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a84393d11b18ee2aa436ca856ad10ecca">rte_mempool_cache_free</a> (struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *cache)</td></tr>
<tr class="separator:a84393d11b18ee2aa436ca856ad10ecca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0929bd6e5dbc455f4c659be4fbf966"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aed0929bd6e5dbc455f4c659be4fbf966">rte_mempool_default_cache</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, unsigned lcore_id)</td></tr>
<tr class="separator:aed0929bd6e5dbc455f4c659be4fbf966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca812ec68a5e3de153b772415977301"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a5ca812ec68a5e3de153b772415977301">rte_mempool_cache_flush</a> (struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *cache, struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a5ca812ec68a5e3de153b772415977301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a921213eb20cdc0f92e20fff7457df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a84a921213eb20cdc0f92e20fff7457df">rte_mempool_generic_put</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *const *obj_table, unsigned int n, struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *cache)</td></tr>
<tr class="separator:a84a921213eb20cdc0f92e20fff7457df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e46fc827d764e516e8ff0c3f00e33fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a5e46fc827d764e516e8ff0c3f00e33fc">rte_mempool_put_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *const *obj_table, unsigned int n)</td></tr>
<tr class="separator:a5e46fc827d764e516e8ff0c3f00e33fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0989ddd8b037416c8c3544c9d8b8106"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ab0989ddd8b037416c8c3544c9d8b8106">rte_mempool_put</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *obj)</td></tr>
<tr class="separator:ab0989ddd8b037416c8c3544c9d8b8106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c731b5204a5736134f9f688868df245"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a8c731b5204a5736134f9f688868df245">rte_mempool_generic_get</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_table, unsigned int n, struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *cache)</td></tr>
<tr class="separator:a8c731b5204a5736134f9f688868df245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d326354d53ef5068d86a8b7d9ec2d61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a0d326354d53ef5068d86a8b7d9ec2d61">rte_mempool_get_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_table, unsigned int n)</td></tr>
<tr class="separator:a0d326354d53ef5068d86a8b7d9ec2d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6150c041e889498a08d0e0d0769292cb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6150c041e889498a08d0e0d0769292cb">rte_mempool_get</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_p)</td></tr>
<tr class="separator:a6150c041e889498a08d0e0d0769292cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563f242367bf6533fe2d4ce7a0411848"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a563f242367bf6533fe2d4ce7a0411848">rte_mempool_get_contig_blocks</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **first_obj_table, unsigned int n)</td></tr>
<tr class="separator:a563f242367bf6533fe2d4ce7a0411848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505a815fc46e027a0a2054df124bc514"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a505a815fc46e027a0a2054df124bc514">rte_mempool_avail_count</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a505a815fc46e027a0a2054df124bc514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce09dff484b6726ced4da3bbe3b2e55"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#abce09dff484b6726ced4da3bbe3b2e55">rte_mempool_in_use_count</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:abce09dff484b6726ced4da3bbe3b2e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a83e5cc7f9d57f154839b1c80992a3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a85a83e5cc7f9d57f154839b1c80992a3">rte_mempool_full</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a85a83e5cc7f9d57f154839b1c80992a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ad83873c9af9bc2012153cd4b4ed52"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ad6ad83873c9af9bc2012153cd4b4ed52">rte_mempool_empty</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:ad6ad83873c9af9bc2012153cd4b4ed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f365fff447d3e46b55590d1da90f30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a20f365fff447d3e46b55590d1da90f30">rte_mempool_virt2iova</a> (const void *elt)</td></tr>
<tr class="separator:a20f365fff447d3e46b55590d1da90f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd7e5570903fc76c16ad8d2b05adde5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a9fd7e5570903fc76c16ad8d2b05adde5">rte_mempool_audit</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a9fd7e5570903fc76c16ad8d2b05adde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b794c0cd2a78c74817b250becf981fc"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6b794c0cd2a78c74817b250becf981fc">rte_mempool_get_priv</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a6b794c0cd2a78c74817b250becf981fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1120319a35b0cf0b23827705b2229a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#acb1120319a35b0cf0b23827705b2229a">rte_mempool_list_dump</a> (FILE *f)</td></tr>
<tr class="separator:acb1120319a35b0cf0b23827705b2229a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5887135fc6329a35780b0053e769ad"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a3a5887135fc6329a35780b0053e769ad">rte_mempool_lookup</a> (const char *name)</td></tr>
<tr class="separator:a3a5887135fc6329a35780b0053e769ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121d699436738109067ed80a1ecae38f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a121d699436738109067ed80a1ecae38f">rte_mempool_calc_obj_size</a> (uint32_t elt_size, uint32_t flags, struct <a class="el" href="structrte__mempool__objsz.html">rte_mempool_objsz</a> *sz)</td></tr>
<tr class="separator:a121d699436738109067ed80a1ecae38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0de941287fb011e1448c043a145ed8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aa0de941287fb011e1448c043a145ed8d">rte_mempool_walk</a> (void(*func)(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *arg), void *arg)</td></tr>
<tr class="separator:aa0de941287fb011e1448c043a145ed8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad4faf736256b092f327925d45a1db0b1"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool__ops__table.html">rte_mempool_ops_table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ad4faf736256b092f327925d45a1db0b1">rte_mempool_ops_table</a></td></tr>
<tr class="separator:ad4faf736256b092f327925d45a1db0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Mempool.</p>
<p>A memory pool is an allocator of fixed-size object. It is identified by its name, and uses a ring to store free objects. It provides some other optional services, like a per-core object cache, and an alignment helper to ensure that objects are padded to spread them equally on all RAM channels, ranks, and so on.</p>
<p>Objects owned by a mempool should never be added in another mempool. When an object is freed using <a class="el" href="rte__mempool_8h.html#ab0989ddd8b037416c8c3544c9d8b8106">rte_mempool_put()</a> or equivalent, the object data is not modified; the user can save some meta-data in the object data and retrieve them when allocating a new object.</p>
<p>Note: the mempool implementation is not preemptible. An lcore must not be interrupted by another task that uses the same mempool (because it uses a ring which is not preemptible). Also, usual mempool functions like <a class="el" href="rte__mempool_8h.html#a6150c041e889498a08d0e0d0769292cb">rte_mempool_get()</a> or <a class="el" href="rte__mempool_8h.html#ab0989ddd8b037416c8c3544c9d8b8106">rte_mempool_put()</a> are designed to be called from an EAL thread due to the internal per-lcore cache. Due to the lack of caching, <a class="el" href="rte__mempool_8h.html#a6150c041e889498a08d0e0d0769292cb">rte_mempool_get()</a> or <a class="el" href="rte__mempool_8h.html#ab0989ddd8b037416c8c3544c9d8b8106">rte_mempool_put()</a> performance will suffer when called by unregistered non-EAL threads. Instead, unregistered non-EAL threads should call <a class="el" href="rte__mempool_8h.html#a8c731b5204a5736134f9f688868df245">rte_mempool_generic_get()</a> or <a class="el" href="rte__mempool_8h.html#a84a921213eb20cdc0f92e20fff7457df">rte_mempool_generic_put()</a> with a user cache created with <a class="el" href="rte__mempool_8h.html#ab9029f1e9d69b5e0105ab597225ee3f2">rte_mempool_cache_create()</a>. </p>

<p class="definition">Definition in file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ace39cb6a7415a12e81e534c084eaffae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace39cb6a7415a12e81e534c084eaffae">&#9670;&nbsp;</a></span>RTE_MEMPOOL_HEADER_COOKIE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_HEADER_COOKIE1&#160;&#160;&#160;0xbadbadbadadd2e55ULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header cookie. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00060">60</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a734531a6320af1bd65287929672b5dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734531a6320af1bd65287929672b5dd7">&#9670;&nbsp;</a></span>RTE_MEMPOOL_HEADER_COOKIE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_HEADER_COOKIE2&#160;&#160;&#160;0xf2eef2eedadd2e55ULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header cookie. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00061">61</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a6419c9ccd761d970b756c37e25d72dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6419c9ccd761d970b756c37e25d72dd7">&#9670;&nbsp;</a></span>RTE_MEMPOOL_TRAILER_COOKIE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_TRAILER_COOKIE&#160;&#160;&#160;0xadd2e55badbadbadULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trailer cookie. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00062">62</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a2f0648fad3d8d844ccf917cbebe9f741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0648fad3d8d844ccf917cbebe9f741">&#9670;&nbsp;</a></span>MEMPOOL_PG_NUM_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_PG_NUM_DEFAULT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mempool over one chunk of physically continuous memory </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00118">118</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="ac889c96bedc6bf9b1e228a111a679d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac889c96bedc6bf9b1e228a111a679d59">&#9670;&nbsp;</a></span>RTE_MEMPOOL_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_ALIGN&#160;&#160;&#160;RTE_CACHE_LINE_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alignment of elements inside mempool. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00124">124</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a2274675362f7964be2bc499e55782eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2274675362f7964be2bc499e55782eb5">&#9670;&nbsp;</a></span>MEMPOOL_F_NO_SPREAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_NO_SPREAD&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spreading among memory channels not required. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00255">255</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a7f4b50b6c6c3a097d768c8337d146caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4b50b6c6c3a097d768c8337d146caa">&#9670;&nbsp;</a></span>MEMPOOL_F_NO_CACHE_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_NO_CACHE_ALIGN&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not align objs on cache lines. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00256">256</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="aee48ca768ddf8494f6618ca54e2e84e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee48ca768ddf8494f6618ca54e2e84e9">&#9670;&nbsp;</a></span>MEMPOOL_F_SP_PUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_SP_PUT&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default put is "single-producer". </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00257">257</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="ab08a019547fb3968e73aab0dafefc069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08a019547fb3968e73aab0dafefc069">&#9670;&nbsp;</a></span>MEMPOOL_F_SC_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_SC_GET&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default get is "single-consumer". </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00258">258</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a021f350ce257925be709ff73d2cbeac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021f350ce257925be709ff73d2cbeac5">&#9670;&nbsp;</a></span>MEMPOOL_F_POOL_CREATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_POOL_CREATED&#160;&#160;&#160;0x0010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal: pool is created. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00259">259</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="aa0dd9389dfa42c8020b1b469d2fe45ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0dd9389dfa42c8020b1b469d2fe45ae">&#9670;&nbsp;</a></span>MEMPOOL_F_NO_IOVA_CONTIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_NO_IOVA_CONTIG&#160;&#160;&#160;0x0020</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Don't need IOVA contiguous objs. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00260">260</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="abf26ef1d39214774aaa353c85c26378d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf26ef1d39214774aaa353c85c26378d">&#9670;&nbsp;</a></span>MEMPOOL_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_HEADER_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cs&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<span class="keyword">sizeof</span>(*(mp)) + (((cs) == 0) ? 0 : \</div>
<div class="line">    (<span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code" href="structrte__mempool__cache.html">rte_mempool_cache</a>) * RTE_MAX_LCORE)))</div>
</div><!-- fragment --><p>Calculate the size of the mempool header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Pointer to the memory pool. </td></tr>
    <tr><td class="paramname">cs</td><td>Size of the per-lcore cache. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00300">300</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="aa1d198cc75927ad4b9aafb6943ebc455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d198cc75927ad4b9aafb6943ebc455">&#9670;&nbsp;</a></span>RTE_MEMPOOL_OPS_NAMESIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_OPS_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max length of ops struct name. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00386">386</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="acaa2d00b15fbdf7cf5433f23681dc168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa2d00b15fbdf7cf5433f23681dc168">&#9670;&nbsp;</a></span>RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align objects on addresses multiple of total_elt_sz. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00556">556</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="ad2a6f557bd89248b41b088b22af83e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a6f557bd89248b41b088b22af83e3b">&#9670;&nbsp;</a></span>RTE_MEMPOOL_MAX_OPS_IDX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_MAX_OPS_IDX&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max registered ops structs </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00641">641</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a134755e2933fe944f5e45a2f7855af48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134755e2933fe944f5e45a2f7855af48">&#9670;&nbsp;</a></span>MEMPOOL_REGISTER_OPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_REGISTER_OPS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ops</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="rte__common_8h.html#aaa00d0ee0e96206a928be48e6837758c">RTE_INIT</a>(mp_hdlr_init_##ops)                \</div>
<div class="line">    {                           \</div>
<div class="line">        rte_mempool_register_ops(&amp;ops);         \</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Macro to statically register the ops of a mempool handler. Note that the rte_mempool_register_ops fails silently here when more than RTE_MEMPOOL_MAX_OPS_IDX is registered. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00890">890</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a024fe092ff5209fbb37e15197b12628e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024fe092ff5209fbb37e15197b12628e">&#9670;&nbsp;</a></span>rte_mempool_memchunk_free_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() rte_mempool_memchunk_free_cb_t(struct <a class="el" href="structrte__mempool__memhdr.html">rte_mempool_memhdr</a> *memhdr, void *opaque)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback used to free a memory chunk </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00174">174</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a889a701bfd28d316cc37bad4370577ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889a701bfd28d316cc37bad4370577ac">&#9670;&nbsp;</a></span>rte_mempool_alloc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mempool_alloc_t) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype for implementation specific data provisioning function.</p>
<p>The function should provide the implementation specific memory for use by the other mempool ops functions in a given mempool ops struct. E.g. the default ops provides an instance of the <a class="el" href="structrte__ring.html">rte_ring</a> for this purpose. it will most likely point to a different type of data structure, and will be transparent to the application programmer. This function should set mp-&gt;pool_data. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00398">398</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a58e11016030c9e1ebe4b6beaf0c5f224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e11016030c9e1ebe4b6beaf0c5f224">&#9670;&nbsp;</a></span>rte_mempool_free_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_mempool_free_t) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the opaque private data pointed to by mp-&gt;pool_data pointer. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00403">403</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a1b2aa01871366bf7c6c36ded20ac12d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2aa01871366bf7c6c36ded20ac12d4">&#9670;&nbsp;</a></span>rte_mempool_enqueue_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mempool_enqueue_t) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *const *obj_table, unsigned int n)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue an object into the external pool. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00408">408</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a2ddcd76bd4cc7a950787abaa71536cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddcd76bd4cc7a950787abaa71536cea">&#9670;&nbsp;</a></span>rte_mempool_dequeue_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mempool_dequeue_t) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_table, unsigned int n)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequeue an object from the external pool. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00414">414</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a585600ff1c0f2b874f636774b0417d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585600ff1c0f2b874f636774b0417d70">&#9670;&nbsp;</a></span>rte_mempool_dequeue_contig_blocks_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mempool_dequeue_contig_blocks_t) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **first_obj_table, unsigned int n)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dequeue a number of contiguous object blocks from the external pool. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00420">420</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a39ca98d81d5a0cdcf4fdf38f42bebb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ca98d81d5a0cdcf4fdf38f42bebb67">&#9670;&nbsp;</a></span>rte_mempool_get_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned(* rte_mempool_get_count) (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of available objects in the external pool. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00426">426</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="aaba877885cd822800f774204536d5495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba877885cd822800f774204536d5495">&#9670;&nbsp;</a></span>rte_mempool_calc_mem_size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* rte_mempool_calc_mem_size_t) (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, uint32_t obj_num, uint32_t pg_shift, size_t *min_chunk_size, size_t *align)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate memory size required to store given number of objects.</p>
<p>If mempool objects are not required to be IOVA-contiguous (the flag MEMPOOL_F_NO_IOVA_CONTIG is set), min_chunk_size defines virtually contiguous chunk size. Otherwise, if mempool objects must be IOVA-contiguous (the flag MEMPOOL_F_NO_IOVA_CONTIG is clear), min_chunk_size defines IOVA-contiguous chunk size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>Pointer to the memory pool. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj_num</td><td>Number of objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pg_shift</td><td>LOG2 of the physical pages size. If set to 0, ignore page boundaries. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_chunk_size</td><td>Location for minimum size of the memory chunk which may be used to store memory pool objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">align</td><td>Location for required memory chunk alignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required memory size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00451">451</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a3b33d8ef0ee40e9fb64fec3924bf8539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b33d8ef0ee40e9fb64fec3924bf8539">&#9670;&nbsp;</a></span>rte_mempool_populate_obj_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() rte_mempool_populate_obj_cb_t(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque, void *vaddr, <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> iova)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to be called for each populated object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opaque</td><td>An opaque pointer passed to iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vaddr</td><td>Object virtual address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iova</td><td>Input/output virtual address of the object or RTE_BAD_IOVA. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00517">517</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="aecd42fb234bcce98f482034ab1fbf1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd42fb234bcce98f482034ab1fbf1e4">&#9670;&nbsp;</a></span>rte_mempool_populate_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mempool_populate_t) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, unsigned int max_objs, void *vaddr, <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> iova, size_t len, <a class="el" href="rte__mempool_8h.html#a3b33d8ef0ee40e9fb64fec3924bf8539">rte_mempool_populate_obj_cb_t</a> *obj_cb, void *obj_cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate memory pool objects using provided memory chunk.</p>
<p>Populated objects should be enqueued to the pool, e.g. using rte_mempool_ops_enqueue_bulk().</p>
<p>If the given IO address is unknown (iova = RTE_BAD_IOVA), the chunk doesn't need to be physically contiguous (only virtually), and allocated objects may span two pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_objs</td><td>Maximum number of objects to be populated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vaddr</td><td>The virtual address of memory that should be used to store objects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iova</td><td>The IO address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of memory in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj_cb</td><td>Callback function to be executed for each populated object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj_cb_arg</td><td>An opaque pointer passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects added on success. On error, no objects are populated and a negative errno is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00548">548</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="afcbf16bfdfda24d9ebbfc19047d15012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbf16bfdfda24d9ebbfc19047d15012">&#9670;&nbsp;</a></span>rte_mempool_get_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* rte_mempool_get_info_t) (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, struct <a class="el" href="structrte__mempool__info.html">rte_mempool_info</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get some additional information about a mempool. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00609">609</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a127321ad7ff30d88414f6943a857ae3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127321ad7ff30d88414f6943a857ae3d">&#9670;&nbsp;</a></span>rte_mempool_obj_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() rte_mempool_obj_cb_t(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque, void *obj, unsigned obj_idx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An object callback function for mempool.</p>
<p>Used by <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> and <a class="el" href="rte__mempool_8h.html#abd4bec335c01bac3d695beffb5a28690">rte_mempool_obj_iter()</a>. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00901">901</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="aa57a7bf9eb8320cf38377d192a2ffb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57a7bf9eb8320cf38377d192a2ffb90">&#9670;&nbsp;</a></span>rte_mempool_mem_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() rte_mempool_mem_cb_t(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque, struct <a class="el" href="structrte__mempool__memhdr.html">rte_mempool_memhdr</a> *memhdr, unsigned mem_idx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A memory callback function for mempool.</p>
<p>Used by <a class="el" href="rte__mempool_8h.html#ad7641e4bb5161d53543d3bd4c3d9e85a">rte_mempool_mem_iter()</a>. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00910">910</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="aa29fcb33f12181ad2cb0729dfd547736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29fcb33f12181ad2cb0729dfd547736">&#9670;&nbsp;</a></span>rte_mempool_ctor_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() rte_mempool_ctor_t(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A mempool constructor callback function.</p>
<p>Arguments are the mempool and the opaque pointer given by the user in <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a>. </p>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00920">920</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5ce49691d0b20e30b530abf468632d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce49691d0b20e30b530abf468632d20">&#9670;&nbsp;</a></span>STAILQ_HEAD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STAILQ_HEAD </td>
          <td>(</td>
          <td class="paramtype">rte_mempool_objhdr_list&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrte__mempool__objhdr.html">rte_mempool_objhdr</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A list of object headers type </p>

</div>
</div>
<a id="afc480abc8d46500a80241926f53d897a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc480abc8d46500a80241926f53d897a">&#9670;&nbsp;</a></span>STAILQ_HEAD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STAILQ_HEAD </td>
          <td>(</td>
          <td class="paramtype">rte_mempool_memhdr_list&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrte__mempool__memhdr.html">rte_mempool_memhdr</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A list of memory where objects are stored </p>

</div>
</div>
<a id="a9b1ffc62a2fcc1ac728158ad2b177d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1ffc62a2fcc1ac728158ad2b177d0a">&#9670;&nbsp;</a></span>rte_mempool_from_obj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_from_obj </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the mempool owning this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An object that is owned by a pool. If this is not the case, the behavior is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the mempool structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l00320">320</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a6febb6f6c1468c055210f257363bc3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6febb6f6c1468c055210f257363bc3f4">&#9670;&nbsp;</a></span>rte_mempool_op_calc_mem_size_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rte_mempool_op_calc_mem_size_default </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>obj_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>min_chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default way to calculate memory size required to store given number of objects.</p>
<p>Equivalent to rte_mempool_op_calc_mem_size_helper(mp, obj_num, pg_shift, 0, min_chunk_size, align). </p>

</div>
</div>
<a id="a108419b63ad6476c47d87ea5e20f0925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108419b63ad6476c47d87ea5e20f0925">&#9670;&nbsp;</a></span>rte_mempool_op_populate_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mempool_op_populate_default </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td>
          <td class="paramname"><em>iova</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a3b33d8ef0ee40e9fb64fec3924bf8539">rte_mempool_populate_obj_cb_t</a> *&#160;</td>
          <td class="paramname"><em>obj_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default way to populate memory pool object using provided memory chunk.</p>
<p>Equivalent to rte_mempool_op_populate_helper(mp, 0, max_objs, vaddr, iova, len, obj_cb, obj_cb_arg). </p>

</div>
</div>
<a id="ab2ed5da907156a7a63569512f5b9e04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ed5da907156a7a63569512f5b9e04d">&#9670;&nbsp;</a></span>rte_mempool_ops_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mempool_ops_get_info </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool__info.html">rte_mempool_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for mempool_ops get_info callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mp</td><td>Pointer to the memory pool. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>Pointer to the <a class="el" href="structrte__mempool__info.html">rte_mempool_info</a> structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; The mempool driver supports retrieving supplementary mempool information</li>
<li>-ENOTSUP - doesn't support get_info ops (valid case). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a04d43951645ad4c11a3d88e3d7664aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d43951645ad4c11a3d88e3d7664aa9">&#9670;&nbsp;</a></span>rte_mempool_set_ops_byname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mempool_set_ops_byname </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pool_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the ops of a mempool.</p>
<p>This can only be done on a mempool that is not populated, i.e. just after a call to <a class="el" href="rte__mempool_8h.html#a542ec0f29072e7f1cfdb5c150f57b236">rte_mempool_create_empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Pointer to the memory pool. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the ops structure to use for this mempool. </td></tr>
    <tr><td class="paramname">pool_config</td><td>Opaque data that can be passed by the application to the ops functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; the mempool is now using the requested ops functions.</li>
<li>-EINVAL - Invalid ops struct name provided.</li>
<li>-EEXIST - mempool already has an ops struct assigned. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a54">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a6365f00c9b5f23dedcc585b6fa8354e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6365f00c9b5f23dedcc585b6fa8354e8">&#9670;&nbsp;</a></span>rte_mempool_register_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mempool_register_ops </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool__ops.html">rte_mempool_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register mempool operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>Pointer to an ops structure to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&gt;=0: Success; return the index of the ops struct in the table.</li>
<li>-EINVAL - some missing callbacks while registering ops struct.</li>
<li>-ENOSPC - the maximum number of ops structs has been reached. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a503f2f889043a48ca9995878846db2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503f2f889043a48ca9995878846db2fd">&#9670;&nbsp;</a></span>rte_mempool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>private_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#aa29fcb33f12181ad2cb0729dfd547736">rte_mempool_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>mp_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mp_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a127321ad7ff30d88414f6943a857ae3d">rte_mempool_obj_cb_t</a> *&#160;</td>
          <td class="paramname"><em>obj_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new mempool named <em>name</em> in memory.</p>
<p>This function uses <code><a class="el" href="rte__memzone_8h.html#a3ccbea77ccab608c6e683817a3eb170f">rte_memzone_reserve()</a></code> to allocate memory. The pool contains n elements of elt_size. Its size is set to n.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mempool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">cache_size</td><td>If cache_size is non-zero, the <a class="el" href="structrte__mempool.html">rte_mempool</a> library will try to limit the accesses to the common lockless pool, by maintaining a per-lcore object cache. This argument must be lower or equal to RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose cache_size to have "n modulo cache_size == 0": if this is not the case, some elements will always stay in the pool and will never be used. The access to the per-lcore table is of course faster than the multi-producer/consumer pool. The cache can be disabled if the cache_size argument is set to 0; it can be useful to avoid losing objects in cache. </td></tr>
    <tr><td class="paramname">private_data_size</td><td>The size of the private data appended after the mempool structure. This is useful for storing some private data after the mempool structure, as is done for rte_mbuf_pool for example. </td></tr>
    <tr><td class="paramname">mp_init</td><td>A function pointer that is called for initialization of the pool, before object initialization. The user can initialize the private data in this function if needed. This parameter can be NULL if not needed. </td></tr>
    <tr><td class="paramname">mp_init_arg</td><td>An opaque pointer to data that can be used in the mempool constructor function. </td></tr>
    <tr><td class="paramname">obj_init</td><td>A function pointer that is called for each object at initialization of the pool. The user can set some meta data in objects if needed. This parameter can be NULL if not needed. The obj_init() function takes the mempool pointer, the init_arg, the object pointer and the object number as parameters. </td></tr>
    <tr><td class="paramname">obj_init_arg</td><td>An opaque pointer to data that can be used as an argument for each call to the object constructor function. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in the case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>The <em>flags</em> arguments is an OR of following flags:<ul>
<li>MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread between channels in RAM: the pool allocator will add padding between objects depending on the hardware configuration. See Memory alignment constraints for details. If this flag is set, the allocator will just align them to a cache line.</li>
<li>MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are cache-aligned. This flag removes this constraint, and no padding will be present between objects. This flag implies MEMPOOL_F_NO_SPREAD.</li>
<li>MEMPOOL_F_SP_PUT: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#ab0989ddd8b037416c8c3544c9d8b8106">rte_mempool_put()</a> or <a class="el" href="rte__mempool_8h.html#a5e46fc827d764e516e8ff0c3f00e33fc">rte_mempool_put_bulk()</a> is "single-producer". Otherwise, it is "multi-producers".</li>
<li>MEMPOOL_F_SC_GET: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#a6150c041e889498a08d0e0d0769292cb">rte_mempool_get()</a> or <a class="el" href="rte__mempool_8h.html#a0d326354d53ef5068d86a8b7d9ec2d61">rte_mempool_get_bulk()</a> is "single-consumer". Otherwise, it is "multi-consumers".</li>
<li>MEMPOOL_F_NO_IOVA_CONTIG: If set, allocated objects won't necessarily be contiguous in IO memory. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to rte_config structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>EINVAL - cache size provided is too large</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2fips_validation_2fips_dev_self_test_8c-example.html#a99">examples/fips_validation/fips_dev_self_test.c</a>, <a class="el" href="examples_2fips_validation_2main_8c-example.html#a17">examples/fips_validation/main.c</a>, <a class="el" href="examples_2ip_pipeline_2cryptodev_8c-example.html#a11">examples/ip_pipeline/cryptodev.c</a>, <a class="el" href="examples_2ipsec-secgw_2ipsec-secgw_8c-example.html#a160">examples/ipsec-secgw/ipsec-secgw.c</a>, <a class="el" href="examples_2l2fwd-crypto_2main_8c-example.html#a120">examples/l2fwd-crypto/main.c</a>, <a class="el" href="examples_2multi_process_2simple_mp_2main_8c-example.html#a12">examples/multi_process/simple_mp/main.c</a>, and <a class="el" href="examples_2vhost_crypto_2main_8c-example.html#a32">examples/vhost_crypto/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="a542ec0f29072e7f1cfdb5c150f57b236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542ec0f29072e7f1cfdb5c150f57b236">&#9670;&nbsp;</a></span>rte_mempool_create_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_create_empty </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>private_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an empty mempool</p>
<p>The mempool is allocated and initialized, but it is not populated: no memory is allocated for the mempool elements. The user has to call rte_mempool_populate_*() to add memory chunks to the pool. Once populated, the user may also want to initialize each object with <a class="el" href="rte__mempool_8h.html#abd4bec335c01bac3d695beffb5a28690">rte_mempool_obj_iter()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of elements that can be added in the mempool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">cache_size</td><td>Size of the cache. See <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> for details. </td></tr>
    <tr><td class="paramname">private_data_size</td><td>The size of the private data appended after the mempool structure. This is useful for storing some private data after the mempool structure, as is done for rte_mbuf_pool for example. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in the case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags controlling the behavior of the mempool. See <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. See <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> for details. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a53">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a35271bce2d546e116074803fd69376e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35271bce2d546e116074803fd69376e9">&#9670;&nbsp;</a></span>rte_mempool_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a mempool</p>
<p>Unlink the mempool from global list, free the memory chunks, and all memory referenced by the mempool. The objects must not be used by other cores as they will be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2fips_validation_2fips_dev_self_test_8c-example.html#a82">examples/fips_validation/fips_dev_self_test.c</a>, <a class="el" href="examples_2fips_validation_2main_8c-example.html#a23">examples/fips_validation/main.c</a>, <a class="el" href="examples_2ip_pipeline_2cryptodev_8c-example.html#a13">examples/ip_pipeline/cryptodev.c</a>, <a class="el" href="examples_2ip_pipeline_2mempool_8c-example.html#a4">examples/ip_pipeline/mempool.c</a>, <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a67">examples/ntb/ntb_fwd.c</a>, <a class="el" href="examples_2pipeline_2obj_8c-example.html#a5">examples/pipeline/obj.c</a>, and <a class="el" href="examples_2vhost_crypto_2main_8c-example.html#a19">examples/vhost_crypto/main.c</a>.</dd>
</dl>

</div>
</div>
<a id="ac3522d5f027567081122f31e4d4cfe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3522d5f027567081122f31e4d4cfe3b">&#9670;&nbsp;</a></span>rte_mempool_populate_iova()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mempool_populate_iova </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a>&#160;</td>
          <td class="paramname"><em>iova</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a024fe092ff5209fbb37e15197b12628e">rte_mempool_memchunk_free_cb_t</a> *&#160;</td>
          <td class="paramname"><em>free_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add physically contiguous memory for objects in the pool at init</p>
<p>Add a virtually and physically contiguous memory chunk in the pool where objects can be instantiated.</p>
<p>If the given IO address is unknown (iova = RTE_BAD_IOVA), the chunk doesn't need to be physically contiguous (only virtually), and allocated objects may span two pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">vaddr</td><td>The virtual address of memory that should be used to store objects. </td></tr>
    <tr><td class="paramname">iova</td><td>The IO address </td></tr>
    <tr><td class="paramname">len</td><td>The length of memory in bytes. </td></tr>
    <tr><td class="paramname">free_cb</td><td>The callback used to free this chunk when destroying the mempool. </td></tr>
    <tr><td class="paramname">opaque</td><td>An opaque argument passed to free_cb. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects added on success (strictly positive). On error, the chunk is not added in the memory list of the mempool the following code is returned: (0): not enough room in chunk for one object. (-ENOSPC): mempool is already populated. (-ENOMEM): allocation failure. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a63">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="a64cafcc36eef66ff8ccc3300c3bd92cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cafcc36eef66ff8ccc3300c3bd92cf">&#9670;&nbsp;</a></span>rte_mempool_populate_virt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mempool_populate_virt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pg_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a024fe092ff5209fbb37e15197b12628e">rte_mempool_memchunk_free_cb_t</a> *&#160;</td>
          <td class="paramname"><em>free_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add virtually contiguous memory for objects in the pool at init</p>
<p>Add a virtually contiguous memory chunk in the pool where objects can be instantiated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">addr</td><td>The virtual address of memory that should be used to store objects. </td></tr>
    <tr><td class="paramname">len</td><td>The length of memory in bytes. </td></tr>
    <tr><td class="paramname">pg_sz</td><td>The size of memory pages in this virtual area. </td></tr>
    <tr><td class="paramname">free_cb</td><td>The callback used to free this chunk when destroying the mempool. </td></tr>
    <tr><td class="paramname">opaque</td><td>An opaque argument passed to free_cb. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects added on success (strictly positive). On error, the chunk is not added in the memory list of the mempool the following code is returned: (0): not enough room in chunk for one object. (-ENOSPC): mempool is already populated. (-ENOMEM): allocation failure. </dd></dl>

</div>
</div>
<a id="a4e463ccfc2e40cca2836137ea737d8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e463ccfc2e40cca2836137ea737d8a8">&#9670;&nbsp;</a></span>rte_mempool_populate_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mempool_populate_default </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add memory for objects in the pool at init</p>
<p>This is the default function used by <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> to populate the mempool. It adds memory allocated using <a class="el" href="rte__memzone_8h.html#a3ccbea77ccab608c6e683817a3eb170f">rte_memzone_reserve()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects added on success. On error, the chunk is not added in the memory list of the mempool and a negative errno is returned. </dd></dl>

</div>
</div>
<a id="a7101e2157c9082f095d2ed5993e42117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7101e2157c9082f095d2ed5993e42117">&#9670;&nbsp;</a></span>rte_mempool_populate_anon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_mempool_populate_anon </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add memory from anonymous mapping for objects in the pool at init</p>
<p>This function mmap an anonymous memory zone that is locked in memory to store the objects of the mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of objects added on success. On error, 0 is returned, rte_errno is set, and the chunk is not added in the memory list of the mempool. </dd></dl>

</div>
</div>
<a id="abd4bec335c01bac3d695beffb5a28690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4bec335c01bac3d695beffb5a28690">&#9670;&nbsp;</a></span>rte_mempool_obj_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rte_mempool_obj_iter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a127321ad7ff30d88414f6943a857ae3d">rte_mempool_obj_cb_t</a> *&#160;</td>
          <td class="paramname"><em>obj_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call a function for each mempool element</p>
<p>Iterate across all objects attached to a <a class="el" href="structrte__mempool.html">rte_mempool</a> and call the callback function on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to an initialized mempool. </td></tr>
    <tr><td class="paramname">obj_cb</td><td>A function pointer that is called for each object. </td></tr>
    <tr><td class="paramname">obj_cb_arg</td><td>An opaque pointer passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of objects iterated. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a68">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

</div>
</div>
<a id="ad7641e4bb5161d53543d3bd4c3d9e85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7641e4bb5161d53543d3bd4c3d9e85a">&#9670;&nbsp;</a></span>rte_mempool_mem_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rte_mempool_mem_iter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#aa57a7bf9eb8320cf38377d192a2ffb90">rte_mempool_mem_cb_t</a> *&#160;</td>
          <td class="paramname"><em>mem_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call a function for each mempool memory chunk</p>
<p>Iterate across all memory chunks attached to a <a class="el" href="structrte__mempool.html">rte_mempool</a> and call the callback function on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to an initialized mempool. </td></tr>
    <tr><td class="paramname">mem_cb</td><td>A function pointer that is called for each memory chunk. </td></tr>
    <tr><td class="paramname">mem_cb_arg</td><td>An opaque pointer passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of memory chunks iterated. </dd></dl>

</div>
</div>
<a id="a89dd70a2377f35d89b046655ba5c6cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dd70a2377f35d89b046655ba5c6cf9">&#9670;&nbsp;</a></span>rte_mempool_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of the mempool to a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9029f1e9d69b5e0105ab597225ee3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9029f1e9d69b5e0105ab597225ee3f2">&#9670;&nbsp;</a></span>rte_mempool_cache_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a>* rte_mempool_cache_create </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a user-owned mempool cache.</p>
<p>This can be used by unregistered non-EAL threads to enable caching when they interact with a mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the mempool cache. See <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a>'s cache_size parameter description for more information. The same limits and considerations apply here too. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The socket identifier in the case of NUMA. The value can be SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84393d11b18ee2aa436ca856ad10ecca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84393d11b18ee2aa436ca856ad10ecca">&#9670;&nbsp;</a></span>rte_mempool_cache_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_cache_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a user-owned mempool cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>A pointer to the mempool cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed0929bd6e5dbc455f4c659be4fbf966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0929bd6e5dbc455f4c659be4fbf966">&#9670;&nbsp;</a></span>rte_mempool_default_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a>* rte_mempool_default_cache </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>lcore_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the per-lcore default mempool cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">lcore_id</td><td>The logical core id. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the mempool cache or NULL if disabled or unregistered non-EAL thread. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01238">1238</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a5ca812ec68a5e3de153b772415977301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca812ec68a5e3de153b772415977301">&#9670;&nbsp;</a></span>rte_mempool_cache_flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_mempool_cache_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flush a user-owned mempool cache to the specified mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>A pointer to the mempool cache. </td></tr>
    <tr><td class="paramname">mp</td><td>A pointer to the mempool. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01260">1260</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a84a921213eb20cdc0f92e20fff7457df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a921213eb20cdc0f92e20fff7457df">&#9670;&nbsp;</a></span>rte_mempool_generic_put()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_mempool_generic_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put several objects back in the mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the mempool from the obj_table. </td></tr>
    <tr><td class="paramname">cache</td><td>A pointer to a mempool cache structure. May be NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01344">1344</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a5e46fc827d764e516e8ff0c3f00e33fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e46fc827d764e516e8ff0c3f00e33fc">&#9670;&nbsp;</a></span>rte_mempool_put_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_mempool_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put several objects back in the mempool.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at mempool creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the mempool from obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a25">examples/ioat/ioatfwd.c</a>, and <a class="el" href="examples_2vhost_crypto_2main_8c-example.html#a18">examples/vhost_crypto/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01367">1367</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="ab0989ddd8b037416c8c3544c9d8b8106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0989ddd8b037416c8c3544c9d8b8106">&#9670;&nbsp;</a></span>rte_mempool_put()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_mempool_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put one object back in the mempool.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at mempool creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2multi_process_2simple_mp_2main_8c-example.html#a5">examples/multi_process/simple_mp/main.c</a>, and <a class="el" href="examples_2multi_process_2simple_mp_2mp_commands_8c-example.html#a4">examples/multi_process/simple_mp/mp_commands.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01389">1389</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a8c731b5204a5736134f9f688868df245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c731b5204a5736134f9f688868df245">&#9670;&nbsp;</a></span>rte_mempool_generic_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_mempool_generic_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool__cache.html">rte_mempool_cache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get several objects from the mempool.</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to get from mempool to obj_table. </td></tr>
    <tr><td class="paramname">cache</td><td>A pointer to a mempool cache structure. May be NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01487">1487</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a0d326354d53ef5068d86a8b7d9ec2d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d326354d53ef5068d86a8b7d9ec2d61">&#9670;&nbsp;</a></span>rte_mempool_get_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_mempool_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get several objects from the mempool.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behaviour that was specified at mempool creation time (see flags).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to get from the mempool to obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2bbdev_app_2main_8c-example.html#a57">examples/bbdev_app/main.c</a>, <a class="el" href="examples_2ioat_2ioatfwd_8c-example.html#a21">examples/ioat/ioatfwd.c</a>, and <a class="el" href="examples_2ntb_2ntb_fwd_8c-example.html#a17">examples/ntb/ntb_fwd.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01521">1521</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a6150c041e889498a08d0e0d0769292cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6150c041e889498a08d0e0d0769292cb">&#9670;&nbsp;</a></span>rte_mempool_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_mempool_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one object from the mempool.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behavior that was specified at mempool creation (see flags).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2multi_process_2simple_mp_2mp_commands_8c-example.html#a1">examples/multi_process/simple_mp/mp_commands.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01550">1550</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a563f242367bf6533fe2d4ce7a0411848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563f242367bf6533fe2d4ce7a0411848">&#9670;&nbsp;</a></span>rte_mempool_get_contig_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_mempool_get_contig_blocks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>first_obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a contiguous blocks of objects from the mempool.</p>
<p>If cache is enabled, consider to flush it first, to reuse objects as soon as possible.</p>
<p>The application should check that the driver supports the operation by calling <a class="el" href="rte__mempool_8h.html#ab2ed5da907156a7a63569512f5b9e04d">rte_mempool_ops_get_info()</a> and checking that <code>contig_block_size</code> is not zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">first_obj_table</td><td>A pointer to a pointer to the first object in each block. </td></tr>
    <tr><td class="paramname">n</td><td>The number of blocks to get from mempool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; blocks taken.</li>
<li>-ENOBUFS: Not enough entries in the mempool; no object is retrieved.</li>
<li>-EOPNOTSUPP: The mempool driver does not support block dequeue </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01577">1577</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a505a815fc46e027a0a2054df124bc514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505a815fc46e027a0a2054df124bc514">&#9670;&nbsp;</a></span>rte_mempool_avail_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rte_mempool_avail_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of entries in the mempool.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes. User-owned mempool caches are not accounted for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the mempool. </dd></dl>

</div>
</div>
<a id="abce09dff484b6726ced4da3bbe3b2e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce09dff484b6726ced4da3bbe3b2e55">&#9670;&nbsp;</a></span>rte_mempool_in_use_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rte_mempool_in_use_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of elements which have been allocated from the mempool</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of free entries in the mempool. </dd></dl>

</div>
</div>
<a id="a85a83e5cc7f9d57f154839b1c80992a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a83e5cc7f9d57f154839b1c80992a3">&#9670;&nbsp;</a></span>rte_mempool_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_full </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if the mempool is full.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes. User-owned mempool caches are not accounted for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The mempool is full.</li>
<li>0: The mempool is not full. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01638">1638</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="ad6ad83873c9af9bc2012153cd4b4ed52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ad83873c9af9bc2012153cd4b4ed52">&#9670;&nbsp;</a></span>rte_mempool_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if the mempool is empty.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes. User-owned mempool caches are not accounted for.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The mempool is empty.</li>
<li>0: The mempool is not empty. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01657">1657</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a20f365fff447d3e46b55590d1da90f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f365fff447d3e46b55590d1da90f30">&#9670;&nbsp;</a></span>rte_mempool_virt2iova()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#a6bbae0c1ede15e66dea0cc8ec17a3d87">rte_iova_t</a> rte_mempool_virt2iova </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>elt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the IO address of elt, which is an element of the pool mp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>A pointer (virtual address) to the element of the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IO address of the elt element. If the mempool was created with MEMPOOL_F_NO_IOVA_CONTIG, the returned value is RTE_BAD_IOVA. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01673">1673</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="a9fd7e5570903fc76c16ad8d2b05adde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd7e5570903fc76c16ad8d2b05adde5">&#9670;&nbsp;</a></span>rte_mempool_audit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_audit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the consistency of mempool objects.</p>
<p>Verify the coherency of fields in the mempool structure. Also check that the cookies of mempool objects (even the ones that are not present in pool) have a correct value. If not, a panic will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b794c0cd2a78c74817b250becf981fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b794c0cd2a78c74817b250becf981fc">&#9670;&nbsp;</a></span>rte_mempool_get_priv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* rte_mempool_get_priv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the private data in an mempool structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the private data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__mempool_8h_source.html#l01701">1701</a> of file <a class="el" href="rte__mempool_8h_source.html">rte_mempool.h</a>.</p>

</div>
</div>
<a id="acb1120319a35b0cf0b23827705b2229a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1120319a35b0cf0b23827705b2229a">&#9670;&nbsp;</a></span>rte_mempool_list_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_list_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of all mempools on the console</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a5887135fc6329a35780b0053e769ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5887135fc6329a35780b0053e769ad">&#9670;&nbsp;</a></span>rte_mempool_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search a mempool from its name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the mempool matching the name, or NULL if not found. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - required entry not available to return. </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2multi_process_2client_server_mp_2mp_client_2client_8c-example.html#a17">examples/multi_process/client_server_mp/mp_client/client.c</a>, <a class="el" href="examples_2multi_process_2simple_mp_2main_8c-example.html#a14">examples/multi_process/simple_mp/main.c</a>, <a class="el" href="examples_2multi_process_2symmetric_mp_2main_8c-example.html#a46">examples/multi_process/symmetric_mp/main.c</a>, and <a class="el" href="examples_2server_node_efd_2node_2node_8c-example.html#a34">examples/server_node_efd/node/node.c</a>.</dd>
</dl>

</div>
</div>
<a id="a121d699436738109067ed80a1ecae38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121d699436738109067ed80a1ecae38f">&#9670;&nbsp;</a></span>rte_mempool_calc_obj_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rte_mempool_calc_obj_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool__objsz.html">rte_mempool_objsz</a> *&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the header, trailer and total size of a mempool element.</p>
<p>Given a desired size of the mempool element and mempool flags, calculates header, trailer, body and total sizes of the mempool object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt_size</td><td>The size of each element, without header and trailer. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags used for the mempool creation. Consult <a class="el" href="rte__mempool_8h.html#a503f2f889043a48ca9995878846db2fd">rte_mempool_create()</a> for more information about possible values. The size of each element. </td></tr>
    <tr><td class="paramname">sz</td><td>The calculated detailed size the mempool object. May be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size of the mempool object. </dd></dl>

</div>
</div>
<a id="aa0de941287fb011e1448c043a145ed8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0de941287fb011e1448c043a145ed8d">&#9670;&nbsp;</a></span>rte_mempool_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_walk </td>
          <td>(</td>
          <td class="paramtype">void(*)(struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *arg)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk list of all memory pools</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad4faf736256b092f327925d45a1db0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4faf736256b092f327925d45a1db0b1">&#9670;&nbsp;</a></span>rte_mempool_ops_table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool__ops__table.html">rte_mempool_ops_table</a> <a class="el" href="structrte__mempool__ops__table.html">rte_mempool_ops_table</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of registered ops structs. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="arte__common_8h_html_aaa00d0ee0e96206a928be48e6837758c"><div class="ttname"><a href="rte__common_8h.html#aaa00d0ee0e96206a928be48e6837758c">RTE_INIT</a></div><div class="ttdeci">#define RTE_INIT(func)</div><div class="ttdef"><b>Definition:</b> <a href="rte__common_8h_source.html#l00190">rte_common.h:190</a></div></div>
<div class="ttc" id="astructrte__mempool__cache_html"><div class="ttname"><a href="structrte__mempool__cache.html">rte_mempool_cache</a></div><div class="ttdef"><b>Definition:</b> <a href="rte__mempool_8h_source.html#l00085">rte_mempool.h:85</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
