<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_rcu/rte_rcu_qsbr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_7fb41ed998b608e7313c151134bd387c.html">librte_rcu</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_rcu_qsbr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h_source.html">rte_memory.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__lcore_8h_source.html">rte_lcore.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__debug_8h_source.html">rte_debug.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__atomic_8h_source.html">rte_atomic.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__ring_8h_source.html">rte_ring.h</a>&gt;</code><br />
</div>
<p><a href="rte__rcu__qsbr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__rcu__qsbr__dq__parameters.html">rte_rcu_qsbr_dq_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1b6eb1a5f61d7b1aa1827f097af1d854"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a1b6eb1a5f61d7b1aa1827f097af1d854">RTE_RCU_QSBR_DQ_MT_UNSAFE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a1b6eb1a5f61d7b1aa1827f097af1d854"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9ed39256b0fe6528f05a927a4655c8c0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a9ed39256b0fe6528f05a927a4655c8c0">rte_rcu_qsbr_free_resource_t</a>) (void *p, void *e, unsigned int n)</td></tr>
<tr class="separator:a9ed39256b0fe6528f05a927a4655c8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aec26d9b4505a2f05b991538d572591f7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#aec26d9b4505a2f05b991538d572591f7">rte_rcu_qsbr_get_memsize</a> (uint32_t max_threads)</td></tr>
<tr class="separator:aec26d9b4505a2f05b991538d572591f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3c358d7aea63f9afc656165d310d9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a4e3c358d7aea63f9afc656165d310d9a">rte_rcu_qsbr_init</a> (struct rte_rcu_qsbr *v, uint32_t max_threads)</td></tr>
<tr class="separator:a4e3c358d7aea63f9afc656165d310d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a220c06cdbc7d2409feecea9d1c9ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a15a220c06cdbc7d2409feecea9d1c9ea">rte_rcu_qsbr_thread_register</a> (struct rte_rcu_qsbr *v, unsigned int thread_id)</td></tr>
<tr class="separator:a15a220c06cdbc7d2409feecea9d1c9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fe6cf29d4fafc9af8d95604b416086"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a31fe6cf29d4fafc9af8d95604b416086">rte_rcu_qsbr_thread_unregister</a> (struct rte_rcu_qsbr *v, unsigned int thread_id)</td></tr>
<tr class="separator:a31fe6cf29d4fafc9af8d95604b416086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfd5289c23eae4abccd1e18f43e2ec4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a1bfd5289c23eae4abccd1e18f43e2ec4">rte_rcu_qsbr_thread_online</a> (struct rte_rcu_qsbr *v, unsigned int thread_id)</td></tr>
<tr class="separator:a1bfd5289c23eae4abccd1e18f43e2ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cbced510477d4670e1904f1150acb6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a59cbced510477d4670e1904f1150acb6">rte_rcu_qsbr_thread_offline</a> (struct rte_rcu_qsbr *v, unsigned int thread_id)</td></tr>
<tr class="separator:a59cbced510477d4670e1904f1150acb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417137b68475e834da870e6f978c6f1b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a417137b68475e834da870e6f978c6f1b">rte_rcu_qsbr_lock</a> (<a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> struct rte_rcu_qsbr *v, <a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> unsigned int thread_id)</td></tr>
<tr class="separator:a417137b68475e834da870e6f978c6f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14abcbea7d7bdaee3867be4bc8ebf41f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a14abcbea7d7bdaee3867be4bc8ebf41f">rte_rcu_qsbr_unlock</a> (<a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> struct rte_rcu_qsbr *v, <a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> unsigned int thread_id)</td></tr>
<tr class="separator:a14abcbea7d7bdaee3867be4bc8ebf41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061b674cb44bd08216a42a4f8ca720c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a0061b674cb44bd08216a42a4f8ca720c">rte_rcu_qsbr_start</a> (struct rte_rcu_qsbr *v)</td></tr>
<tr class="separator:a0061b674cb44bd08216a42a4f8ca720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd77cfc1016e018aec31cf38159ad1ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#afd77cfc1016e018aec31cf38159ad1ab">rte_rcu_qsbr_quiescent</a> (struct rte_rcu_qsbr *v, unsigned int thread_id)</td></tr>
<tr class="separator:afd77cfc1016e018aec31cf38159ad1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef95f47cd8e1c954bb6a1360a423526"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#acef95f47cd8e1c954bb6a1360a423526">rte_rcu_qsbr_check</a> (struct rte_rcu_qsbr *v, uint64_t t, bool wait)</td></tr>
<tr class="separator:acef95f47cd8e1c954bb6a1360a423526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca19f540c3afdd112495f76b898a37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#aa8ca19f540c3afdd112495f76b898a37">rte_rcu_qsbr_synchronize</a> (struct rte_rcu_qsbr *v, unsigned int thread_id)</td></tr>
<tr class="separator:aa8ca19f540c3afdd112495f76b898a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac106b7dd55224fc54ca6129211bf1188"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#ac106b7dd55224fc54ca6129211bf1188">rte_rcu_qsbr_dump</a> (FILE *f, struct rte_rcu_qsbr *v)</td></tr>
<tr class="separator:ac106b7dd55224fc54ca6129211bf1188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad9f3855048e4454937055ddc81ac7a"><td class="memItemLeft" align="right" valign="top">__rte_experimental struct rte_rcu_qsbr_dq *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#afad9f3855048e4454937055ddc81ac7a">rte_rcu_qsbr_dq_create</a> (const struct <a class="el" href="structrte__rcu__qsbr__dq__parameters.html">rte_rcu_qsbr_dq_parameters</a> *params)</td></tr>
<tr class="separator:afad9f3855048e4454937055ddc81ac7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4865c42a7c8f2181fcae9a45ebef6af5"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a4865c42a7c8f2181fcae9a45ebef6af5">rte_rcu_qsbr_dq_enqueue</a> (struct rte_rcu_qsbr_dq *dq, void *e)</td></tr>
<tr class="separator:a4865c42a7c8f2181fcae9a45ebef6af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c54b40ce15e4d6210e50e7d3d767149"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a6c54b40ce15e4d6210e50e7d3d767149">rte_rcu_qsbr_dq_reclaim</a> (struct rte_rcu_qsbr_dq *dq, unsigned int n, unsigned int *freed, unsigned int *pending, unsigned int *available)</td></tr>
<tr class="separator:a6c54b40ce15e4d6210e50e7d3d767149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daa4ca3c1f35d6da5ab665894989805"><td class="memItemLeft" align="right" valign="top">__rte_experimental int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__rcu__qsbr_8h.html#a5daa4ca3c1f35d6da5ab665894989805">rte_rcu_qsbr_dq_delete</a> (struct rte_rcu_qsbr_dq *dq)</td></tr>
<tr class="separator:a5daa4ca3c1f35d6da5ab665894989805"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Quiescent State Based Reclamation (QSBR).</p>
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> All functions in this file may be changed or removed without prior notice.</dd></dl>
<p>Quiescent State (QS) is any point in the thread execution where the thread does not hold a reference to a data structure in shared memory. While using lock-less data structures, the writer can safely free memory once all the reader threads have entered quiescent state.</p>
<p>This library provides the ability for the readers to report quiescent state and for the writers to identify when all the readers have entered quiescent state. </p>

<p class="definition">Definition in file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1b6eb1a5f61d7b1aa1827f097af1d854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6eb1a5f61d7b1aa1827f097af1d854">&#9670;&nbsp;</a></span>RTE_RCU_QSBR_DQ_MT_UNSAFE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_RCU_QSBR_DQ_MT_UNSAFE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Various flags supported. &lt; Enqueue and reclaim operations are multi-thread safe by default. The call back functions registered to free the resources are assumed to be multi-thread safe. Set this flag if multi-thread safety is not required. </p>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00149">149</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9ed39256b0fe6528f05a927a4655c8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed39256b0fe6528f05a927a4655c8c0">&#9670;&nbsp;</a></span>rte_rcu_qsbr_free_resource_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_rcu_qsbr_free_resource_t) (void *p, void *e, unsigned int n)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call back function called to free the resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer provided while creating the defer queue </td></tr>
    <tr><td class="paramname">e</td><td>Pointer to the resource data stored on the defer queue </td></tr>
    <tr><td class="paramname">n</td><td>Number of resources to free. Currently, this is set to 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00137">137</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aec26d9b4505a2f05b991538d572591f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec26d9b4505a2f05b991538d572591f7">&#9670;&nbsp;</a></span>rte_rcu_qsbr_get_memsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rte_rcu_qsbr_get_memsize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the size of the memory occupied by a Quiescent State variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_threads</td><td>Maximum number of threads reporting quiescent state on this variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success - size of memory in bytes required for this QS variable. On error - 1 with error code set in rte_errno. Possible rte_errno codes are:<ul>
<li>EINVAL - max_threads is 0 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4e3c358d7aea63f9afc656165d310d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3c358d7aea63f9afc656165d310d9a">&#9670;&nbsp;</a></span>rte_rcu_qsbr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rcu_qsbr_init </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a Quiescent State (QS) variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">max_threads</td><td>Maximum number of threads reporting quiescent state on this variable. This should be the same value as passed to rte_rcu_qsbr_get_memsize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success - 0 On error - 1 with error code set in rte_errno. Possible rte_errno codes are:<ul>
<li>EINVAL - max_threads is 0 or 'v' is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a15a220c06cdbc7d2409feecea9d1c9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a220c06cdbc7d2409feecea9d1c9ea">&#9670;&nbsp;</a></span>rte_rcu_qsbr_thread_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rcu_qsbr_thread_register </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a reader thread to report its quiescent state on a QS variable.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe. Any reader thread that wants to report its quiescent state must call this API. This can be called during initialization or as part of the packet processing loop.</p>
<p>Note that rte_rcu_qsbr_thread_online must be called before the thread updates its quiescent state using rte_rcu_qsbr_quiescent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">thread_id</td><td>Reader thread with this thread ID will report its quiescent state on the QS variable. thread_id is a value between 0 and (max_threads - 1). 'max_threads' is the parameter passed in 'rte_rcu_qsbr_init' API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31fe6cf29d4fafc9af8d95604b416086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fe6cf29d4fafc9af8d95604b416086">&#9670;&nbsp;</a></span>rte_rcu_qsbr_thread_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rcu_qsbr_thread_unregister </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a reader thread, from the list of threads reporting their quiescent state on a QS variable.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe. This API can be called from the reader threads during shutdown. Ongoing quiescent state queries will stop waiting for the status from this unregistered reader thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">thread_id</td><td>Reader thread with this thread ID will stop reporting its quiescent state on the QS variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bfd5289c23eae4abccd1e18f43e2ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfd5289c23eae4abccd1e18f43e2ec4">&#9670;&nbsp;</a></span>rte_rcu_qsbr_thread_online()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_rcu_qsbr_thread_online </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a registered reader thread, to the list of threads reporting their quiescent state on a QS variable.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe.</p>
<p>Any registered reader thread that wants to report its quiescent state must call this API before calling rte_rcu_qsbr_quiescent. This can be called during initialization or as part of the packet processing loop.</p>
<p>The reader thread must call rte_rcu_qsbr_thread_offline API, before calling any functions that block, to ensure that rte_rcu_qsbr_check API does not wait indefinitely for the reader thread to update its QS.</p>
<p>The reader thread must call rte_rcu_thread_online API, after the blocking function call returns, to ensure that rte_rcu_qsbr_check API waits for the reader thread to update its quiescent state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">thread_id</td><td>Reader thread with this thread ID will report its quiescent state on the QS variable. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00303">303</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<a id="a59cbced510477d4670e1904f1150acb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cbced510477d4670e1904f1150acb6">&#9670;&nbsp;</a></span>rte_rcu_qsbr_thread_offline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_rcu_qsbr_thread_offline </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove a registered reader thread from the list of threads reporting their quiescent state on a QS variable.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe.</p>
<p>This can be called during initialization or as part of the packet processing loop.</p>
<p>The reader thread must call rte_rcu_qsbr_thread_offline API, before calling any functions that block, to ensure that rte_rcu_qsbr_check API does not wait indefinitely for the reader thread to update its QS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">thread_id</td><td>rte_rcu_qsbr_check API will not wait for the reader thread with this thread ID to report its quiescent state on the QS variable. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00361">361</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<a id="a417137b68475e834da870e6f978c6f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417137b68475e834da870e6f978c6f1b">&#9670;&nbsp;</a></span>rte_rcu_qsbr_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_rcu_qsbr_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> unsigned int&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquire a lock for accessing a shared data structure.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe.</p>
<p>This API is provided to aid debugging. This should be called before accessing a shared data structure.</p>
<p>When RTE_LIBRTE_RCU_DEBUG is enabled a lock counter is incremented. Similarly rte_rcu_qsbr_unlock will decrement the counter. When the rte_rcu_qsbr_check API will verify that this counter is 0.</p>
<p>When RTE_LIBRTE_RCU_DEBUG is disabled, this API will do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">thread_id</td><td>Reader thread id </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00398">398</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<a id="a14abcbea7d7bdaee3867be4bc8ebf41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14abcbea7d7bdaee3867be4bc8ebf41f">&#9670;&nbsp;</a></span>rte_rcu_qsbr_unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_rcu_qsbr_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__common_8h.html#ae1a7c8799cb57669ae2ddf367b21533f">__rte_unused</a> unsigned int&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release a lock after accessing a shared data structure.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe.</p>
<p>This API is provided to aid debugging. This should be called after accessing a shared data structure.</p>
<p>When RTE_LIBRTE_RCU_DEBUG is enabled, rte_rcu_qsbr_unlock will decrement a lock counter. rte_rcu_qsbr_check API will verify that this counter is 0.</p>
<p>When RTE_LIBRTE_RCU_DEBUG is disabled, this API will do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">thread_id</td><td>Reader thread id </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00431">431</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<a id="a0061b674cb44bd08216a42a4f8ca720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0061b674cb44bd08216a42a4f8ca720c">&#9670;&nbsp;</a></span>rte_rcu_qsbr_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> uint64_t rte_rcu_qsbr_start </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask the reader threads to report the quiescent state status.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe and can be called from worker threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>This is the token for this call of the API. This should be passed to rte_rcu_qsbr_check API. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00461">461</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<a id="afd77cfc1016e018aec31cf38159ad1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd77cfc1016e018aec31cf38159ad1ab">&#9670;&nbsp;</a></span>rte_rcu_qsbr_quiescent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> void rte_rcu_qsbr_quiescent </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update quiescent state for a reader thread.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe. All the reader threads registered to report their quiescent state on the QS variable must call this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">thread_id</td><td>Update the quiescent state for the reader with this thread ID. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00490">490</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<a id="acef95f47cd8e1c954bb6a1360a423526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef95f47cd8e1c954bb6a1360a423526">&#9670;&nbsp;</a></span>rte_rcu_qsbr_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__common_8h.html#af1e21922385a6cbe051e3ab70bba9f11">__rte_always_inline</a> int rte_rcu_qsbr_check </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if all the reader threads have entered the quiescent state referenced by token.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe and can be called from the worker threads as well.</p>
<p>If this API is called with 'wait' set to true, the following factors must be considered:</p>
<p>1) If the calling thread is also reporting the status on the same QS variable, it must update the quiescent state status, before calling this API.</p>
<p>2) In addition, while calling from multiple threads, only one of those threads can be reporting the quiescent state status on a given QS variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">t</td><td>Token returned by rte_rcu_qsbr_start API </td></tr>
    <tr><td class="paramname">wait</td><td>If true, block till all the reader threads have completed entering the quiescent state referenced by token 't'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if all reader threads have NOT passed through specified number of quiescent states.</li>
<li>1 if all reader threads have passed through specified number of quiescent states. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="rte__rcu__qsbr_8h_source.html#l00677">677</a> of file <a class="el" href="rte__rcu__qsbr_8h_source.html">rte_rcu_qsbr.h</a>.</p>

</div>
</div>
<a id="aa8ca19f540c3afdd112495f76b898a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ca19f540c3afdd112495f76b898a37">&#9670;&nbsp;</a></span>rte_rcu_qsbr_synchronize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_rcu_qsbr_synchronize </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait till the reader threads have entered quiescent state.</p>
<p>This is implemented as a lock-free function. It is multi-thread safe. This API can be thought of as a wrapper around rte_rcu_qsbr_start and rte_rcu_qsbr_check APIs.</p>
<p>If this API is called from multiple threads, only one of those threads can be reporting the quiescent state status on a given QS variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
    <tr><td class="paramname">thread_id</td><td>Thread ID of the caller if it is registered to report quiescent state on this QS variable (i.e. the calling thread is also part of the readside critical section). If not, pass RTE_QSBR_THRID_INVALID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac106b7dd55224fc54ca6129211bf1188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac106b7dd55224fc54ca6129211bf1188">&#9670;&nbsp;</a></span>rte_rcu_qsbr_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_rcu_qsbr_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_rcu_qsbr *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the details of a single QS variables to a file.</p>
<p>It is NOT multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
    <tr><td class="paramname">v</td><td>QS variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success - 0 On error - 1 with error code set in rte_errno. Possible rte_errno codes are:<ul>
<li>EINVAL - NULL parameters are passed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afad9f3855048e4454937055ddc81ac7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad9f3855048e4454937055ddc81ac7a">&#9670;&nbsp;</a></span>rte_rcu_qsbr_dq_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental struct rte_rcu_qsbr_dq* rte_rcu_qsbr_dq_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__rcu__qsbr__dq__parameters.html">rte_rcu_qsbr_dq_parameters</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Create a queue used to store the data structure elements that can be freed later. This queue is referred to as 'defer queue'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Parameters to create a defer queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success - Valid pointer to defer queue On error - NULL Possible rte_errno codes are:<ul>
<li>EINVAL - NULL parameters are passed</li>
<li>ENOMEM - Not enough memory </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4865c42a7c8f2181fcae9a45ebef6af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4865c42a7c8f2181fcae9a45ebef6af5">&#9670;&nbsp;</a></span>rte_rcu_qsbr_dq_enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_rcu_qsbr_dq_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr_dq *&#160;</td>
          <td class="paramname"><em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Enqueue one resource to the defer queue and start the grace period. The resource will be freed later after at least one grace period is over.</p>
<p>If the defer queue is full, it will attempt to reclaim resources. It will also reclaim resources at regular intervals to avoid the defer queue from growing too big.</p>
<p>Multi-thread safety is provided as the defer queue configuration. When multi-thread safety is requested, it is possible that the resources are not stored in their order of deletion. This results in resources being held in the defer queue longer than they should.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq</td><td>Defer queue to allocate an entry from. </td></tr>
    <tr><td class="paramname">e</td><td>Pointer to resource data to copy to the defer queue. The size of the data to copy is equal to the element size provided when the defer queue was created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success - 0 On error - 1 with rte_errno set to<ul>
<li>EINVAL - NULL parameters are passed</li>
<li>ENOSPC - Defer queue is full. This condition can not happen if the defer queue size is equal (or larger) than the number of elements in the data structure. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6c54b40ce15e4d6210e50e7d3d767149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c54b40ce15e4d6210e50e7d3d767149">&#9670;&nbsp;</a></span>rte_rcu_qsbr_dq_reclaim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_rcu_qsbr_dq_reclaim </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr_dq *&#160;</td>
          <td class="paramname"><em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>freed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Free resources from the defer queue.</p>
<p>This API is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq</td><td>Defer queue to free an entry from. </td></tr>
    <tr><td class="paramname">n</td><td>Maximum number of resources to free. </td></tr>
    <tr><td class="paramname">freed</td><td>Number of resources that were freed. </td></tr>
    <tr><td class="paramname">pending</td><td>Number of resources pending on the defer queue. This number might not be accurate if multi-thread safety is configured. </td></tr>
    <tr><td class="paramname">available</td><td>Number of resources that can be added to the defer queue. This number might not be accurate if multi-thread safety is configured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On successful reclamation of at least 1 resource - 0 On error - 1 with rte_errno set to<ul>
<li>EINVAL - NULL parameters are passed </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5daa4ca3c1f35d6da5ab665894989805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5daa4ca3c1f35d6da5ab665894989805">&#9670;&nbsp;</a></span>rte_rcu_qsbr_dq_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__rte_experimental int rte_rcu_qsbr_dq_delete </td>
          <td>(</td>
          <td class="paramtype">struct rte_rcu_qsbr_dq *&#160;</td>
          <td class="paramname"><em>dq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Delete a defer queue.</p>
<p>It tries to reclaim all the resources on the defer queue. If any of the resources have not completed the grace period the reclamation stops and returns immediately. The rest of the resources are not reclaimed and the defer queue is not freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq</td><td>Defer queue to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success - 0 On error - 1 Possible rte_errno codes are:<ul>
<li>EAGAIN - Some of the resources have not completed at least 1 grace period, try again. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
