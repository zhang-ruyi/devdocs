<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPDK: lib/librte_member/rte_member.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   &#160;<span id="projectnumber">20.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_e6bf5b3b5611bc8c19dd42f833c7eb40.html">librte_member</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_member.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__common_8h_source.html">rte_common.h</a>&gt;</code><br />
<code>#include &lt;rte_config.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__jhash_8h_source.html">rte_jhash.h</a>&gt;</code><br />
</div>
<p><a href="rte__member_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__member__parameters.html">rte_member_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3c3cf84868db35d94f360b326b619e88"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#a3c3cf84868db35d94f360b326b619e88">RTE_MEMBER_NO_MATCH</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a3c3cf84868db35d94f360b326b619e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ffd6b18a45af27739d832c0ed5ab11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#a21ffd6b18a45af27739d832c0ed5ab11">RTE_MEMBER_ENTRIES_MAX</a>&#160;&#160;&#160;(1 &lt;&lt; 30)</td></tr>
<tr class="separator:a21ffd6b18a45af27739d832c0ed5ab11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e48446a6c2285d74721bcb4eeb276c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#a83e48446a6c2285d74721bcb4eeb276c">RTE_MEMBER_LOOKUP_BULK_MAX</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a83e48446a6c2285d74721bcb4eeb276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23d081e08f2c40a76c86976e1d324e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#ac23d081e08f2c40a76c86976e1d324e6">RTE_MEMBER_BUCKET_ENTRIES</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:ac23d081e08f2c40a76c86976e1d324e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb0079bf3ee3b2cea181b770466592c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#acdb0079bf3ee3b2cea181b770466592c">RTE_MEMBER_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:acdb0079bf3ee3b2cea181b770466592c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac5d5a860901554873840b6236b83ff67"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a></td></tr>
<tr class="separator:ac5d5a860901554873840b6236b83ff67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afbbb6e79d47e08460f152dcb0461bfee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#afbbb6e79d47e08460f152dcb0461bfee">rte_member_setsum_type</a> { <a class="el" href="rte__member_8h.html#afbbb6e79d47e08460f152dcb0461bfeeaee7e3dc3f84963e5e98a3e5436d48565">RTE_MEMBER_TYPE_HT</a> = 0, 
<a class="el" href="rte__member_8h.html#afbbb6e79d47e08460f152dcb0461bfeea8f14e0c6eedc62183c373b90557f8f55">RTE_MEMBER_TYPE_VBF</a>
 }</td></tr>
<tr class="separator:afbbb6e79d47e08460f152dcb0461bfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1c4b0dd3af63b6d0e174f6966cae48ca"><td class="memItemLeft" align="right" valign="top">struct rte_member_setsum *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#a1c4b0dd3af63b6d0e174f6966cae48ca">rte_member_find_existing</a> (const char *name)</td></tr>
<tr class="separator:a1c4b0dd3af63b6d0e174f6966cae48ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee57050e31fd5407f4f2c8d23cbe210"><td class="memItemLeft" align="right" valign="top">struct rte_member_setsum *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#aaee57050e31fd5407f4f2c8d23cbe210">rte_member_create</a> (const struct <a class="el" href="structrte__member__parameters.html">rte_member_parameters</a> *params)</td></tr>
<tr class="separator:aaee57050e31fd5407f4f2c8d23cbe210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308b532dd3688dac87ac45adbe29aea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#a308b532dd3688dac87ac45adbe29aea9">rte_member_lookup</a> (const struct rte_member_setsum *setsum, const void *key, <a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> *set_id)</td></tr>
<tr class="separator:a308b532dd3688dac87ac45adbe29aea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101aba088dc577716f134c50ffa5ef0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#a101aba088dc577716f134c50ffa5ef0d">rte_member_lookup_bulk</a> (const struct rte_member_setsum *setsum, const void **keys, uint32_t num_keys, <a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> *set_ids)</td></tr>
<tr class="separator:a101aba088dc577716f134c50ffa5ef0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2248bf9915468645abb018d4b8f887a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#ad2248bf9915468645abb018d4b8f887a">rte_member_lookup_multi</a> (const struct rte_member_setsum *setsum, const void *key, uint32_t max_match_per_key, <a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> *set_id)</td></tr>
<tr class="separator:ad2248bf9915468645abb018d4b8f887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f69bffb41e4de8acaca3722bfae326"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#ae2f69bffb41e4de8acaca3722bfae326">rte_member_lookup_multi_bulk</a> (const struct rte_member_setsum *setsum, const void **keys, uint32_t num_keys, uint32_t max_match_per_key, uint32_t *match_count, <a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> *set_ids)</td></tr>
<tr class="separator:ae2f69bffb41e4de8acaca3722bfae326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034c2e16094f08d77b21f3d66f81d371"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#a034c2e16094f08d77b21f3d66f81d371">rte_member_add</a> (const struct rte_member_setsum *setsum, const void *key, <a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> set_id)</td></tr>
<tr class="separator:a034c2e16094f08d77b21f3d66f81d371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5e0fe1b306d39a5c559b302412ee2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#ace5e0fe1b306d39a5c559b302412ee2a">rte_member_free</a> (struct rte_member_setsum *setsum)</td></tr>
<tr class="separator:ace5e0fe1b306d39a5c559b302412ee2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68593c306ebcfdb511ab9f822e54fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#ad68593c306ebcfdb511ab9f822e54fdb">rte_member_reset</a> (const struct rte_member_setsum *setsum)</td></tr>
<tr class="separator:ad68593c306ebcfdb511ab9f822e54fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f94090cf8802dd9a36915f805160112"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__member_8h.html#a4f94090cf8802dd9a36915f805160112">rte_member_delete</a> (const struct rte_member_setsum *setsum, const void *key, <a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> set_id)</td></tr>
<tr class="separator:a4f94090cf8802dd9a36915f805160112"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Membership Library</p>
<p>The Membership Library is an extension and generalization of a traditional filter (for example Bloom Filter and cuckoo filter) structure that has multiple usages in a variety of workloads and applications. The library is used to test if a key belongs to certain sets. Two types of such "set-summary" structures are implemented: hash-table based (HT) and vector bloom filter (vBF). For HT setsummary, two subtypes or modes are available, cache and non-cache modes. The table below summarize some properties of the different implementations.</p>
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice </dd></dl>

<p class="definition">Definition in file <a class="el" href="rte__member_8h_source.html">rte_member.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a3c3cf84868db35d94f360b326b619e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3cf84868db35d94f360b326b619e88">&#9670;&nbsp;</a></span>RTE_MEMBER_NO_MATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMBER_NO_MATCH&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid set ID used to mean no match found. </p>

<p class="definition">Definition at line <a class="el" href="rte__member_8h_source.html#l00060">60</a> of file <a class="el" href="rte__member_8h_source.html">rte_member.h</a>.</p>

</div>
</div>
<a id="a21ffd6b18a45af27739d832c0ed5ab11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ffd6b18a45af27739d832c0ed5ab11">&#9670;&nbsp;</a></span>RTE_MEMBER_ENTRIES_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMBER_ENTRIES_MAX&#160;&#160;&#160;(1 &lt;&lt; 30)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum size of hash table that can be created. </p>

<p class="definition">Definition at line <a class="el" href="rte__member_8h_source.html#l00062">62</a> of file <a class="el" href="rte__member_8h_source.html">rte_member.h</a>.</p>

</div>
</div>
<a id="a83e48446a6c2285d74721bcb4eeb276c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e48446a6c2285d74721bcb4eeb276c">&#9670;&nbsp;</a></span>RTE_MEMBER_LOOKUP_BULK_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMBER_LOOKUP_BULK_MAX&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of keys that can be searched as a bulk </p>

<p class="definition">Definition at line <a class="el" href="rte__member_8h_source.html#l00064">64</a> of file <a class="el" href="rte__member_8h_source.html">rte_member.h</a>.</p>

</div>
</div>
<a id="ac23d081e08f2c40a76c86976e1d324e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23d081e08f2c40a76c86976e1d324e6">&#9670;&nbsp;</a></span>RTE_MEMBER_BUCKET_ENTRIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMBER_BUCKET_ENTRIES&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Entry count per bucket in hash table based mode. </p>

<p class="definition">Definition at line <a class="el" href="rte__member_8h_source.html#l00066">66</a> of file <a class="el" href="rte__member_8h_source.html">rte_member.h</a>.</p>

</div>
</div>
<a id="acdb0079bf3ee3b2cea181b770466592c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb0079bf3ee3b2cea181b770466592c">&#9670;&nbsp;</a></span>RTE_MEMBER_NAMESIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMBER_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of characters in setsum name. </p>

<p class="definition">Definition at line <a class="el" href="rte__member_8h_source.html#l00068">68</a> of file <a class="el" href="rte__member_8h_source.html">rte_member.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac5d5a860901554873840b6236b83ff67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d5a860901554873840b6236b83ff67">&#9670;&nbsp;</a></span>member_set_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The set ID type that stored internally in hash table based set summary. </p>

<p class="definition">Definition at line <a class="el" href="rte__member_8h_source.html#l00058">58</a> of file <a class="el" href="rte__member_8h_source.html">rte_member.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afbbb6e79d47e08460f152dcb0461bfee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbb6e79d47e08460f152dcb0461bfee">&#9670;&nbsp;</a></span>rte_member_setsum_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__member_8h.html#afbbb6e79d47e08460f152dcb0461bfee">rte_member_setsum_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Define different set summary types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbbb6e79d47e08460f152dcb0461bfeeaee7e3dc3f84963e5e98a3e5436d48565"></a>RTE_MEMBER_TYPE_HT&#160;</td><td class="fielddoc"><p>Hash table based set summary. </p>
</td></tr>
<tr><td class="fieldname"><a id="afbbb6e79d47e08460f152dcb0461bfeea8f14e0c6eedc62183c373b90557f8f55"></a>RTE_MEMBER_TYPE_VBF&#160;</td><td class="fielddoc"><p>Vector of bloom filters. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="rte__member_8h_source.html#l00105">105</a> of file <a class="el" href="rte__member_8h_source.html">rte_member.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1c4b0dd3af63b6d0e174f6966cae48ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4b0dd3af63b6d0e174f6966cae48ca">&#9670;&nbsp;</a></span>rte_member_find_existing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_member_setsum* rte_member_find_existing </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Find an existing set-summary and return a pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the set-summary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the set-summary or NULL if object not found with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - value not available for return </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaee57050e31fd5407f4f2c8d23cbe210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee57050e31fd5407f4f2c8d23cbe210">&#9670;&nbsp;</a></span>rte_member_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_member_setsum* rte_member_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__member__parameters.html">rte_member_parameters</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Create set-summary (SS).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Parameters to initialize the setsummary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the pointer to the setsummary. Return value is NULL if the creation failed. </dd></dl>

</div>
</div>
<a id="a308b532dd3688dac87ac45adbe29aea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308b532dd3688dac87ac45adbe29aea9">&#9670;&nbsp;</a></span>rte_member_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_member_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct rte_member_setsum *&#160;</td>
          <td class="paramname"><em>setsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> *&#160;</td>
          <td class="paramname"><em>set_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Lookup key in set-summary (SS). Single key lookup and return as soon as the first match found</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setsum</td><td>Pointer of a setsummary. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer of the key to be looked up. </td></tr>
    <tr><td class="paramname">set_id</td><td>Output the set id matches the key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return 1 for found a match and 0 for not found a match. </dd></dl>

</div>
</div>
<a id="a101aba088dc577716f134c50ffa5ef0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101aba088dc577716f134c50ffa5ef0d">&#9670;&nbsp;</a></span>rte_member_lookup_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_member_lookup_bulk </td>
          <td>(</td>
          <td class="paramtype">const struct rte_member_setsum *&#160;</td>
          <td class="paramname"><em>setsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> *&#160;</td>
          <td class="paramname"><em>set_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Lookup bulk of keys in set-summary (SS). Each key lookup returns as soon as the first match found</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setsum</td><td>Pointer of a setsummary. </td></tr>
    <tr><td class="paramname">keys</td><td>Pointer of the bulk of keys to be looked up. </td></tr>
    <tr><td class="paramname">num_keys</td><td>Number of keys that will be lookup. </td></tr>
    <tr><td class="paramname">set_ids</td><td>Output set ids for all the keys to this array. User should preallocate array that can contain all results, which size is the num_keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of keys that found a match. </dd></dl>

</div>
</div>
<a id="ad2248bf9915468645abb018d4b8f887a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2248bf9915468645abb018d4b8f887a">&#9670;&nbsp;</a></span>rte_member_lookup_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_member_lookup_multi </td>
          <td>(</td>
          <td class="paramtype">const struct rte_member_setsum *&#160;</td>
          <td class="paramname"><em>setsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_match_per_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> *&#160;</td>
          <td class="paramname"><em>set_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Lookup a key in set-summary (SS) for multiple matches. The key lookup will find all matched entries (multiple match). Note that for cache mode of HT, each key can have at most one match. This is because keys with same signature that maps to same bucket will overwrite each other. So multi-match lookup should be used for vBF and non-cache HT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setsum</td><td>Pointer of a set-summary. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer of the key that to be looked up. </td></tr>
    <tr><td class="paramname">max_match_per_key</td><td>User specified maximum number of matches for each key. The function returns as soon as this number of matches found for the key. </td></tr>
    <tr><td class="paramname">set_id</td><td>Output set ids for all the matches of the key. User needs to preallocate the array that can contain max_match_per_key number of results. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of matches that found for the key. For cache mode HT set-summary, the number should be at most 1. </dd></dl>

</div>
</div>
<a id="ae2f69bffb41e4de8acaca3722bfae326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f69bffb41e4de8acaca3722bfae326">&#9670;&nbsp;</a></span>rte_member_lookup_multi_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_member_lookup_multi_bulk </td>
          <td>(</td>
          <td class="paramtype">const struct rte_member_setsum *&#160;</td>
          <td class="paramname"><em>setsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_match_per_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>match_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a> *&#160;</td>
          <td class="paramname"><em>set_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Lookup a bulk of keys in set-summary (SS) for multiple matches each key. Each key lookup will find all matched entries (multiple match). Note that for cache mode HT, each key can have at most one match. So multi-match function is mainly used for vBF and non-cache mode HT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setsum</td><td>Pointer of a setsummary. </td></tr>
    <tr><td class="paramname">keys</td><td>Pointer of the keys to be looked up. </td></tr>
    <tr><td class="paramname">num_keys</td><td>The number of keys that will be lookup. </td></tr>
    <tr><td class="paramname">max_match_per_key</td><td>The possible maximum number of matches for each key. </td></tr>
    <tr><td class="paramname">match_count</td><td>Output the number of matches for each key in an array. </td></tr>
    <tr><td class="paramname">set_ids</td><td>Return set ids for all the matches of all keys. Users pass in a preallocated 2D array with first dimension as key index and second dimension as match index. For example set_ids[bulk_size][max_match_per_key] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of keys that found one or more matches in the set-summary. </dd></dl>

</div>
</div>
<a id="a034c2e16094f08d77b21f3d66f81d371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034c2e16094f08d77b21f3d66f81d371">&#9670;&nbsp;</a></span>rte_member_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_member_add </td>
          <td>(</td>
          <td class="paramtype">const struct rte_member_setsum *&#160;</td>
          <td class="paramname"><em>setsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a>&#160;</td>
          <td class="paramname"><em>set_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Insert key into set-summary (SS).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setsum</td><td>Pointer of a set-summary. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer of the key to be added. </td></tr>
    <tr><td class="paramname">set_id</td><td>The set id associated with the key that needs to be added. Different mode supports different set_id ranges. 0 cannot be used as set_id since RTE_MEMBER_NO_MATCH by default is set as 0. For HT mode, the set_id has range as [1, 0x7FFF], MSB is reserved. For vBF mode the set id is limited by the num_set parameter when create the set-summary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HT (cache mode) and vBF should never fail unless the set_id is not in the valid range. In such case -EINVAL is returned. For HT (non-cache mode) it could fail with -ENOSPC error code when table is full. For success it returns different values for different modes to provide extra information for users. Return 0 for HT (cache mode) if the add does not cause eviction, return 1 otherwise. Return 0 for non-cache mode if success, -ENOSPC for full, and 1 if cuckoo eviction happens. Always returns 0 for vBF mode. </dd></dl>

</div>
</div>
<a id="ace5e0fe1b306d39a5c559b302412ee2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5e0fe1b306d39a5c559b302412ee2a">&#9670;&nbsp;</a></span>rte_member_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_member_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_member_setsum *&#160;</td>
          <td class="paramname"><em>setsum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>De-allocate memory used by set-summary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setsum</td><td>Pointer to the set summary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad68593c306ebcfdb511ab9f822e54fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68593c306ebcfdb511ab9f822e54fdb">&#9670;&nbsp;</a></span>rte_member_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_member_reset </td>
          <td>(</td>
          <td class="paramtype">const struct rte_member_setsum *&#160;</td>
          <td class="paramname"><em>setsum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Reset the set-summary tables. E.g. reset bits to be 0 in BF, reset set_id in each entry to be RTE_MEMBER_NO_MATCH in HT based SS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setsum</td><td>Pointer to the set-summary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f94090cf8802dd9a36915f805160112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f94090cf8802dd9a36915f805160112">&#9670;&nbsp;</a></span>rte_member_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_member_delete </td>
          <td>(</td>
          <td class="paramtype">const struct rte_member_setsum *&#160;</td>
          <td class="paramname"><em>setsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__member_8h.html#ac5d5a860901554873840b6236b83ff67">member_set_t</a>&#160;</td>
          <td class="paramname"><em>set_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd><b>EXPERIMENTAL:</b> this API may change without prior notice</dd></dl>
<p>Delete items from the set-summary. Note that vBF does not support deletion in current implementation. For vBF, error code of -EINVAL will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">setsum</td><td>Pointer to the set-summary. </td></tr>
    <tr><td class="paramname">key</td><td>Pointer of the key to be deleted. </td></tr>
    <tr><td class="paramname">set_id</td><td>For HT mode, we need both key and its corresponding set_id to properly delete the key. Without set_id, we may delete other keys with the same signature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If no entry found to delete, an error code of -ENOENT could be returned. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
