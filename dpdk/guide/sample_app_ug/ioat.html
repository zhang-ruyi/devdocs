

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>15. Packet copying using Intel® QuickData Technology &mdash; Data Plane Development Kit 20.11.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="16. L2 Forwarding with Crypto Sample Application" href="l2_forward_crypto.html" />
    <link rel="prev" title="14. Keep Alive Sample Application" href="keep_alive.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Data Plane Development Kit
          

          
            
            <img src="../_static/DPDK_logo_vertical_rev_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                20.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Sample Applications User Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">1. Introduction to the DPDK Sample Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="compiling.html">2. Compiling the Sample Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="cmd_line.html">3. Command Line Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ethtool.html">4. Ethtool Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="hello_world.html">5. Hello World Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="skeleton.html">6. Basic Forwarding Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxtx_callbacks.html">7. RX/TX Callbacks Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow_classify.html">8. Flow Classify Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow_filtering.html">9. Basic RTE Flow Filtering Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_frag.html">10. IP Fragmentation Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipv4_multicast.html">11. IPv4 Multicast Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_reassembly.html">12. IP Reassembly Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel_nic_interface.html">13. Kernel NIC Interface Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="keep_alive.html">14. Keep Alive Sample Application</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">15. Packet copying using Intel® QuickData Technology</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">15.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiling-the-application">15.2. Compiling the Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-the-application">15.3. Running the Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explanation">15.4. Explanation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-main-function">15.4.1. The Main Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-lcores-launching-functions">15.4.2. The Lcores Launching Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-lcores-processing-functions">15.4.3. The Lcores Processing Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-packet-copying-functions">15.4.4. The Packet Copying Functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_crypto.html">16. L2 Forwarding with Crypto Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_job_stats.html">17. L2 Forwarding Sample Application (in Real and Virtualized Environments) with core load statistics.</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_real_virtual.html">18. L2 Forwarding Sample Application (in Real and Virtualized Environments)</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_event.html">19. L2 Forwarding Eventdev Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_cat.html">20. L2 Forwarding Sample Application with Cache Allocation Technology (CAT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="l3_forward.html">21. L3 Forwarding Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l3_forward_graph.html">22. L3 Forwarding Graph Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l3_forward_power_man.html">23. L3 Forwarding with Power Management Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l3_forward_access_ctrl.html">24. L3 Forwarding with Access Control Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="link_status_intr.html">25. Link Status Interrupt Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="server_node_efd.html">26. Server-Node EFD Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="service_cores.html">27. Service Cores Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_process.html">28. Multi-process Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_metering.html">29. QoS Metering Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_scheduler.html">30. QoS Scheduler Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer.html">31. Timer Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_ordering.html">32. Packet Ordering Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vmdq_dcb_forwarding.html">33. VMDQ and DCB Forwarding Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vmdq_forwarding.html">34. VMDq Forwarding Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost.html">35. Vhost Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost_blk.html">36. Vhost_blk Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost_crypto.html">37. Vhost_Crypto Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vdpa.html">38. Vdpa Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_pipeline.html">39. Internet Protocol (IP) Pipeline Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="test_pipeline.html">40. Test Pipeline Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="pipeline.html">41. Pipeline Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="eventdev_pipeline.html">42. Eventdev Pipeline Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="dist_app.html">43. Distributor Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vm_power_management.html">44. Virtual Machine Power Management Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptpclient.html">45. PTP Client Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance_thread.html">46. Performance Thread Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="fips_validation.html">47. Federal Information Processing Standards (FIPS) CryptoDev Validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec_secgw.html">48. IPsec Security Gateway Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="bbdev_app.html">49. Loop-back Sample Application using Baseband Device (bbdev)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">50. NTB Sample Application</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../prog_guide/index.html">Programmer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor’s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Data Plane Development Kit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Sample Applications User Guides</a> &raquo;</li>
        
      <li><span class="section-number">15. </span>Packet copying using Intel® QuickData Technology</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/sample_app_ug/ioat.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="packet-copying-using-intelreg-quickdata-technology">
<h1><span class="section-number">15. </span>Packet copying using Intel® QuickData Technology</h1>
<div class="section" id="overview">
<h2><span class="section-number">15.1. </span>Overview</h2>
<p>This sample is intended as a demonstration of the basic components of a DPDK
forwarding application and example of how to use IOAT driver API to make
packets copies.</p>
<p>Also while forwarding, the MAC addresses are affected as follows:</p>
<ul class="simple">
<li><p>The source MAC address is replaced by the TX port MAC address</p></li>
<li><p>The destination MAC address is replaced by  02:00:00:00:00:TX_PORT_ID</p></li>
</ul>
<p>This application can be used to compare performance of using software packet
copy with copy done using a DMA device for different sizes of packets.
The example will print out statistics each second. The stats shows
received/send packets and packets dropped or failed to copy.</p>
</div>
<div class="section" id="compiling-the-application">
<h2><span class="section-number">15.2. </span>Compiling the Application</h2>
<p>To compile the sample application see <a class="reference internal" href="compiling.html"><span class="doc">Compiling the Sample Applications</span></a>.</p>
<p>The application is located in the <code class="docutils literal notranslate"><span class="pre">ioat</span></code> sub-directory.</p>
</div>
<div class="section" id="running-the-application">
<h2><span class="section-number">15.3. </span>Running the Application</h2>
<p>In order to run the hardware copy application, the copying device
needs to be bound to user-space IO driver.</p>
<p>Refer to the “IOAT Rawdev Driver” chapter in the “Rawdev Drivers” document
for information on using the driver.</p>
<p>The application requires a number of command line options:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/examples/dpdk-ioat [EAL options] -- [-p MASK] [-q NQ] [-s RS] [-c &lt;sw|hw&gt;]</span>
<span class="go">    [--[no-]mac-updating]</span>
</pre></div>
</div>
<p>where,</p>
<ul class="simple">
<li><p>p MASK: A hexadecimal bitmask of the ports to configure (default is all)</p></li>
<li><p>q NQ: Number of Rx queues used per port equivalent to CBDMA channels
per port (default is 1)</p></li>
<li><p>c CT: Performed packet copy type: software (sw) or hardware using
DMA (hw) (default is hw)</p></li>
<li><p>s RS: Size of IOAT rawdev ring for hardware copy mode or rte_ring for
software copy mode (default is 2048)</p></li>
<li><p>–[no-]mac-updating: Whether MAC address of packets should be changed
or not (default is mac-updating)</p></li>
</ul>
<p>The application can be launched in various configurations depending on
provided parameters. The app can use up to 2 lcores: one of them receives
incoming traffic and makes a copy of each packet. The second lcore then
updates MAC address and sends the copy. If one lcore per port is used,
both operations are done sequentially. For each configuration an additional
lcore is needed since the main lcore does not handle traffic but is
responsible for configuration, statistics printing and safe shutdown of
all ports and devices.</p>
<p>The application can use a maximum of 8 ports.</p>
<p>To run the application in a Linux environment with 3 lcores (the main lcore,
plus two forwarding cores), a single port (port 0), software copying and MAC
updating issue the command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ./&lt;build_dir&gt;/examples/dpdk-ioat -l <span class="m">0</span>-2 -n <span class="m">2</span> -- -p 0x1 --mac-updating -c sw
</pre></div>
</div>
<p>To run the application in a Linux environment with 2 lcores (the main lcore,
plus one forwarding core), 2 ports (ports 0 and 1), hardware copying and no MAC
updating issue the command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ./&lt;build_dir&gt;/examples/dpdk-ioat -l <span class="m">0</span>-1 -n <span class="m">1</span> -- -p 0x3 --no-mac-updating -c hw
</pre></div>
</div>
<p>Refer to the <em>DPDK Getting Started Guide</em> for general information on
running applications and the Environment Abstraction Layer (EAL) options.</p>
</div>
<div class="section" id="explanation">
<h2><span class="section-number">15.4. </span>Explanation</h2>
<p>The following sections provide an explanation of the main components of the
code.</p>
<p>All DPDK library functions used in the sample code are prefixed with
<code class="docutils literal notranslate"><span class="pre">rte_</span></code> and are explained in detail in the <em>DPDK API Documentation</em>.</p>
<div class="section" id="the-main-function">
<h3><span class="section-number">15.4.1. </span>The Main Function</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">main()</span></code> function performs the initialization and calls the execution
threads for each lcore.</p>
<p>The first task is to initialize the Environment Abstraction Layer (EAL).
The <code class="docutils literal notranslate"><span class="pre">argc</span></code> and <code class="docutils literal notranslate"><span class="pre">argv</span></code> arguments are provided to the <code class="docutils literal notranslate"><span class="pre">rte_eal_init()</span></code>
function. The value returned is the number of parsed arguments:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* init EAL */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eal_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Invalid EAL arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">main()</span></code> also allocates a mempool to hold the mbufs (Message Buffers)
used by the application:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">nb_mbufs</span> <span class="o">=</span> <span class="n">RTE_MAX</span><span class="p">(</span><span class="n">rte_eth_dev_count_avail</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">nb_rxd</span> <span class="o">+</span> <span class="n">nb_txd</span>
    <span class="o">+</span> <span class="n">MAX_PKT_BURST</span> <span class="o">+</span> <span class="n">rte_lcore_count</span><span class="p">()</span> <span class="o">*</span> <span class="n">MEMPOOL_CACHE_SIZE</span><span class="p">),</span>
    <span class="n">MIN_POOL_SIZE</span><span class="p">);</span>

<span class="cm">/* Create the mbuf pool */</span>
<span class="n">ioat_pktmbuf_pool</span> <span class="o">=</span> <span class="n">rte_pktmbuf_pool_create</span><span class="p">(</span><span class="s">&quot;mbuf_pool&quot;</span><span class="p">,</span> <span class="n">nb_mbufs</span><span class="p">,</span>
    <span class="n">MEMPOOL_CACHE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RTE_MBUF_DEFAULT_BUF_SIZE</span><span class="p">,</span>
    <span class="n">rte_socket_id</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ioat_pktmbuf_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Cannot init mbuf pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Mbufs are the packet buffer structure used by DPDK. They are explained in
detail in the “Mbuf Library” section of the <em>DPDK Programmer’s Guide</em>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">main()</span></code> function also initializes the ports:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Initialise each port */</span>
<span class="n">RTE_ETH_FOREACH_DEV</span><span class="p">(</span><span class="n">portid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">port_init</span><span class="p">(</span><span class="n">portid</span><span class="p">,</span> <span class="n">ioat_pktmbuf_pool</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each port is configured using <code class="docutils literal notranslate"><span class="pre">port_init()</span></code> function. The Ethernet
ports are configured with local settings using the <code class="docutils literal notranslate"><span class="pre">rte_eth_dev_configure()</span></code>
function and the <code class="docutils literal notranslate"><span class="pre">port_conf</span></code> struct. The RSS is enabled so that
multiple Rx queues could be used for packet receiving and copying by
multiple CBDMA channels per port:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* configuring port to use RSS for multiple RX queues */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rte_eth_conf</span> <span class="n">port_conf</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">rxmode</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">mq_mode</span>        <span class="o">=</span> <span class="n">ETH_MQ_RX_RSS</span><span class="p">,</span>
        <span class="p">.</span><span class="n">max_rx_pkt_len</span> <span class="o">=</span> <span class="n">RTE_ETHER_MAX_LEN</span>
    <span class="p">},</span>
    <span class="p">.</span><span class="n">rx_adv_conf</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">rss_conf</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">rss_key</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
            <span class="p">.</span><span class="n">rss_hf</span> <span class="o">=</span> <span class="n">ETH_RSS_PROTO_MASK</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For this example the ports are set up with the number of Rx queues provided
with -q option and 1 Tx queue using the <code class="docutils literal notranslate"><span class="pre">rte_eth_rx_queue_setup()</span></code>
and <code class="docutils literal notranslate"><span class="pre">rte_eth_tx_queue_setup()</span></code> functions.</p>
<p>The Ethernet port is then started:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eth_dev_start</span><span class="p">(</span><span class="n">portid</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;rte_eth_dev_start:err=%d, port=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">ret</span><span class="p">,</span> <span class="n">portid</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally the Rx port is set in promiscuous mode:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rte_eth_promiscuous_enable</span><span class="p">(</span><span class="n">portid</span><span class="p">);</span>
</pre></div>
</div>
<p>After that each port application assigns resources needed.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">check_link_status</span><span class="p">(</span><span class="n">ioat_enabled_port_mask</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">.</span><span class="n">nb_ports</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
        <span class="s">&quot;All available ports are disabled. Please set portmask.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Check if there is enough lcores for all ports. */</span>
<span class="n">cfg</span><span class="p">.</span><span class="n">nb_lcores</span> <span class="o">=</span> <span class="n">rte_lcore_count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">nb_lcores</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
        <span class="s">&quot;There should be at least one worker lcore.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">copy_mode</span> <span class="o">==</span> <span class="n">COPY_MODE_IOAT_NUM</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assign_rawdevs</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="cm">/* copy_mode == COPY_MODE_SW_NUM */</span> <span class="p">{</span>
    <span class="n">assign_rings</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Depending on mode set (whether copy should be done by software or by hardware)
special structures are assigned to each port. If software copy was chosen,
application have to assign ring structures for packet exchanging between lcores
assigned to ports.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">assign_rings</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">nb_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">ring_name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

        <span class="n">snprintf</span><span class="p">(</span><span class="n">ring_name</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;rx_to_tx_ring_%u&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="cm">/* Create ring for inter core communication */</span>
        <span class="n">cfg</span><span class="p">.</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_to_tx_ring</span> <span class="o">=</span> <span class="n">rte_ring_create</span><span class="p">(</span>
                <span class="n">ring_name</span><span class="p">,</span> <span class="n">ring_size</span><span class="p">,</span>
                <span class="n">rte_socket_id</span><span class="p">(),</span> <span class="n">RING_F_SP_ENQ</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rx_to_tx_ring</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                    <span class="n">rte_strerror</span><span class="p">(</span><span class="n">rte_errno</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When using hardware copy each Rx queue of the port is assigned an
IOAT device (<code class="docutils literal notranslate"><span class="pre">assign_rawdevs()</span></code>) using IOAT Rawdev Driver API
functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">assign_rawdevs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">nb_rawdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rdev_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">nb_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nb_queues</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">rte_rawdev_info</span> <span class="n">rdev_info</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

            <span class="k">do</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">rdev_id</span> <span class="o">==</span> <span class="n">rte_rawdev_count</span><span class="p">())</span>
                    <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
                <span class="n">rte_rawdev_info_get</span><span class="p">(</span><span class="n">rdev_id</span><span class="o">++</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdev_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">rdev_info</span><span class="p">.</span><span class="n">driver_name</span><span class="p">,</span>
                <span class="n">IOAT_PMD_RAWDEV_NAME_STR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

            <span class="n">cfg</span><span class="p">.</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioat_ids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdev_id</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">configure_rawdev_queue</span><span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ioat_ids</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="o">++</span><span class="n">nb_rawdev</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="nl">end</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nb_rawdev</span> <span class="o">&lt;</span> <span class="n">cfg</span><span class="p">.</span><span class="n">nb_ports</span> <span class="o">*</span> <span class="n">cfg</span><span class="p">.</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nb_queues</span><span class="p">)</span>
        <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
            <span class="s">&quot;Not enough IOAT rawdevs (%u) for all queues (%u).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
            <span class="n">nb_rawdev</span><span class="p">,</span> <span class="n">cfg</span><span class="p">.</span><span class="n">nb_ports</span> <span class="o">*</span> <span class="n">cfg</span><span class="p">.</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nb_queues</span><span class="p">);</span>
    <span class="n">RTE_LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">,</span> <span class="n">IOAT</span><span class="p">,</span> <span class="s">&quot;Number of used rawdevs: %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nb_rawdev</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The initialization of hardware device is done by <code class="docutils literal notranslate"><span class="pre">rte_rawdev_configure()</span></code>
function using <code class="docutils literal notranslate"><span class="pre">rte_rawdev_info</span></code> struct. After configuration the device is
started using <code class="docutils literal notranslate"><span class="pre">rte_rawdev_start()</span></code> function. Each of the above operations
is done in <code class="docutils literal notranslate"><span class="pre">configure_rawdev_queue()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">configure_rawdev_queue</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_ioat_rawdev_config</span> <span class="n">dev_config</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">ring_size</span> <span class="o">=</span> <span class="n">ring_size</span> <span class="p">};</span>
    <span class="k">struct</span> <span class="n">rte_rawdev_info</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">dev_private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev_config</span> <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">rte_rawdev_configure</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dev_config</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
            <span class="s">&quot;Error with rte_rawdev_configure()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rte_rawdev_start</span><span class="p">(</span><span class="n">dev_id</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
            <span class="s">&quot;Error with rte_rawdev_start()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If initialization is successful, memory for hardware device
statistics is allocated.</p>
<p>Finally <code class="docutils literal notranslate"><span class="pre">main()</span></code> function starts all packet handling lcores and starts
printing stats in a loop on the main lcore. The application can be
interrupted and closed using <code class="docutils literal notranslate"><span class="pre">Ctrl-C</span></code>. The main lcore waits for
all worker lcores to finish, deallocates resources and exits.</p>
<p>The processing lcores launching function are described below.</p>
</div>
<div class="section" id="the-lcores-launching-functions">
<h3><span class="section-number">15.4.2. </span>The Lcores Launching Functions</h3>
<p>As described above, <code class="docutils literal notranslate"><span class="pre">main()</span></code> function invokes <code class="docutils literal notranslate"><span class="pre">start_forwarding_cores()</span></code>
function in order to start processing for each lcore:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">start_forwarding_cores</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">lcore_id</span> <span class="o">=</span> <span class="n">rte_lcore_id</span><span class="p">();</span>

    <span class="n">RTE_LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">,</span> <span class="n">IOAT</span><span class="p">,</span> <span class="s">&quot;Entering %s on lcore %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
            <span class="n">__func__</span><span class="p">,</span> <span class="n">rte_lcore_id</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">nb_lcores</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lcore_id</span> <span class="o">=</span> <span class="n">rte_get_next_lcore</span><span class="p">(</span><span class="n">lcore_id</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="n">rte_eal_remote_launch</span><span class="p">((</span><span class="n">lcore_function_t</span> <span class="o">*</span><span class="p">)</span><span class="n">rxtx_main_loop</span><span class="p">,</span>
            <span class="nb">NULL</span><span class="p">,</span> <span class="n">lcore_id</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="p">.</span><span class="n">nb_lcores</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lcore_id</span> <span class="o">=</span> <span class="n">rte_get_next_lcore</span><span class="p">(</span><span class="n">lcore_id</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="n">rte_eal_remote_launch</span><span class="p">((</span><span class="n">lcore_function_t</span> <span class="o">*</span><span class="p">)</span><span class="n">rx_main_loop</span><span class="p">,</span>
            <span class="nb">NULL</span><span class="p">,</span> <span class="n">lcore_id</span><span class="p">);</span>

        <span class="n">lcore_id</span> <span class="o">=</span> <span class="n">rte_get_next_lcore</span><span class="p">(</span><span class="n">lcore_id</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="n">rte_eal_remote_launch</span><span class="p">((</span><span class="n">lcore_function_t</span> <span class="o">*</span><span class="p">)</span><span class="n">tx_main_loop</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
            <span class="n">lcore_id</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function launches Rx/Tx processing functions on configured lcores
using <code class="docutils literal notranslate"><span class="pre">rte_eal_remote_launch()</span></code>. The configured ports, their number
and number of assigned lcores are stored in user-defined
<code class="docutils literal notranslate"><span class="pre">rxtx_transmission_config</span></code> struct:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rxtx_transmission_config</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rxtx_port_config</span> <span class="n">ports</span><span class="p">[</span><span class="n">RTE_MAX_ETHPORTS</span><span class="p">];</span>
    <span class="kt">uint16_t</span> <span class="n">nb_ports</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">nb_lcores</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The structure is initialized in ‘main()’ function with the values
corresponding to ports and lcores configuration provided by the user.</p>
</div>
<div class="section" id="the-lcores-processing-functions">
<h3><span class="section-number">15.4.3. </span>The Lcores Processing Functions</h3>
<p>For receiving packets on each port, the <code class="docutils literal notranslate"><span class="pre">ioat_rx_port()</span></code> function is used.
The function receives packets on each configured Rx queue. Depending on the
mode the user chose, it will enqueue packets to IOAT rawdev channels and
then invoke copy process (hardware copy), or perform software copy of each
packet using <code class="docutils literal notranslate"><span class="pre">pktmbuf_sw_copy()</span></code> function and enqueue them to an rte_ring:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Receive packets on one port and enqueue to IOAT rawdev or rte_ring. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ioat_rx_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxtx_port_config</span> <span class="o">*</span><span class="n">rx_config</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">nb_rx</span><span class="p">,</span> <span class="n">nb_enq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">pkts_burst</span><span class="p">[</span><span class="n">MAX_PKT_BURST</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rx_config</span><span class="o">-&gt;</span><span class="n">nb_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">nb_rx</span> <span class="o">=</span> <span class="n">rte_eth_rx_burst</span><span class="p">(</span><span class="n">rx_config</span><span class="o">-&gt;</span><span class="n">rxtx_port</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
            <span class="n">pkts_burst</span><span class="p">,</span> <span class="n">MAX_PKT_BURST</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nb_rx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="n">port_statistics</span><span class="p">.</span><span class="n">rx</span><span class="p">[</span><span class="n">rx_config</span><span class="o">-&gt;</span><span class="n">rxtx_port</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nb_rx</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">copy_mode</span> <span class="o">==</span> <span class="n">COPY_MODE_IOAT_NUM</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Perform packet hardware copy */</span>
            <span class="n">nb_enq</span> <span class="o">=</span> <span class="n">ioat_enqueue_packets</span><span class="p">(</span><span class="n">pkts_burst</span><span class="p">,</span>
                <span class="n">nb_rx</span><span class="p">,</span> <span class="n">rx_config</span><span class="o">-&gt;</span><span class="n">ioat_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nb_enq</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">rte_ioat_perform_ops</span><span class="p">(</span><span class="n">rx_config</span><span class="o">-&gt;</span><span class="n">ioat_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* Perform packet software copy, free source packets */</span>
            <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
            <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">pkts_burst_copy</span><span class="p">[</span><span class="n">MAX_PKT_BURST</span><span class="p">];</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_mempool_get_bulk</span><span class="p">(</span><span class="n">ioat_pktmbuf_pool</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkts_burst_copy</span><span class="p">,</span> <span class="n">nb_rx</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
                    <span class="s">&quot;Unable to allocate memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nb_rx</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">pktmbuf_sw_copy</span><span class="p">(</span><span class="n">pkts_burst</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                    <span class="n">pkts_burst_copy</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

            <span class="n">rte_mempool_put_bulk</span><span class="p">(</span><span class="n">ioat_pktmbuf_pool</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkts_burst</span><span class="p">,</span> <span class="n">nb_rx</span><span class="p">);</span>

            <span class="n">nb_enq</span> <span class="o">=</span> <span class="n">rte_ring_enqueue_burst</span><span class="p">(</span>
                <span class="n">rx_config</span><span class="o">-&gt;</span><span class="n">rx_to_tx_ring</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkts_burst_copy</span><span class="p">,</span> <span class="n">nb_rx</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

            <span class="cm">/* Free any not enqueued packets. */</span>
            <span class="n">rte_mempool_put_bulk</span><span class="p">(</span><span class="n">ioat_pktmbuf_pool</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkts_burst_copy</span><span class="p">[</span><span class="n">nb_enq</span><span class="p">],</span>
                <span class="n">nb_rx</span> <span class="o">-</span> <span class="n">nb_enq</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">port_statistics</span><span class="p">.</span><span class="n">copy_dropped</span><span class="p">[</span><span class="n">rx_config</span><span class="o">-&gt;</span><span class="n">rxtx_port</span><span class="p">]</span> <span class="o">+=</span>
            <span class="p">(</span><span class="n">nb_rx</span> <span class="o">-</span> <span class="n">nb_enq</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The packets are received in burst mode using <code class="docutils literal notranslate"><span class="pre">rte_eth_rx_burst()</span></code>
function. When using hardware copy mode the packets are enqueued in
copying device’s buffer using <code class="docutils literal notranslate"><span class="pre">ioat_enqueue_packets()</span></code> which calls
<code class="docutils literal notranslate"><span class="pre">rte_ioat_enqueue_copy()</span></code>. When all received packets are in the
buffer the copy operations are started by calling <code class="docutils literal notranslate"><span class="pre">rte_ioat_perform_ops()</span></code>.
Function <code class="docutils literal notranslate"><span class="pre">rte_ioat_enqueue_copy()</span></code> operates on physical address of
the packet. Structure <code class="docutils literal notranslate"><span class="pre">rte_mbuf</span></code> contains only physical address to
start of the data buffer (<code class="docutils literal notranslate"><span class="pre">buf_iova</span></code>). Thus the address is adjusted
by <code class="docutils literal notranslate"><span class="pre">addr_offset</span></code> value in order to get the address of <code class="docutils literal notranslate"><span class="pre">rearm_data</span></code>
member of <code class="docutils literal notranslate"><span class="pre">rte_mbuf</span></code>. That way both the packet data and metadata can
be copied in a single operation. This method can be used because the mbufs
are direct mbufs allocated by the apps. If another app uses external buffers,
or indirect mbufs, then multiple copy operations must be used.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">ioat_enqueue_packets</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">**</span><span class="n">pkts</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">nb_rx</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">pkts_copy</span><span class="p">[</span><span class="n">MAX_PKT_BURST</span><span class="p">];</span>

    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">addr_offset</span> <span class="o">=</span> <span class="n">RTE_PTR_DIFF</span><span class="p">(</span><span class="n">pkts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buf_addr</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">pkts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">rearm_data</span><span class="p">);</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_mempool_get_bulk</span><span class="p">(</span><span class="n">ioat_pktmbuf_pool</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pkts_copy</span><span class="p">,</span> <span class="n">nb_rx</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Unable to allocate memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nb_rx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Perform data copy */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_ioat_enqueue_copy</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span>
            <span class="n">pkts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buf_iova</span>
                <span class="o">-</span> <span class="n">addr_offset</span><span class="p">,</span>
            <span class="n">pkts_copy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">buf_iova</span>
                <span class="o">-</span> <span class="n">addr_offset</span><span class="p">,</span>
            <span class="n">rte_pktmbuf_data_len</span><span class="p">(</span><span class="n">pkts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="o">+</span> <span class="n">addr_offset</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">pkts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">pkts_copy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="mi">0</span> <span class="cm">/* nofence */</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="cm">/* Free any not enqueued packets. */</span>
    <span class="n">rte_mempool_put_bulk</span><span class="p">(</span><span class="n">ioat_pktmbuf_pool</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nb_rx</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">rte_mempool_put_bulk</span><span class="p">(</span><span class="n">ioat_pktmbuf_pool</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pkts_copy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
        <span class="n">nb_rx</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All completed copies are processed by <code class="docutils literal notranslate"><span class="pre">ioat_tx_port()</span></code> function. When using
hardware copy mode the function invokes <code class="docutils literal notranslate"><span class="pre">rte_ioat_completed_ops()</span></code>
on each assigned IOAT channel to gather copied packets. If software copy
mode is used the function dequeues copied packets from the rte_ring. Then each
packet MAC address is changed if it was enabled. After that copies are sent
in burst mode using `` rte_eth_tx_burst()``.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Transmit packets from IOAT rawdev/rte_ring for one port. */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">ioat_tx_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">rxtx_port_config</span> <span class="o">*</span><span class="n">tx_config</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">nb_dq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">mbufs_src</span><span class="p">[</span><span class="n">MAX_PKT_BURST</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">mbufs_dst</span><span class="p">[</span><span class="n">MAX_PKT_BURST</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tx_config</span><span class="o">-&gt;</span><span class="n">nb_queues</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copy_mode</span> <span class="o">==</span> <span class="n">COPY_MODE_IOAT_NUM</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Deque the mbufs from IOAT device. */</span>
            <span class="n">nb_dq</span> <span class="o">=</span> <span class="n">rte_ioat_completed_ops</span><span class="p">(</span>
                <span class="n">tx_config</span><span class="o">-&gt;</span><span class="n">ioat_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">MAX_PKT_BURST</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mbufs_src</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mbufs_dst</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* Deque the mbufs from rx_to_tx_ring. */</span>
            <span class="n">nb_dq</span> <span class="o">=</span> <span class="n">rte_ring_dequeue_burst</span><span class="p">(</span>
                <span class="n">tx_config</span><span class="o">-&gt;</span><span class="n">rx_to_tx_ring</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mbufs_dst</span><span class="p">,</span>
                <span class="n">MAX_PKT_BURST</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nb_dq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">copy_mode</span> <span class="o">==</span> <span class="n">COPY_MODE_IOAT_NUM</span><span class="p">)</span>
            <span class="n">rte_mempool_put_bulk</span><span class="p">(</span><span class="n">ioat_pktmbuf_pool</span><span class="p">,</span>
                <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mbufs_src</span><span class="p">,</span> <span class="n">nb_dq</span><span class="p">);</span>

        <span class="cm">/* Update macs if enabled */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mac_updating</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nb_dq</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">update_mac_addrs</span><span class="p">(</span><span class="n">mbufs_dst</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                    <span class="n">tx_config</span><span class="o">-&gt;</span><span class="n">rxtx_port</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">nb_tx</span> <span class="o">=</span> <span class="n">rte_eth_tx_burst</span><span class="p">(</span>
            <span class="n">tx_config</span><span class="o">-&gt;</span><span class="n">rxtx_port</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mbufs_dst</span><span class="p">,</span> <span class="n">nb_dq</span><span class="p">);</span>

        <span class="n">port_statistics</span><span class="p">.</span><span class="n">tx</span><span class="p">[</span><span class="n">tx_config</span><span class="o">-&gt;</span><span class="n">rxtx_port</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nb_tx</span><span class="p">;</span>

        <span class="cm">/* Free any unsent packets. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nb_tx</span> <span class="o">&lt;</span> <span class="n">nb_dq</span><span class="p">))</span>
            <span class="n">rte_mempool_put_bulk</span><span class="p">(</span><span class="n">ioat_pktmbuf_pool</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbufs_dst</span><span class="p">[</span><span class="n">nb_tx</span><span class="p">],</span>
                <span class="n">nb_dq</span> <span class="o">-</span> <span class="n">nb_tx</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-packet-copying-functions">
<h3><span class="section-number">15.4.4. </span>The Packet Copying Functions</h3>
<p>In order to perform packet copy there is a user-defined function
<code class="docutils literal notranslate"><span class="pre">pktmbuf_sw_copy()</span></code> used. It copies a whole packet by copying
metadata from source packet to new mbuf, and then copying a data
chunk of source packet. Both memory copies are done using
<code class="docutils literal notranslate"><span class="pre">rte_memcpy()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">pktmbuf_sw_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Copy packet metadata */</span>
    <span class="n">rte_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">rearm_data</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">rearm_data</span><span class="p">,</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mbuf</span><span class="p">,</span> <span class="n">cacheline1</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mbuf</span><span class="p">,</span> <span class="n">rearm_data</span><span class="p">));</span>

    <span class="cm">/* Copy packet data */</span>
    <span class="n">rte_memcpy</span><span class="p">(</span><span class="n">rte_pktmbuf_mtod</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">),</span>
        <span class="n">rte_pktmbuf_mtod</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">),</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">data_len</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The metadata in this example is copied from <code class="docutils literal notranslate"><span class="pre">rearm_data</span></code> member of
<code class="docutils literal notranslate"><span class="pre">rte_mbuf</span></code> struct up to <code class="docutils literal notranslate"><span class="pre">cacheline1</span></code>.</p>
<p>In order to understand why software packet copying is done as shown
above please refer to the “Mbuf Library” section of the
<em>DPDK Programmer’s Guide</em>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="l2_forward_crypto.html" class="btn btn-neutral float-right" title="16. L2 Forwarding with Crypto Sample Application" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="keep_alive.html" class="btn btn-neutral float-left" title="14. Keep Alive Sample Application" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>