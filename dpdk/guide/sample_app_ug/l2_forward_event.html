

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>19. L2 Forwarding Eventdev Sample Application &mdash; Data Plane Development Kit 20.11.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="20. L2 Forwarding Sample Application with Cache Allocation Technology (CAT)" href="l2_forward_cat.html" />
    <link rel="prev" title="18. L2 Forwarding Sample Application (in Real and Virtualized Environments)" href="l2_forward_real_virtual.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Data Plane Development Kit
          

          
            
            <img src="../_static/DPDK_logo_vertical_rev_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                20.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Sample Applications User Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">1. Introduction to the DPDK Sample Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="compiling.html">2. Compiling the Sample Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="cmd_line.html">3. Command Line Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ethtool.html">4. Ethtool Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="hello_world.html">5. Hello World Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="skeleton.html">6. Basic Forwarding Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="rxtx_callbacks.html">7. RX/TX Callbacks Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow_classify.html">8. Flow Classify Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow_filtering.html">9. Basic RTE Flow Filtering Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_frag.html">10. IP Fragmentation Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipv4_multicast.html">11. IPv4 Multicast Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_reassembly.html">12. IP Reassembly Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel_nic_interface.html">13. Kernel NIC Interface Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="keep_alive.html">14. Keep Alive Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ioat.html">15. Packet copying using Intel® QuickData Technology</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_crypto.html">16. L2 Forwarding with Crypto Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_job_stats.html">17. L2 Forwarding Sample Application (in Real and Virtualized Environments) with core load statistics.</a></li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_real_virtual.html">18. L2 Forwarding Sample Application (in Real and Virtualized Environments)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">19. L2 Forwarding Eventdev Sample Application</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">19.1. Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiling-the-application">19.2. Compiling the Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-the-application">19.3. Running the Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explanation">19.4. Explanation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#command-line-arguments">19.4.1. Command Line Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mbuf-pool-initialization">19.4.2. Mbuf Pool Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-initialization">19.4.3. Driver Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rx-queue-initialization">19.4.4. RX Queue Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tx-queue-initialization">19.4.5. TX Queue Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#event-device-initialization">19.4.6. Event device Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#event-queue-initialization">19.4.7. Event queue Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#event-port-initialization">19.4.8. Event port Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rx-tx-adapter-initialization">19.4.9. Rx/Tx adapter Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#receive-process-and-transmit-packets">19.4.10. Receive, Process and Transmit Packets</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="l2_forward_cat.html">20. L2 Forwarding Sample Application with Cache Allocation Technology (CAT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="l3_forward.html">21. L3 Forwarding Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l3_forward_graph.html">22. L3 Forwarding Graph Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l3_forward_power_man.html">23. L3 Forwarding with Power Management Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="l3_forward_access_ctrl.html">24. L3 Forwarding with Access Control Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="link_status_intr.html">25. Link Status Interrupt Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="server_node_efd.html">26. Server-Node EFD Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="service_cores.html">27. Service Cores Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_process.html">28. Multi-process Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_metering.html">29. QoS Metering Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_scheduler.html">30. QoS Scheduler Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer.html">31. Timer Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_ordering.html">32. Packet Ordering Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vmdq_dcb_forwarding.html">33. VMDQ and DCB Forwarding Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vmdq_forwarding.html">34. VMDq Forwarding Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost.html">35. Vhost Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost_blk.html">36. Vhost_blk Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost_crypto.html">37. Vhost_Crypto Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vdpa.html">38. Vdpa Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_pipeline.html">39. Internet Protocol (IP) Pipeline Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="test_pipeline.html">40. Test Pipeline Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="pipeline.html">41. Pipeline Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="eventdev_pipeline.html">42. Eventdev Pipeline Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="dist_app.html">43. Distributor Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="vm_power_management.html">44. Virtual Machine Power Management Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="ptpclient.html">45. PTP Client Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance_thread.html">46. Performance Thread Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="fips_validation.html">47. Federal Information Processing Standards (FIPS) CryptoDev Validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec_secgw.html">48. IPsec Security Gateway Sample Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="bbdev_app.html">49. Loop-back Sample Application using Baseband Device (bbdev)</a></li>
<li class="toctree-l2"><a class="reference internal" href="ntb.html">50. NTB Sample Application</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../prog_guide/index.html">Programmer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor’s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Data Plane Development Kit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Sample Applications User Guides</a> &raquo;</li>
        
      <li><span class="section-number">19. </span>L2 Forwarding Eventdev Sample Application</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/sample_app_ug/l2_forward_event.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="l2-forwarding-eventdev-sample-application">
<span id="l2-fwd-event-app"></span><h1><span class="section-number">19. </span>L2 Forwarding Eventdev Sample Application</h1>
<p>The L2 Forwarding eventdev sample application is a simple example of packet
processing using the Data Plane Development Kit (DPDK) to demonstrate usage of
poll and event mode packet I/O mechanism.</p>
<div class="section" id="overview">
<h2><span class="section-number">19.1. </span>Overview</h2>
<p>The L2 Forwarding eventdev sample application, performs L2 forwarding for each
packet that is received on an RX_PORT. The destination port is the adjacent port
from the enabled portmask, that is, if the first four ports are enabled (portmask=0x0f),
ports 1 and 2 forward into each other, and ports 3 and 4 forward into each other.
Also, if MAC addresses updating is enabled, the MAC addresses are affected as follows:</p>
<ul class="simple">
<li><p>The source MAC address is replaced by the TX_PORT MAC address</p></li>
<li><p>The destination MAC address is replaced by  02:00:00:00:00:TX_PORT_ID</p></li>
</ul>
<p>Application receives packets from RX_PORT using below mentioned methods:</p>
<ul class="simple">
<li><p>Poll mode</p></li>
<li><p>Eventdev mode (default)</p></li>
</ul>
<p>This application can be used to benchmark performance using a traffic-generator,
as shown in the <a class="reference internal" href="#figure-l2fwd-event-benchmark-setup"><span class="std std-numref">Fig. 19.1</span></a>.</p>
<div class="figure align-default" id="id1">
<span id="figure-l2fwd-event-benchmark-setup"></span><img alt="../_images/l2_fwd_benchmark_setup.svg" src="../_images/l2_fwd_benchmark_setup.svg" /><p class="caption"><span class="caption-number">Fig. 19.1 </span><span class="caption-text">Performance Benchmark Setup (Basic Environment)</span></p>
</div>
</div>
<div class="section" id="compiling-the-application">
<h2><span class="section-number">19.2. </span>Compiling the Application</h2>
<p>To compile the sample application see <a class="reference internal" href="compiling.html"><span class="doc">Compiling the Sample Applications</span></a>.</p>
<p>The application is located in the <code class="docutils literal notranslate"><span class="pre">l2fwd-event</span></code> sub-directory.</p>
</div>
<div class="section" id="running-the-application">
<h2><span class="section-number">19.3. </span>Running the Application</h2>
<p>The application requires a number of command line options:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/examples/dpdk-l2fwd-event [EAL options] -- -p PORTMASK [-q NQ] --[no-]mac-updating --mode=MODE --eventq-sched=SCHED_MODE</span>
</pre></div>
</div>
<p>where,</p>
<ul class="simple">
<li><p>p PORTMASK: A hexadecimal bitmask of the ports to configure</p></li>
<li><p>q NQ: A number of queues (=ports) per lcore (default is 1)</p></li>
<li><p>–[no-]mac-updating: Enable or disable MAC addresses updating (enabled by default).</p></li>
<li><p>–mode=MODE: Packet transfer mode for I/O, poll or eventdev. Eventdev by default.</p></li>
<li><p>–eventq-sched=SCHED_MODE: Event queue schedule mode, Ordered, Atomic or Parallel. Atomic by default.</p></li>
<li><p>–config: Configure forwarding port pair mapping. Alternate port pairs by default.</p></li>
</ul>
<p>Sample usage commands are given below to run the application into different mode:</p>
<p>Poll mode with 4 lcores, 16 ports and 8 RX queues per lcore and MAC address updating enabled,
issue the command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/examples/dpdk-l2fwd-event -l 0-3 -n 4 -- -q 8 -p ffff --mode=poll</span>
</pre></div>
</div>
<p>Eventdev mode with 4 lcores, 16 ports , sched method ordered and MAC address updating enabled,
issue the command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/examples/dpdk-l2fwd-event -l 0-3 -n 4 -- -p ffff --eventq-sched=ordered</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/examples/dpdk-l2fwd-event -l 0-3 -n 4 -- -q 8 -p ffff --mode=eventdev --eventq-sched=ordered</span>
</pre></div>
</div>
<p>Refer to the <em>DPDK Getting Started Guide</em> for general information on running
applications and the Environment Abstraction Layer (EAL) options.</p>
<p>To run application with S/W scheduler, it uses following DPDK services:</p>
<ul class="simple">
<li><p>Software scheduler</p></li>
<li><p>Rx adapter service function</p></li>
<li><p>Tx adapter service function</p></li>
</ul>
<p>Application needs service cores to run above mentioned services. Service cores
must be provided as EAL parameters along with the –vdev=event_sw0 to enable S/W
scheduler. Following is the sample command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/examples/dpdk-l2fwd-event -l 0-7 -s 0-3 -n 4 --vdev event_sw0 -- -q 8 -p ffff --mode=eventdev --eventq-sched=ordered</span>
</pre></div>
</div>
</div>
<div class="section" id="explanation">
<h2><span class="section-number">19.4. </span>Explanation</h2>
<p>The following sections provide some explanation of the code.</p>
<div class="section" id="command-line-arguments">
<span id="l2-fwd-event-app-cmd-arguments"></span><h3><span class="section-number">19.4.1. </span>Command Line Arguments</h3>
<p>The L2 Forwarding eventdev sample application takes specific parameters,
in addition to Environment Abstraction Layer (EAL) arguments.
The preferred way to parse parameters is to use the getopt() function,
since it is part of a well-defined and portable library.</p>
<p>The parsing of arguments is done in the <strong>l2fwd_parse_args()</strong> function for non
eventdev parameters and in <strong>parse_eventdev_args()</strong> for eventdev parameters.
The method of argument parsing is not described here. Refer to the
<em>glibc getopt(3)</em> man page for details.</p>
<p>EAL arguments are parsed first, then application-specific arguments.
This is done at the beginning of the main() function and eventdev parameters
are parsed in eventdev_resource_setup() function during eventdev setup:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* init EAL */</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eal_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Invalid EAL arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="n">argc</span> <span class="o">-=</span> <span class="n">ret</span><span class="p">;</span>
<span class="n">argv</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

<span class="cm">/* parse application arguments (after the EAL ones) */</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">l2fwd_parse_args</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Invalid L2FWD arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">.</span>
<span class="p">.</span>
<span class="p">.</span>

<span class="cm">/* Parse eventdev command line options */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">parse_eventdev_args</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="mbuf-pool-initialization">
<span id="l2-fwd-event-app-mbuf-init"></span><h3><span class="section-number">19.4.2. </span>Mbuf Pool Initialization</h3>
<p>Once the arguments are parsed, the mbuf pool is created.
The mbuf pool contains a set of mbuf objects that will be used by the driver
and the application to store network packet data:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* create the mbuf pool */</span>

<span class="n">l2fwd_pktmbuf_pool</span> <span class="o">=</span> <span class="n">rte_pktmbuf_pool_create</span><span class="p">(</span><span class="s">&quot;mbuf_pool&quot;</span><span class="p">,</span> <span class="n">NB_MBUF</span><span class="p">,</span>
                                             <span class="n">MEMPOOL_CACHE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                             <span class="n">RTE_MBUF_DEFAULT_BUF_SIZE</span><span class="p">,</span>
                                             <span class="n">rte_socket_id</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">l2fwd_pktmbuf_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Cannot init mbuf pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The rte_mempool is a generic structure used to handle pools of objects.
In this case, it is necessary to create a pool that will be used by the driver.
The number of allocated pkt mbufs is NB_MBUF, with a data room size of
RTE_MBUF_DEFAULT_BUF_SIZE each.
A per-lcore cache of 32 mbufs is kept.
The memory is allocated in NUMA socket 0,
but it is possible to extend this code to allocate one mbuf pool per socket.</p>
<p>The rte_pktmbuf_pool_create() function uses the default mbuf pool and mbuf
initializers, respectively rte_pktmbuf_pool_init() and rte_pktmbuf_init().
An advanced application may want to use the mempool API to create the
mbuf pool with more control.</p>
</div>
<div class="section" id="driver-initialization">
<span id="l2-fwd-event-app-drv-init"></span><h3><span class="section-number">19.4.3. </span>Driver Initialization</h3>
<p>The main part of the code in the main() function relates to the initialization
of the driver. To fully understand this code, it is recommended to study the
chapters that related to the Poll Mode and Event mode Driver in the
<em>DPDK Programmer’s Guide</em> - Rel 1.4 EAR and the <em>DPDK API Reference</em>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* reset l2fwd_dst_ports */</span>

<span class="k">for</span> <span class="p">(</span><span class="n">portid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">portid</span> <span class="o">&lt;</span> <span class="n">RTE_MAX_ETHPORTS</span><span class="p">;</span> <span class="n">portid</span><span class="o">++</span><span class="p">)</span>
    <span class="n">l2fwd_dst_ports</span><span class="p">[</span><span class="n">portid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">last_port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Each logical core is assigned a dedicated TX queue on each port.</span>
<span class="cm"> */</span>

<span class="n">RTE_ETH_FOREACH_DEV</span><span class="p">(</span><span class="n">portid</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* skip ports that are not enabled */</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">l2fwd_enabled_port_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">portid</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
       <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nb_ports_in_mask</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">l2fwd_dst_ports</span><span class="p">[</span><span class="n">portid</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_port</span><span class="p">;</span>
        <span class="n">l2fwd_dst_ports</span><span class="p">[</span><span class="n">last_port</span><span class="p">]</span> <span class="o">=</span> <span class="n">portid</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
       <span class="n">last_port</span> <span class="o">=</span> <span class="n">portid</span><span class="p">;</span>

    <span class="n">nb_ports_in_mask</span><span class="o">++</span><span class="p">;</span>

    <span class="n">rte_eth_dev_info_get</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="n">portid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_info</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The next step is to configure the RX and TX queues. For each port, there is only
one RX queue (only one lcore is able to poll a given port). The number of TX
queues depends on the number of available lcores. The rte_eth_dev_configure()
function is used to configure the number of queues for a port:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eth_dev_configure</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)</span><span class="n">portid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port_conf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Cannot configure device: err=%d, port=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
              <span class="n">ret</span><span class="p">,</span> <span class="n">portid</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="rx-queue-initialization">
<span id="l2-fwd-event-app-rx-init"></span><h3><span class="section-number">19.4.4. </span>RX Queue Initialization</h3>
<p>The application uses one lcore to poll one or several ports, depending on the -q
option, which specifies the number of queues per lcore.</p>
<p>For example, if the user specifies -q 4, the application is able to poll four
ports with one lcore. If there are 16 ports on the target (and if the portmask
argument is -p ffff ), the application will need four lcores to poll all the
ports.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eth_rx_queue_setup</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="n">portid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nb_rxd</span><span class="p">,</span> <span class="n">SOCKET0</span><span class="p">,</span>
                             <span class="o">&amp;</span><span class="n">rx_conf</span><span class="p">,</span> <span class="n">l2fwd_pktmbuf_pool</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;rte_eth_rx_queue_setup: err=%d, port=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
              <span class="n">ret</span><span class="p">,</span> <span class="n">portid</span><span class="p">);</span>
</pre></div>
</div>
<p>The list of queues that must be polled for a given lcore is stored in a private
structure called struct lcore_queue_conf.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">lcore_queue_conf</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">n_rx_port</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">rx_port_list</span><span class="p">[</span><span class="n">MAX_RX_QUEUE_PER_LCORE</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">mbuf_table</span> <span class="n">tx_mbufs</span><span class="p">[</span><span class="n">L2FWD_MAX_PORTS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">rte_cache_aligned</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">lcore_queue_conf</span> <span class="n">lcore_queue_conf</span><span class="p">[</span><span class="n">RTE_MAX_LCORE</span><span class="p">];</span>
</pre></div>
</div>
<p>The values n_rx_port and rx_port_list[] are used in the main packet processing
loop (see <a class="reference internal" href="#l2-fwd-event-app-rx-tx-packets"><span class="std std-ref">Receive, Process and Transmit Packets</span></a>).</p>
</div>
<div class="section" id="tx-queue-initialization">
<span id="l2-fwd-event-app-tx-init"></span><h3><span class="section-number">19.4.5. </span>TX Queue Initialization</h3>
<p>Each lcore should be able to transmit on any port. For every port, a single TX
queue is initialized.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* init one TX queue on each port */</span>

<span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eth_tx_queue_setup</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="n">portid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nb_txd</span><span class="p">,</span>
                             <span class="n">rte_eth_dev_socket_id</span><span class="p">(</span><span class="n">portid</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">tx_conf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;rte_eth_tx_queue_setup:err=%d, port=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
              <span class="n">ret</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">portid</span><span class="p">);</span>
</pre></div>
</div>
<p>To configure eventdev support, application setups following components:</p>
<ul class="simple">
<li><p>Event dev</p></li>
<li><p>Event queue</p></li>
<li><p>Event Port</p></li>
<li><p>Rx/Tx adapters</p></li>
<li><p>Ethernet ports</p></li>
</ul>
</div>
<div class="section" id="event-device-initialization">
<span id="l2-fwd-event-app-event-dev-init"></span><h3><span class="section-number">19.4.6. </span>Event device Initialization</h3>
<p>Application can use either H/W or S/W based event device scheduler
implementation and supports single instance of event device. It configures event
device as per below configuration</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_event_dev_config</span> <span class="n">event_d_conf</span> <span class="o">=</span> <span class="p">{</span>
     <span class="p">.</span><span class="n">nb_event_queues</span> <span class="o">=</span> <span class="n">ethdev_count</span><span class="p">,</span> <span class="cm">/* Dedicated to each Ethernet port */</span>
     <span class="p">.</span><span class="n">nb_event_ports</span> <span class="o">=</span> <span class="n">num_workers</span><span class="p">,</span> <span class="cm">/* Dedicated to each lcore */</span>
     <span class="p">.</span><span class="n">nb_events_limit</span>  <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span>
     <span class="p">.</span><span class="n">nb_event_queue_flows</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
     <span class="p">.</span><span class="n">nb_event_port_dequeue_depth</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
     <span class="p">.</span><span class="n">nb_event_port_enqueue_depth</span> <span class="o">=</span> <span class="mi">128</span>
<span class="p">};</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_dev_configure</span><span class="p">(</span><span class="n">event_d_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_d_conf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
     <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Error in configuring event device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>In case of S/W scheduler, application runs eventdev scheduler service on service
core. Application retrieves service id and finds the best possible service core to
run S/W scheduler.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rte_event_dev_info_get</span><span class="p">(</span><span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">event_d_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">evdev_info</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">evdev_info</span><span class="p">.</span><span class="n">event_dev_cap</span>  <span class="o">&amp;</span> <span class="n">RTE_EVENT_DEV_CAP_DISTRIBUTED_SCHED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_dev_service_id_get</span><span class="p">(</span><span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">event_d_id</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">service_id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESRCH</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Error in starting eventdev service</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">l2fwd_event_service_enable</span><span class="p">(</span><span class="n">service_id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="event-queue-initialization">
<span id="l2-fwd-app-event-queue-init"></span><h3><span class="section-number">19.4.7. </span>Event queue Initialization</h3>
<p>Each Ethernet device is assigned a dedicated event queue which will be linked
to all available event ports i.e. each lcore can dequeue packets from any of the
Ethernet ports.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_event_queue_conf</span> <span class="n">event_q_conf</span> <span class="o">=</span> <span class="p">{</span>
     <span class="p">.</span><span class="n">nb_atomic_flows</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
     <span class="p">.</span><span class="n">nb_atomic_order_sequences</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
     <span class="p">.</span><span class="n">event_queue_cfg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
     <span class="p">.</span><span class="n">schedule_type</span> <span class="o">=</span> <span class="n">RTE_SCHED_TYPE_ATOMIC</span><span class="p">,</span>
     <span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">RTE_EVENT_DEV_PRIORITY_HIGHEST</span>
<span class="p">};</span>

<span class="cm">/* User requested sched mode */</span>
<span class="n">event_q_conf</span><span class="p">.</span><span class="n">schedule_type</span> <span class="o">=</span> <span class="n">eventq_sched_mode</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">event_q_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">event_q_id</span> <span class="o">&lt;</span> <span class="n">ethdev_count</span><span class="p">;</span> <span class="n">event_q_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_queue_setup</span><span class="p">(</span><span class="n">event_d_id</span><span class="p">,</span> <span class="n">event_q_id</span><span class="p">,</span>
                                         <span class="o">&amp;</span><span class="n">event_q_conf</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
           <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Error in configuring event queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In case of S/W scheduler, an extra event queue is created which will be used for
Tx adapter service function for enqueue operation.</p>
</div>
<div class="section" id="event-port-initialization">
<span id="l2-fwd-app-event-port-init"></span><h3><span class="section-number">19.4.8. </span>Event port Initialization</h3>
<p>Each worker thread is assigned a dedicated event port for enq/deq operations
to/from an event device. All event ports are linked with all available event
queues.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_event_port_conf</span> <span class="n">event_p_conf</span> <span class="o">=</span> <span class="p">{</span>
     <span class="p">.</span><span class="n">dequeue_depth</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
     <span class="p">.</span><span class="n">enqueue_depth</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
     <span class="p">.</span><span class="n">new_event_threshold</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="p">};</span>

<span class="k">for</span> <span class="p">(</span><span class="n">event_p_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">event_p_id</span> <span class="o">&lt;</span> <span class="n">num_workers</span><span class="p">;</span> <span class="n">event_p_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_port_setup</span><span class="p">(</span><span class="n">event_d_id</span><span class="p">,</span> <span class="n">event_p_id</span><span class="p">,</span>
                                <span class="o">&amp;</span><span class="n">event_p_conf</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
           <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Error in configuring event port %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">event_p_id</span><span class="p">);</span>

     <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_port_link</span><span class="p">(</span><span class="n">event_d_id</span><span class="p">,</span> <span class="n">event_p_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                               <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
           <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Error in linking event port %d to queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                     <span class="n">event_p_id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In case of S/W scheduler, an extra event port is created by DPDK library which
is retrieved  by the application and same will be used by Tx adapter service.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_tx_adapter_event_port_get</span><span class="p">(</span><span class="n">tx_adptr_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tx_port_id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Failed to get Tx adapter port id: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_port_link</span><span class="p">(</span><span class="n">event_d_id</span><span class="p">,</span> <span class="n">tx_port_id</span><span class="p">,</span>
                          <span class="o">&amp;</span><span class="n">evt_rsrc</span><span class="p">.</span><span class="n">evq</span><span class="p">.</span><span class="n">event_q_id</span><span class="p">[</span>
                                <span class="n">evt_rsrc</span><span class="p">.</span><span class="n">evq</span><span class="p">.</span><span class="n">nb_queues</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                          <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Unable to link Tx adapter port to Tx queue:err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                  <span class="n">ret</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="rx-tx-adapter-initialization">
<span id="l2-fwd-event-app-adapter-init"></span><h3><span class="section-number">19.4.9. </span>Rx/Tx adapter Initialization</h3>
<p>Each Ethernet port is assigned a dedicated Rx/Tx adapter for H/W scheduler. Each
Ethernet port’s Rx queues are connected to its respective event queue at
priority 0 via Rx adapter configuration and Ethernet port’s tx queues are
connected via Tx adapter.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">RTE_ETH_FOREACH_DEV</span><span class="p">(</span><span class="n">port_id</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">enabled_port_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port_id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_rx_adapter_create</span><span class="p">(</span><span class="n">adapter_id</span><span class="p">,</span> <span class="n">event_d_id</span><span class="p">,</span>
                                        <span class="o">&amp;</span><span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">def_p_conf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Failed to create rx adapter[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                          <span class="n">adapter_id</span><span class="p">);</span>

        <span class="cm">/* Configure user requested sched type*/</span>
        <span class="n">eth_q_conf</span><span class="p">.</span><span class="n">ev</span><span class="p">.</span><span class="n">sched_type</span> <span class="o">=</span> <span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">sched_type</span><span class="p">;</span>
        <span class="n">eth_q_conf</span><span class="p">.</span><span class="n">ev</span><span class="p">.</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">evq</span><span class="p">.</span><span class="n">event_q_id</span><span class="p">[</span><span class="n">q_id</span><span class="p">];</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_rx_adapter_queue_add</span><span class="p">(</span><span class="n">adapter_id</span><span class="p">,</span> <span class="n">port_id</span><span class="p">,</span>
                                                 <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eth_q_conf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Failed to add queues to Rx adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_rx_adapter_start</span><span class="p">(</span><span class="n">adapter_id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Rx adapter[%d] start Failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter_id</span><span class="p">);</span>

        <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">rx_adptr</span><span class="p">.</span><span class="n">rx_adptr</span><span class="p">[</span><span class="n">adapter_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter_id</span><span class="p">;</span>
        <span class="n">adapter_id</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">q_id</span> <span class="o">&lt;</span> <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">evq</span><span class="p">.</span><span class="n">nb_queues</span><span class="p">)</span>
                <span class="n">q_id</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">adapter_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">RTE_ETH_FOREACH_DEV</span><span class="p">(</span><span class="n">port_id</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">enabled_port_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">port_id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_tx_adapter_create</span><span class="p">(</span><span class="n">adapter_id</span><span class="p">,</span> <span class="n">event_d_id</span><span class="p">,</span>
                                        <span class="o">&amp;</span><span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">def_p_conf</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Failed to create tx adapter[%d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                          <span class="n">adapter_id</span><span class="p">);</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_tx_adapter_queue_add</span><span class="p">(</span><span class="n">adapter_id</span><span class="p">,</span> <span class="n">port_id</span><span class="p">,</span>
                                                 <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Failed to add queues to Tx adapter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_tx_adapter_start</span><span class="p">(</span><span class="n">adapter_id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Tx adapter[%d] start Failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter_id</span><span class="p">);</span>

        <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">tx_adptr</span><span class="p">.</span><span class="n">tx_adptr</span><span class="p">[</span><span class="n">adapter_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter_id</span><span class="p">;</span>
        <span class="n">adapter_id</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For S/W scheduler instead of dedicated adapters, common Rx/Tx adapters are
configured which will be shared among all the Ethernet ports. Also DPDK library
need service cores to run internal services for Rx/Tx adapters. Application gets
service id for Rx/Tx adapters and after successful setup it runs the services
on dedicated service cores.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">rx_adptr</span><span class="p">.</span><span class="n">nb_rx_adptr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_rx_adapter_caps_get</span><span class="p">(</span><span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">event_d_id</span><span class="p">,</span>
                        <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">rx_adptr</span><span class="p">.</span><span class="n">rx_adptr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">caps</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Failed to get Rx adapter[%d] caps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                          <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">rx_adptr</span><span class="p">.</span><span class="n">rx_adptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_rx_adapter_service_id_get</span><span class="p">(</span>
                                        <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">event_d_id</span><span class="p">,</span>
                                        <span class="o">&amp;</span><span class="n">service_id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESRCH</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Error in starting Rx adapter[%d] service</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                          <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">rx_adptr</span><span class="p">.</span><span class="n">rx_adptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">l2fwd_event_service_enable</span><span class="p">(</span><span class="n">service_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">tx_adptr</span><span class="p">.</span><span class="n">nb_tx_adptr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_tx_adapter_caps_get</span><span class="p">(</span><span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">event_d_id</span><span class="p">,</span>
                        <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">tx_adptr</span><span class="p">.</span><span class="n">tx_adptr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">caps</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Failed to get Rx adapter[%d] caps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                          <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">tx_adptr</span><span class="p">.</span><span class="n">tx_adptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_event_eth_tx_adapter_service_id_get</span><span class="p">(</span>
                        <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">event_d_id</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">service_id</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESRCH</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">rte_panic</span><span class="p">(</span><span class="s">&quot;Error in starting Rx adapter[%d] service</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                          <span class="n">evt_rsrc</span><span class="o">-&gt;</span><span class="n">tx_adptr</span><span class="p">.</span><span class="n">tx_adptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">l2fwd_event_service_enable</span><span class="p">(</span><span class="n">service_id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="receive-process-and-transmit-packets">
<span id="l2-fwd-event-app-rx-tx-packets"></span><h3><span class="section-number">19.4.10. </span>Receive, Process and Transmit Packets</h3>
<p>In the <strong>l2fwd_main_loop()</strong> function, the main task is to read ingress packets from
the RX queues. This is done using the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Read packet from RX queues</span>
<span class="cm"> */</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qconf</span><span class="o">-&gt;</span><span class="n">n_rx_port</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">portid</span> <span class="o">=</span> <span class="n">qconf</span><span class="o">-&gt;</span><span class="n">rx_port_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">nb_rx</span> <span class="o">=</span> <span class="n">rte_eth_rx_burst</span><span class="p">((</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="n">portid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="n">pkts_burst</span><span class="p">,</span>
                             <span class="n">MAX_PKT_BURST</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nb_rx</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">pkts_burst</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">rte_prefetch0</span><span class="p">(</span><span class="n">rte_pktmbuf_mtod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
        <span class="n">l2fwd_simple_forward</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">portid</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Packets are read in a burst of size MAX_PKT_BURST. The rte_eth_rx_burst()
function writes the mbuf pointers in a local table and returns the number of
available mbufs in the table.</p>
<p>Then, each mbuf in the table is processed by the l2fwd_simple_forward()
function. The processing is very simple: process the TX port from the RX port,
then replace the source and destination MAC addresses if MAC addresses updating
is enabled.</p>
<p>During the initialization process, a static array of destination ports
(l2fwd_dst_ports[]) is filled such that for each source port, a destination port
is assigned that is either the next or previous enabled port from the portmask.
If number of ports are odd in portmask then packet from last port will be
forwarded to first port i.e. if portmask=0x07, then forwarding will take place
like p0—&gt;p1, p1—&gt;p2, p2—&gt;p0.</p>
<p>Also to optimize enqueue operation, l2fwd_simple_forward() stores incoming mbufs
up to MAX_PKT_BURST. Once it reaches up to limit, all packets are transmitted to
destination ports.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">l2fwd_simple_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">portid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">dst_port</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">sent</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_eth_dev_tx_buffer</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>

    <span class="n">dst_port</span> <span class="o">=</span> <span class="n">l2fwd_dst_ports</span><span class="p">[</span><span class="n">portid</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mac_updating</span><span class="p">)</span>
        <span class="n">l2fwd_mac_updating</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dst_port</span><span class="p">);</span>

    <span class="n">buffer</span> <span class="o">=</span> <span class="n">tx_buffer</span><span class="p">[</span><span class="n">dst_port</span><span class="p">];</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="n">rte_eth_tx_buffer</span><span class="p">(</span><span class="n">dst_port</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="n">port_statistics</span><span class="p">[</span><span class="n">dst_port</span><span class="p">].</span><span class="n">tx</span> <span class="o">+=</span> <span class="n">sent</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For this test application, the processing is exactly the same for all packets
arriving on the same RX port. Therefore, it would have been possible to call
the rte_eth_tx_buffer() function directly from the main loop to send all the
received packets on the same TX port, using the burst-oriented send function,
which is more efficient.</p>
<p>However, in real-life applications (such as, L3 routing),
packet N is not necessarily forwarded on the same port as packet N-1.
The application is implemented to illustrate that, so the same approach can be
reused in a more complex application.</p>
<p>To ensure that no packets remain in the tables, each lcore does a draining of TX
queue in its main loop. This technique introduces some latency when there are
not many packets to send, however it improves performance:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">cur_tsc</span> <span class="o">=</span> <span class="n">rte_rdtsc</span><span class="p">();</span>

<span class="cm">/*</span>
<span class="cm">* TX burst queue drain</span>
<span class="cm">*/</span>
<span class="n">diff_tsc</span> <span class="o">=</span> <span class="n">cur_tsc</span> <span class="o">-</span> <span class="n">prev_tsc</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">diff_tsc</span> <span class="o">&gt;</span> <span class="n">drain_tsc</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qconf</span><span class="o">-&gt;</span><span class="n">n_rx_port</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">portid</span> <span class="o">=</span> <span class="n">l2fwd_dst_ports</span><span class="p">[</span><span class="n">qconf</span><span class="o">-&gt;</span><span class="n">rx_port_list</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
                <span class="n">buffer</span> <span class="o">=</span> <span class="n">tx_buffer</span><span class="p">[</span><span class="n">portid</span><span class="p">];</span>
                <span class="n">sent</span> <span class="o">=</span> <span class="n">rte_eth_tx_buffer_flush</span><span class="p">(</span><span class="n">portid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                               <span class="n">buffer</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sent</span><span class="p">)</span>
                        <span class="n">port_statistics</span><span class="p">[</span><span class="n">portid</span><span class="p">].</span><span class="n">tx</span> <span class="o">+=</span> <span class="n">sent</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* if timer is enabled */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timer_period</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* advance the timer */</span>
                <span class="n">timer_tsc</span> <span class="o">+=</span> <span class="n">diff_tsc</span><span class="p">;</span>

                <span class="cm">/* if timer has reached its timeout */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timer_tsc</span> <span class="o">&gt;=</span> <span class="n">timer_period</span><span class="p">))</span> <span class="p">{</span>
                        <span class="cm">/* do this only on main core */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">lcore_id</span> <span class="o">==</span> <span class="n">rte_get_main_lcore</span><span class="p">())</span> <span class="p">{</span>
                                <span class="n">print_stats</span><span class="p">();</span>
                                <span class="cm">/* reset the timer */</span>
                                <span class="n">timer_tsc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">prev_tsc</span> <span class="o">=</span> <span class="n">cur_tsc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the <strong>l2fwd_event_loop()</strong> function, the main task is to read ingress
packets from the event ports. This is done using the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Read packet from eventdev */</span>
<span class="n">nb_rx</span> <span class="o">=</span> <span class="n">rte_event_dequeue_burst</span><span class="p">(</span><span class="n">event_d_id</span><span class="p">,</span> <span class="n">event_p_id</span><span class="p">,</span>
                                <span class="n">events</span><span class="p">,</span> <span class="n">deq_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nb_rx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rte_pause</span><span class="p">();</span>
        <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nb_rx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mbuf</span><span class="p">;</span>
        <span class="n">rte_prefetch0</span><span class="p">(</span><span class="n">rte_pktmbuf_mtod</span><span class="p">(</span><span class="n">mbuf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Before reading packets, deq_len is fetched to ensure correct allowed deq length
by the eventdev.
The rte_event_dequeue_burst() function writes the mbuf pointers in a local table
and returns the number of available mbufs in the table.</p>
<p>Then, each mbuf in the table is processed by the l2fwd_eventdev_forward()
function. The processing is very simple: process the TX port from the RX port,
then replace the source and destination MAC addresses if MAC addresses updating
is enabled.</p>
<p>During the initialization process, a static array of destination ports
(l2fwd_dst_ports[]) is filled such that for each source port, a destination port
is assigned that is either the next or previous enabled port from the portmask.
If number of ports are odd in portmask then packet from last port will be
forwarded to first port i.e. if portmask=0x07, then forwarding will take place
like p0—&gt;p1, p1—&gt;p2, p2—&gt;p0.</p>
<p>l2fwd_eventdev_forward() does not stores incoming mbufs. Packet will forwarded
be to destination ports via Tx adapter or generic event dev enqueue API
depending H/W or S/W scheduler is used.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">nb_tx</span> <span class="o">=</span> <span class="n">rte_event_eth_tx_adapter_enqueue</span><span class="p">(</span><span class="n">event_d_id</span><span class="p">,</span> <span class="n">port_id</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span>
                                         <span class="n">nb_rx</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">nb_tx</span> <span class="o">&lt;</span> <span class="n">nb_rx</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rsrc</span><span class="o">-&gt;</span><span class="n">force_quit</span><span class="p">)</span>
        <span class="n">nb_tx</span> <span class="o">+=</span> <span class="n">rte_event_eth_tx_adapter_enqueue</span><span class="p">(</span>
                        <span class="n">event_d_id</span><span class="p">,</span> <span class="n">port_id</span><span class="p">,</span>
                        <span class="n">ev</span> <span class="o">+</span> <span class="n">nb_tx</span><span class="p">,</span> <span class="n">nb_rx</span> <span class="o">-</span> <span class="n">nb_tx</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="l2_forward_cat.html" class="btn btn-neutral float-right" title="20. L2 Forwarding Sample Application with Cache Allocation Technology (CAT)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="l2_forward_real_virtual.html" class="btn btn-neutral float-left" title="18. L2 Forwarding Sample Application (in Real and Virtualized Environments)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>