

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>29. Intel Virtual Function Driver &mdash; Data Plane Development Kit 20.11.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="30. KNI Poll Mode Driver" href="kni.html" />
    <link rel="prev" title="28. IXGBE Driver" href="ixgbe.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Data Plane Development Kit
          

          
            
            <img src="../_static/DPDK_logo_vertical_rev_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                20.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_app_ug/index.html">Sample Applications User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prog_guide/index.html">Programmer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Network Interface Controller Drivers</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">1. Overview of Networking Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">2. Features Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="build_and_test.html">3. Compiling and testing a PMD for a NIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="af_packet.html">4. AF_PACKET Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="af_xdp.html">5. AF_XDP Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="ark.html">6. ARK Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="atlantic.html">7. Aquantia Atlantic DPDK Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="avp.html">8. AVP Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="axgbe.html">9. AXGBE Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="bnx2x.html">10. BNX2X Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="bnxt.html">11. BNXT Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxgbe.html">12. CXGBE Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="dpaa.html">13. DPAA Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="dpaa2.html">14. DPAA2 Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="e1000em.html">15. Driver for VM Emulated Devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="ena.html">16. ENA Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="enetc.html">17. ENETC Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="enic.html">18. ENIC Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="fm10k.html">19. FM10K Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="hinic.html">20. HINIC Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="hns3.html">21. HNS3 Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="i40e.html">22. I40E Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="ice.html">23. ICE Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="igb.html">24. IGB Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="igc.html">25. IGC Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="ionic.html">26. IONIC Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipn3ke.html">27. IPN3KE Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="ixgbe.html">28. IXGBE Driver</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">29. Intel Virtual Function Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sr-iov-mode-utilization-in-a-dpdk-environment">29.1. SR-IOV Mode Utilization in a DPDK Environment</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#physical-and-virtual-function-infrastructure">29.1.1. Physical and Virtual Function Infrastructure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#validated-hypervisors">29.1.2. Validated Hypervisors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expected-guest-operating-system-in-virtual-machine">29.1.3. Expected Guest Operating System in Virtual Machine</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#setting-up-a-kvm-virtual-machine-monitor">29.2. Setting Up a KVM Virtual Machine Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dpdk-sr-iov-pmd-pf-vf-driver-usage-model">29.3. DPDK SR-IOV PMD PF/VF Driver Usage Model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#fast-host-based-packet-processing">29.3.1. Fast Host-based Packet Processing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sr-iov-pf-vf-approach-for-inter-vm-communication">29.4. SR-IOV (PF/VF) Approach for Inter-VM Communication</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="kni.html">30. KNI Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="liquidio.html">31. LiquidIO VF Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="memif.html">32. Memif Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="mlx4.html">33. MLX4 poll mode driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mlx5.html">34. MLX5 poll mode driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvneta.html">35. MVNETA Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="mvpp2.html">36. MVPP2 Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="netvsc.html">37. Netvsc poll mode driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfb.html">38. NFB poll mode driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="nfp.html">39. NFP poll mode driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="null.html">40. NULL Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="octeontx.html">41. OCTEON TX Poll Mode driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="octeontx2.html">42. OCTEON TX2 Poll Mode driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="pfe.html">43. PFE Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="qede.html">44. QEDE Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfc_efx.html">45. Solarflare libefx-based Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="softnic.html">46. Soft NIC Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="szedata2.html">47. SZEDATA2 poll mode driver library</a></li>
<li class="toctree-l2"><a class="reference internal" href="tap.html">48. Tun|Tap Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="thunderx.html">49. ThunderX NICVF Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="txgbe.html">50. TXGBE Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="vdev_netvsc.html">51. VDEV_NETVSC driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="virtio.html">52. Poll Mode Driver for Emulated Virtio NIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost.html">53. Poll Mode Driver that wraps vhost library</a></li>
<li class="toctree-l2"><a class="reference internal" href="vmxnet3.html">54. Poll Mode Driver for Paravirtual VMXNET3 NIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="pcap_ring.html">55. Libpcap and Ring Based Poll Mode Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="fail_safe.html">56. Fail-safe poll mode driver library</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor’s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Data Plane Development Kit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Network Interface Controller Drivers</a> &raquo;</li>
        
      <li><span class="section-number">29. </span>Intel Virtual Function Driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/nics/intel_vf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="intel-virtual-function-driver">
<h1><span class="section-number">29. </span>Intel Virtual Function Driver</h1>
<p>Supported Intel® Ethernet Controllers (see the <em>DPDK Release Notes</em> for details)
support the following modes of operation in a virtualized environment:</p>
<ul class="simple">
<li><p><strong>SR-IOV mode</strong>: Involves direct assignment of part of the port resources to different guest operating systems
using the PCI-SIG Single Root I/O Virtualization (SR IOV) standard,
also known as “native mode” or “pass-through” mode.
In this chapter, this mode is referred to as IOV mode.</p></li>
<li><p><strong>VMDq mode</strong>: Involves central management of the networking resources by an IO Virtual Machine (IOVM) or
a Virtual Machine Monitor (VMM), also known as software switch acceleration mode.
In this chapter, this mode is referred to as the Next Generation VMDq mode.</p></li>
</ul>
<div class="section" id="sr-iov-mode-utilization-in-a-dpdk-environment">
<h2><span class="section-number">29.1. </span>SR-IOV Mode Utilization in a DPDK Environment</h2>
<p>The DPDK uses the SR-IOV feature for hardware-based I/O sharing in IOV mode.
Therefore, it is possible to partition SR-IOV capability on Ethernet controller NIC resources logically and
expose them to a virtual machine as a separate PCI function called a “Virtual Function”.
Refer to <a class="reference internal" href="#figure-single-port-nic"><span class="std std-numref">Fig. 29.1</span></a>.</p>
<p>Therefore, a NIC is logically distributed among multiple virtual machines (as shown in <a class="reference internal" href="#figure-single-port-nic"><span class="std std-numref">Fig. 29.1</span></a>),
while still having global data in common to share with the Physical Function and other Virtual Functions.
The DPDK fm10kvf, i40evf, igbvf or ixgbevf as a Poll Mode Driver (PMD) serves for the Intel® 82576 Gigabit Ethernet Controller,
Intel® Ethernet Controller I350 family, Intel® 82599 10 Gigabit Ethernet Controller NIC,
Intel® Fortville 10/40 Gigabit Ethernet Controller NIC’s virtual PCI function, or PCIe host-interface of the Intel Ethernet Switch
FM10000 Series.
Meanwhile the DPDK Poll Mode Driver (PMD) also supports “Physical Function” of such NIC’s on the host.</p>
<p>The DPDK PF/VF Poll Mode Driver (PMD) supports the Layer 2 switch on Intel® 82576 Gigabit Ethernet Controller,
Intel® Ethernet Controller I350 family, Intel® 82599 10 Gigabit Ethernet Controller,
and Intel® Fortville 10/40 Gigabit Ethernet Controller NICs so that guest can choose it for inter virtual machine traffic in SR-IOV mode.</p>
<p>For more detail on SR-IOV, please refer to the following documents:</p>
<ul class="simple">
<li><p><a class="reference external" href="http://www.intel.com/network/connectivity/solutions/vmdc.htm">SR-IOV provides hardware based I/O sharing</a></p></li>
<li><p><a class="reference external" href="http://www.intel.com/content/www/us/en/pci-express/pci-sig-single-root-io-virtualization-support-in-virtualization-technology-for-connectivity-paper.html">PCI-SIG-Single Root I/O Virtualization Support on IA</a></p></li>
<li><p><a class="reference external" href="http://www.intel.com/content/www/us/en/virtualization/server-virtualization/scalable-i-o-virtualized-servers-paper.html">Scalable I/O Virtualized Servers</a></p></li>
</ul>
<div class="figure align-default" id="id1">
<span id="figure-single-port-nic"></span><img alt="../_images/single_port_nic.png" src="../_images/single_port_nic.png" />
<p class="caption"><span class="caption-number">Fig. 29.1 </span><span class="caption-text">Virtualization for a Single Port NIC in SR-IOV Mode</span></p>
</div>
<div class="section" id="physical-and-virtual-function-infrastructure">
<h3><span class="section-number">29.1.1. </span>Physical and Virtual Function Infrastructure</h3>
<p>The following describes the Physical Function and Virtual Functions infrastructure for the supported Ethernet Controller NICs.</p>
<p>Virtual Functions operate under the respective Physical Function on the same NIC Port and therefore have no access
to the global NIC resources that are shared between other functions for the same NIC port.</p>
<p>A Virtual Function has basic access to the queue resources and control structures of the queues assigned to it.
For global resource access, a Virtual Function has to send a request to the Physical Function for that port,
and the Physical Function operates on the global resources on behalf of the Virtual Function.
For this out-of-band communication, an SR-IOV enabled NIC provides a memory buffer for each Virtual Function,
which is called a “Mailbox”.</p>
<div class="section" id="intel-ethernet-adaptive-virtual-function">
<h4><span class="section-number">29.1.1.1. </span>Intel® Ethernet Adaptive Virtual Function</h4>
<p>Adaptive Virtual Function (IAVF) is a SR-IOV Virtual Function with the same device id (8086:1889) on different Intel Ethernet Controller.
IAVF Driver is VF driver which supports for all future Intel devices without requiring a VM update. And since this happens to be an adaptive VF driver,
every new drop of the VF driver would add more and more advanced features that can be turned on in the VM if the underlying HW device supports those
advanced features based on a device agnostic way without ever compromising on the base functionality. IAVF provides generic hardware interface and
interface between IAVF driver and a compliant PF driver is specified.</p>
<p>Intel products starting Ethernet Controller 700 Series to support Adaptive Virtual Function.</p>
<p>The way to generate Virtual Function is like normal, and the resource of VF assignment depends on the NIC Infrastructure.</p>
<p>For more detail on SR-IOV, please refer to the following documents:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.intel.com/content/dam/www/public/us/en/documents/product-specifications/ethernet-adaptive-virtual-function-hardware-spec.pdf">Intel® IAVF HAS</a></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To use DPDK IAVF PMD on Intel® 700 Series Ethernet Controller, the device id (0x1889) need to specified during device
assignment in hypervisor. Take qemu for example, the device assignment should carry the IAVF device id (0x1889) like
<code class="docutils literal notranslate"><span class="pre">-device</span> <span class="pre">vfio-pci,x-pci-device-id=0x1889,host=03:0a.0</span></code>.</p>
<p>When IAVF is backed by an Intel® E810 device, the “Protocol Extraction” feature which is supported by ice PMD is also
available for IAVF PMD. The same devargs with the same parameters can be applied to IAVF PMD, for detail please reference
the section <code class="docutils literal notranslate"><span class="pre">Protocol</span> <span class="pre">extraction</span> <span class="pre">for</span> <span class="pre">per</span> <span class="pre">queue</span></code> of ice.rst.</p>
</div>
</div>
<div class="section" id="the-pcie-host-interface-of-intel-ethernet-switch-fm10000-series-vf-infrastructure">
<h4><span class="section-number">29.1.1.2. </span>The PCIE host-interface of Intel Ethernet Switch FM10000 Series VF infrastructure</h4>
<p>In a virtualized environment, the programmer can enable a maximum of <em>64 Virtual Functions (VF)</em>
globally per PCIE host-interface of the Intel Ethernet Switch FM10000 Series device.
Each VF can have a maximum of 16 queue pairs.
The Physical Function in host could be only configured by the Linux* fm10k driver
(in the case of the Linux Kernel-based Virtual Machine [KVM]), DPDK PMD PF driver doesn’t support it yet.</p>
<p>For example,</p>
<ul>
<li><p>Using Linux* fm10k driver:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">rmmod fm10k (To remove the fm10k module)</span>
<span class="go">insmod fm0k.ko max_vfs=2,2 (To enable two Virtual Functions per port)</span>
</pre></div>
</div>
</li>
</ul>
<p>Virtual Function enumeration is performed in the following sequence by the Linux* pci driver for a dual-port NIC.
When you enable the four Virtual Functions with the above command, the four enabled functions have a Function#
represented by (Bus#, Device#, Function#) in sequence starting from 0 to 3.
However:</p>
<ul class="simple">
<li><p>Virtual Functions 0 and 2 belong to Physical Function 0</p></li>
<li><p>Virtual Functions 1 and 3 belong to Physical Function 1</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above is an important consideration to take into account when targeting specific packets to a selected port.</p>
</div>
</div>
<div class="section" id="intel-x710-xl710-gigabit-ethernet-controller-vf-infrastructure">
<h4><span class="section-number">29.1.1.3. </span>Intel® X710/XL710 Gigabit Ethernet Controller VF Infrastructure</h4>
<p>In a virtualized environment, the programmer can enable a maximum of <em>128 Virtual Functions (VF)</em>
globally per Intel® X710/XL710 Gigabit Ethernet Controller NIC device.
The Physical Function in host could be either configured by the Linux* i40e driver
(in the case of the Linux Kernel-based Virtual Machine [KVM]) or by DPDK PMD PF driver.
When using both DPDK PMD PF/VF drivers, the whole NIC will be taken over by DPDK based application.</p>
<p>For example,</p>
<ul>
<li><p>Using Linux* i40e  driver:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">rmmod i40e (To remove the i40e module)</span>
<span class="go">insmod i40e.ko max_vfs=2,2 (To enable two Virtual Functions per port)</span>
</pre></div>
</div>
</li>
<li><p>Using the DPDK PMD PF i40e driver:</p>
<p>Kernel Params: iommu=pt, intel_iommu=on</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">modprobe uio</span>
<span class="go">insmod igb_uio</span>
<span class="go">./dpdk-devbind.py -b igb_uio bb:ss.f</span>
<span class="go">echo 2 &gt; /sys/bus/pci/devices/0000\:bb\:ss.f/max_vfs (To enable two VFs on a specific PCI device)</span>
</pre></div>
</div>
<p>Launch the DPDK testpmd/example or your own host daemon application using the DPDK PMD library.</p>
</li>
</ul>
<p>Virtual Function enumeration is performed in the following sequence by the Linux* pci driver for a dual-port NIC.
When you enable the four Virtual Functions with the above command, the four enabled functions have a Function#
represented by (Bus#, Device#, Function#) in sequence starting from 0 to 3.
However:</p>
<ul class="simple">
<li><p>Virtual Functions 0 and 2 belong to Physical Function 0</p></li>
<li><p>Virtual Functions 1 and 3 belong to Physical Function 1</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above is an important consideration to take into account when targeting specific packets to a selected port.</p>
<p>For Intel® X710/XL710 Gigabit Ethernet Controller, queues are in pairs. One queue pair means one receive queue and
one transmit queue. The default number of queue pairs per VF is 4, and can be 16 in maximum.</p>
</div>
</div>
<div class="section" id="intel-82599-10-gigabit-ethernet-controller-vf-infrastructure">
<h4><span class="section-number">29.1.1.4. </span>Intel® 82599 10 Gigabit Ethernet Controller VF Infrastructure</h4>
<p>The programmer can enable a maximum of <em>63 Virtual Functions</em> and there must be <em>one Physical Function</em> per Intel® 82599
10 Gigabit Ethernet Controller NIC port.
The reason for this is that the device allows for a maximum of 128 queues per port and a virtual/physical function has to
have at least one queue pair (RX/TX).
The current implementation of the DPDK ixgbevf driver supports a single queue pair (RX/TX) per Virtual Function.
The Physical Function in host could be either configured by the Linux* ixgbe driver
(in the case of the Linux Kernel-based Virtual Machine [KVM]) or by DPDK PMD PF driver.
When using both DPDK PMD PF/VF drivers, the whole NIC will be taken over by DPDK based application.</p>
<p>For example,</p>
<ul>
<li><p>Using Linux* ixgbe driver:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">rmmod ixgbe (To remove the ixgbe module)</span>
<span class="go">insmod ixgbe max_vfs=2,2 (To enable two Virtual Functions per port)</span>
</pre></div>
</div>
</li>
<li><p>Using the DPDK PMD PF ixgbe driver:</p>
<p>Kernel Params: iommu=pt, intel_iommu=on</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">modprobe uio</span>
<span class="go">insmod igb_uio</span>
<span class="go">./dpdk-devbind.py -b igb_uio bb:ss.f</span>
<span class="go">echo 2 &gt; /sys/bus/pci/devices/0000\:bb\:ss.f/max_vfs (To enable two VFs on a specific PCI device)</span>
</pre></div>
</div>
<p>Launch the DPDK testpmd/example or your own host daemon application using the DPDK PMD library.</p>
</li>
<li><p>Using the DPDK PMD PF ixgbe driver to enable VF RSS:</p>
<p>Same steps as above to install the modules of uio, igb_uio, specify max_vfs for PCI device, and
launch the DPDK testpmd/example or your own host daemon application using the DPDK PMD library.</p>
<p>The available queue number (at most 4) per VF depends on the total number of pool, which is
determined by the max number of VF at PF initialization stage and the number of queue specified
in config:</p>
<ul>
<li><p>If the max number of VFs (max_vfs) is set in the range of 1 to 32:</p>
<p>If the number of Rx queues is specified as 4 (<code class="docutils literal notranslate"><span class="pre">--rxq=4</span></code> in testpmd), then there are totally 32
pools (ETH_32_POOLS), and each VF could have 4 Rx queues;</p>
<p>If the number of Rx queues is specified as 2 (<code class="docutils literal notranslate"><span class="pre">--rxq=2</span></code> in testpmd), then there are totally 32
pools (ETH_32_POOLS), and each VF could have 2 Rx queues;</p>
</li>
<li><p>If the max number of VFs (max_vfs) is in the range of 33 to 64:</p>
<p>If the number of Rx queues in specified as 4 (<code class="docutils literal notranslate"><span class="pre">--rxq=4</span></code> in testpmd), then error message is expected
as <code class="docutils literal notranslate"><span class="pre">rxq</span></code> is not correct at this case;</p>
<p>If the number of rxq is 2 (<code class="docutils literal notranslate"><span class="pre">--rxq=2</span></code> in testpmd), then there is totally 64 pools (ETH_64_POOLS),
and each VF have 2 Rx queues;</p>
</li>
</ul>
<p>On host, to enable VF RSS functionality, rx mq mode should be set as ETH_MQ_RX_VMDQ_RSS
or ETH_MQ_RX_RSS mode, and SRIOV mode should be activated (max_vfs &gt;= 1).
It also needs config VF RSS information like hash function, RSS key, RSS key length.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The limitation for VF RSS on Intel® 82599 10 Gigabit Ethernet Controller is:
The hash and key are shared among PF and all VF, the RETA table with 128 entries is also shared
among PF and all VF; So it could not to provide a method to query the hash and reta content per
VF on guest, while, if possible, please query them on host for the shared RETA information.</p>
</div>
<p>Virtual Function enumeration is performed in the following sequence by the Linux* pci driver for a dual-port NIC.
When you enable the four Virtual Functions with the above command, the four enabled functions have a Function#
represented by (Bus#, Device#, Function#) in sequence starting from 0 to 3.
However:</p>
<ul class="simple">
<li><p>Virtual Functions 0 and 2 belong to Physical Function 0</p></li>
<li><p>Virtual Functions 1 and 3 belong to Physical Function 1</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above is an important consideration to take into account when targeting specific packets to a selected port.</p>
</div>
</div>
<div class="section" id="intel-82576-gigabit-ethernet-controller-and-intel-ethernet-controller-i350-family-vf-infrastructure">
<h4><span class="section-number">29.1.1.5. </span>Intel® 82576 Gigabit Ethernet Controller and Intel® Ethernet Controller I350 Family VF Infrastructure</h4>
<p>In a virtualized environment, an Intel® 82576 Gigabit Ethernet Controller serves up to eight virtual machines (VMs).
The controller has 16 TX and 16 RX queues.
They are generally referred to (or thought of) as queue pairs (one TX and one RX queue).
This gives the controller 16 queue pairs.</p>
<p>A pool is a group of queue pairs for assignment to the same VF, used for transmit and receive operations.
The controller has eight pools, with each pool containing two queue pairs, that is, two TX and two RX queues assigned to each VF.</p>
<p>In a virtualized environment, an Intel® Ethernet Controller I350 family device serves up to eight virtual machines (VMs) per port.
The eight queues can be accessed by eight different VMs if configured correctly (the i350 has 4x1GbE ports each with 8T X and 8 RX queues),
that means, one Transmit and one Receive queue assigned to each VF.</p>
<p>For example,</p>
<ul>
<li><p>Using Linux* igb driver:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">rmmod igb (To remove the igb module)</span>
<span class="go">insmod igb max_vfs=2,2 (To enable two Virtual Functions per port)</span>
</pre></div>
</div>
</li>
<li><p>Using DPDK PMD PF igb driver:</p>
<p>Kernel Params: iommu=pt, intel_iommu=on modprobe uio</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">insmod igb_uio</span>
<span class="go">./dpdk-devbind.py -b igb_uio bb:ss.f</span>
<span class="go">echo 2 &gt; /sys/bus/pci/devices/0000\:bb\:ss.f/max_vfs (To enable two VFs on a specific pci device)</span>
</pre></div>
</div>
<p>Launch DPDK testpmd/example or your own host daemon application using the DPDK PMD library.</p>
</li>
</ul>
<p>Virtual Function enumeration is performed in the following sequence by the Linux* pci driver for a four-port NIC.
When you enable the four Virtual Functions with the above command, the four enabled functions have a Function#
represented by (Bus#, Device#, Function#) in sequence, starting from 0 to 7.
However:</p>
<ul class="simple">
<li><p>Virtual Functions 0 and 4 belong to Physical Function 0</p></li>
<li><p>Virtual Functions 1 and 5 belong to Physical Function 1</p></li>
<li><p>Virtual Functions 2 and 6 belong to Physical Function 2</p></li>
<li><p>Virtual Functions 3 and 7 belong to Physical Function 3</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above is an important consideration to take into account when targeting specific packets to a selected port.</p>
</div>
</div>
</div>
<div class="section" id="validated-hypervisors">
<h3><span class="section-number">29.1.2. </span>Validated Hypervisors</h3>
<p>The validated hypervisor is:</p>
<ul class="simple">
<li><p>KVM (Kernel Virtual Machine) with  Qemu, version 0.14.0</p></li>
</ul>
<p>However, the hypervisor is bypassed to configure the Virtual Function devices using the Mailbox interface,
the solution is hypervisor-agnostic.
Xen* and VMware* (when SR- IOV is supported) will also be able to support the DPDK with Virtual Function driver support.</p>
</div>
<div class="section" id="expected-guest-operating-system-in-virtual-machine">
<h3><span class="section-number">29.1.3. </span>Expected Guest Operating System in Virtual Machine</h3>
<p>The expected guest operating systems in a virtualized environment are:</p>
<ul class="simple">
<li><p>Fedora* 14 (64-bit)</p></li>
<li><p>Ubuntu* 10.04 (64-bit)</p></li>
</ul>
<p>For supported kernel versions, refer to the <em>DPDK Release Notes</em>.</p>
</div>
</div>
<div class="section" id="setting-up-a-kvm-virtual-machine-monitor">
<h2><span class="section-number">29.2. </span>Setting Up a KVM Virtual Machine Monitor</h2>
<p>The following describes a target environment:</p>
<ul class="simple">
<li><p>Host Operating System: Fedora 14</p></li>
<li><p>Hypervisor: KVM (Kernel Virtual Machine) with Qemu  version 0.14.0</p></li>
<li><p>Guest Operating System: Fedora 14</p></li>
<li><p>Linux Kernel Version: Refer to the  <em>DPDK Getting Started Guide</em></p></li>
<li><p>Target Applications:  l2fwd, l3fwd-vf</p></li>
</ul>
<p>The setup procedure is as follows:</p>
<ol class="arabic">
<li><p>Before booting the Host OS, open <strong>BIOS setup</strong> and enable <strong>Intel® VT features</strong>.</p></li>
<li><p>While booting the Host OS kernel, pass the intel_iommu=on kernel command line argument using GRUB.
When using DPDK PF driver on host, pass the iommu=pt kernel command line argument in GRUB.</p></li>
<li><p>Download qemu-kvm-0.14.0 from
<a class="reference external" href="http://sourceforge.net/projects/kvm/files/qemu-kvm/">http://sourceforge.net/projects/kvm/files/qemu-kvm/</a>
and install it in the Host OS using the following steps:</p>
<p>When using a recent kernel (2.6.25+) with kvm modules included:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">tar xzf qemu-kvm-release.tar.gz</span>
<span class="go">cd qemu-kvm-release</span>
<span class="go">./configure --prefix=/usr/local/kvm</span>
<span class="go">make</span>
<span class="go">sudo make install</span>
<span class="go">sudo /sbin/modprobe kvm-intel</span>
</pre></div>
</div>
<p>When using an older kernel, or a kernel from a distribution without the kvm modules,
you must download (from the same link), compile and install the modules yourself:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">tar xjf kvm-kmod-release.tar.bz2</span>
<span class="go">cd kvm-kmod-release</span>
<span class="go">./configure</span>
<span class="go">make</span>
<span class="go">sudo make install</span>
<span class="go">sudo /sbin/modprobe kvm-intel</span>
</pre></div>
</div>
<p>qemu-kvm installs in the /usr/local/bin directory.</p>
<p>For more details about KVM configuration and usage, please refer to:</p>
<p><a class="reference external" href="http://www.linux-kvm.org/page/HOWTO1">http://www.linux-kvm.org/page/HOWTO1</a>.</p>
</li>
<li><p>Create a Virtual Machine and install Fedora 14 on the Virtual Machine.
This is referred to as the Guest Operating System (Guest OS).</p></li>
<li><p>Download and install the latest ixgbe driver from:</p>
<p><a class="reference external" href="http://downloadcenter.intel.com/Detail_Desc.aspx?agr=Y&amp;amp;DwnldID=14687">http://downloadcenter.intel.com/Detail_Desc.aspx?agr=Y&amp;amp;DwnldID=14687</a></p>
</li>
<li><p>In the Host OS</p>
<p>When using Linux kernel ixgbe driver, unload the Linux ixgbe driver and reload it with the max_vfs=2,2 argument:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">rmmod ixgbe</span>
<span class="go">modprobe ixgbe max_vfs=2,2</span>
</pre></div>
</div>
<p>When using DPDK PMD PF driver, insert DPDK kernel module igb_uio and set the number of VF by sysfs max_vfs:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">modprobe uio</span>
<span class="go">insmod igb_uio</span>
<span class="go">./dpdk-devbind.py -b igb_uio 02:00.0 02:00.1 0e:00.0 0e:00.1</span>
<span class="go">echo 2 &gt; /sys/bus/pci/devices/0000\:02\:00.0/max_vfs</span>
<span class="go">echo 2 &gt; /sys/bus/pci/devices/0000\:02\:00.1/max_vfs</span>
<span class="go">echo 2 &gt; /sys/bus/pci/devices/0000\:0e\:00.0/max_vfs</span>
<span class="go">echo 2 &gt; /sys/bus/pci/devices/0000\:0e\:00.1/max_vfs</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You need to explicitly specify number of vfs for each port, for example,
in the command above, it creates two vfs for the first two ixgbe ports.</p>
</div>
<p>Let say we have a machine with four physical ixgbe ports:</p>
<blockquote>
<div><p>0000:02:00.0</p>
<p>0000:02:00.1</p>
<p>0000:0e:00.0</p>
<p>0000:0e:00.1</p>
</div></blockquote>
<p>The command above creates two vfs for device 0000:02:00.0:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ls -alrt /sys/bus/pci/devices/0000\:02\:00.0/virt*</span>
<span class="go">lrwxrwxrwx. 1 root root 0 Apr 13 05:40 /sys/bus/pci/devices/0000:02:00.0/virtfn1 -&gt; ../0000:02:10.2</span>
<span class="go">lrwxrwxrwx. 1 root root 0 Apr 13 05:40 /sys/bus/pci/devices/0000:02:00.0/virtfn0 -&gt; ../0000:02:10.0</span>
</pre></div>
</div>
<p>It also creates two vfs for device 0000:02:00.1:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ls -alrt /sys/bus/pci/devices/0000\:02\:00.1/virt*</span>
<span class="go">lrwxrwxrwx. 1 root root 0 Apr 13 05:51 /sys/bus/pci/devices/0000:02:00.1/virtfn1 -&gt; ../0000:02:10.3</span>
<span class="go">lrwxrwxrwx. 1 root root 0 Apr 13 05:51 /sys/bus/pci/devices/0000:02:00.1/virtfn0 -&gt; ../0000:02:10.1</span>
</pre></div>
</div>
</li>
<li><p>List the PCI devices connected and notice that the Host OS shows two Physical Functions (traditional ports)
and four Virtual Functions (two for each port).
This is the result of the previous step.</p></li>
<li><p>Insert the pci_stub module to hold the PCI devices that are freed from the default driver using the following command
(see <a class="reference external" href="http://www.linux-kvm.org/page/How_to_assign_devices_with_VT-d_in_KVM">http://www.linux-kvm.org/page/How_to_assign_devices_with_VT-d_in_KVM</a> Section 4 for more information):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sudo /sbin/modprobe pci-stub</span>
</pre></div>
</div>
<p>Unbind the default driver from the PCI devices representing the Virtual Functions.
A script to perform this action is as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">echo &quot;8086 10ed&quot; &gt; /sys/bus/pci/drivers/pci-stub/new_id</span>
<span class="go">echo 0000:08:10.0 &gt; /sys/bus/pci/devices/0000:08:10.0/driver/unbind</span>
<span class="go">echo 0000:08:10.0 &gt; /sys/bus/pci/drivers/pci-stub/bind</span>
</pre></div>
</div>
<p>where, 0000:08:10.0 belongs to the Virtual Function visible in the Host OS.</p>
</li>
<li><p>Now, start the Virtual Machine by running the following command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">/usr/local/kvm/bin/qemu-system-x86_64 -m 4096 -smp 4 -boot c -hda lucid.qcow2 -device pci-assign,host=08:10.0</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><p>— -m = memory to assign</p>
<p class="attribution">—-smp = number of smp cores</p>
</div></blockquote>
<blockquote>
<div><p>— -boot = boot option</p>
<p class="attribution">—-hda = virtual disk image</p>
</div></blockquote>
<blockquote>
<div><p>— -device = device to attach</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>— The pci-assign,host=08:10.0 value indicates that you want to attach a PCI device
to a Virtual Machine and the respective (Bus:Device.Function)
numbers should be passed for the Virtual Function to be attached.</p>
<p>— qemu-kvm-0.14.0 allows a maximum of four PCI devices assigned to a VM,
but this is qemu-kvm version dependent since qemu-kvm-0.14.1 allows a maximum of five PCI devices.</p>
<p>— qemu-system-x86_64 also has a -cpu command line option that is used to select the cpu_model
to emulate in a Virtual Machine. Therefore, it can be used as:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">/usr/local/kvm/bin/qemu-system-x86_64 -cpu ?</span>

<span class="gp gp-VirtualEnv">(to list all available cpu_models)</span>

<span class="go">/usr/local/kvm/bin/qemu-system-x86_64 -m 4096 -cpu host -smp 4 -boot c -hda lucid.qcow2 -device pci-assign,host=08:10.0</span>

<span class="gp gp-VirtualEnv">(to use the same cpu_model equivalent to the host cpu)</span>
</pre></div>
</div>
<p>For more information, please refer to: <a class="reference external" href="http://wiki.qemu.org/Features/CPUModels">http://wiki.qemu.org/Features/CPUModels</a>.</p>
</div>
</li>
<li><p>If use vfio-pci to pass through device instead of pci-assign, steps 8 and 9 need to be updated to bind device to vfio-pci and
replace pci-assign with vfio-pci when start virtual machine.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">sudo /sbin/modprobe vfio-pci</span>

<span class="go">echo &quot;8086 10ed&quot; &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span>
<span class="go">echo 0000:08:10.0 &gt; /sys/bus/pci/devices/0000:08:10.0/driver/unbind</span>
<span class="go">echo 0000:08:10.0 &gt; /sys/bus/pci/drivers/vfio-pci/bind</span>

<span class="go">/usr/local/kvm/bin/qemu-system-x86_64 -m 4096 -smp 4 -boot c -hda lucid.qcow2 -device vfio-pci,host=08:10.0</span>
</pre></div>
</div>
</li>
<li><p>Install and run DPDK host app to take  over the Physical Function. Eg.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./&lt;build_dir&gt;/app/dpdk-testpmd -l 0-3 -n 4 -- -i</span>
</pre></div>
</div>
</li>
<li><p>Finally, access the Guest OS using vncviewer with the localhost:5900 port and check the lspci command output in the Guest OS.
The virtual functions will be listed as available for use.</p></li>
<li><p>Configure and install the DPDK on the Guest OS as normal, that is, there is no change to the normal installation procedure.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are unable to compile the DPDK and you are getting “error: CPU you selected does not support x86-64 instruction set”,
power off the Guest OS and start the virtual machine with the correct -cpu option in the qemu- system-x86_64 command as shown in step 9.
You must select the best x86_64 cpu_model to emulate or you can select host option if available.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Run the DPDK l2fwd sample application in the Guest OS with Hugepages enabled.
For the expected benchmark performance, you must pin the cores from the Guest OS to the Host OS (taskset can be used to do this) and
you must also look at the PCI Bus layout on the board to ensure you are not running the traffic over the QPI Interface.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The Virtual Machine Manager (the Fedora package name is virt-manager) is a utility for virtual machine management
that can also be used to create, start, stop and delete virtual machines.
If this option is used, step 2 and 6 in the instructions provided will be different.</p></li>
<li><p>virsh, a command line utility for virtual machine management,
can also be used to bind and unbind devices to a virtual machine in Ubuntu.
If this option is used, step 6 in the instructions provided will be different.</p></li>
<li><p>The Virtual Machine Monitor (see <a class="reference internal" href="#figure-perf-benchmark"><span class="std std-numref">Fig. 29.2</span></a>) is equivalent to a Host OS with KVM installed as described in the instructions.</p></li>
</ul>
</div>
<div class="figure align-default" id="id2">
<span id="figure-perf-benchmark"></span><img alt="../_images/perf_benchmark.png" src="../_images/perf_benchmark.png" />
<p class="caption"><span class="caption-number">Fig. 29.2 </span><span class="caption-text">Performance Benchmark Setup</span></p>
</div>
</div>
<div class="section" id="dpdk-sr-iov-pmd-pf-vf-driver-usage-model">
<h2><span class="section-number">29.3. </span>DPDK SR-IOV PMD PF/VF Driver Usage Model</h2>
<div class="section" id="fast-host-based-packet-processing">
<h3><span class="section-number">29.3.1. </span>Fast Host-based Packet Processing</h3>
<p>Software Defined Network (SDN) trends are demanding fast host-based packet handling.
In a virtualization environment,
the DPDK VF PMD driver performs the same throughput result as a non-VT native environment.</p>
<p>With such host instance fast packet processing, lots of services such as filtering, QoS,
DPI can be offloaded on the host fast path.</p>
<p><a class="reference internal" href="#figure-fast-pkt-proc"><span class="std std-numref">Fig. 29.3</span></a> shows the scenario where some VMs directly communicate externally via a VFs,
while others connect to a virtual switch and share the same uplink bandwidth.</p>
<div class="figure align-default" id="id3">
<span id="figure-fast-pkt-proc"></span><img alt="../_images/fast_pkt_proc.png" src="../_images/fast_pkt_proc.png" />
<p class="caption"><span class="caption-number">Fig. 29.3 </span><span class="caption-text">Fast Host-based Packet Processing</span></p>
</div>
</div>
</div>
<div class="section" id="sr-iov-pf-vf-approach-for-inter-vm-communication">
<h2><span class="section-number">29.4. </span>SR-IOV (PF/VF) Approach for Inter-VM Communication</h2>
<p>Inter-VM data communication is one of the traffic bottle necks in virtualization platforms.
SR-IOV device assignment helps a VM to attach the real device, taking advantage of the bridge in the NIC.
So VF-to-VF traffic within the same physical port (VM0&lt;-&gt;VM1) have hardware acceleration.
However, when VF crosses physical ports (VM0&lt;-&gt;VM2), there is no such hardware bridge.
In this case, the DPDK PMD PF driver provides host forwarding between such VMs.</p>
<p><a class="reference internal" href="#figure-inter-vm-comms"><span class="std std-numref">Fig. 29.4</span></a> shows an example.
In this case an update of the MAC address lookup tables in both the NIC and host DPDK application is required.</p>
<p>In the NIC, writing the destination of a MAC address belongs to another cross device VM to the PF specific pool.
So when a packet comes in, its destination MAC address will match and forward to the host DPDK PMD application.</p>
<p>In the host DPDK application, the behavior is similar to L2 forwarding,
that is, the packet is forwarded to the correct PF pool.
The SR-IOV NIC switch forwards the packet to a specific VM according to the MAC destination address
which belongs to the destination VF on the VM.</p>
<div class="figure align-default" id="id4">
<span id="figure-inter-vm-comms"></span><img alt="../_images/inter_vm_comms.png" src="../_images/inter_vm_comms.png" />
<p class="caption"><span class="caption-number">Fig. 29.4 </span><span class="caption-text">Inter-VM Communication</span></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="kni.html" class="btn btn-neutral float-right" title="30. KNI Poll Mode Driver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="ixgbe.html" class="btn btn-neutral float-left" title="28. IXGBE Driver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>