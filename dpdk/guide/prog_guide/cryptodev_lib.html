

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>17. Cryptography Device Library &mdash; Data Plane Development Kit 20.11.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="18. Compression Device Library" href="compressdev.html" />
    <link rel="prev" title="16. Wireless Baseband Device Library" href="bbdev.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Data Plane Development Kit
          

          
            
            <img src="../_static/DPDK_logo_vertical_rev_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                20.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_app_ug/index.html">Sample Applications User Guides</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programmerâ€™s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html">2. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="env_abstraction_layer.html">3. Environment Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="service_cores.html">4. Service Cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="trace_lib.html">5. Trace Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rcu_lib.html">6. RCU Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ring_lib.html">7. Ring Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="stack_lib.html">8. Stack Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mempool_lib.html">9. Mempool Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mbuf_lib.html">10. Mbuf Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="poll_mode_drv.html">11. Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="rte_flow.html">12. Generic flow API (rte_flow)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switch_representation.html">13. Switch Representation within DPDK Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="traffic_metering_and_policing.html">14. Traffic Metering and Policing API</a></li>
<li class="toctree-l2"><a class="reference internal" href="traffic_management.html">15. Traffic Management API</a></li>
<li class="toctree-l2"><a class="reference internal" href="bbdev.html">16. Wireless Baseband Device Library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">17. Cryptography Device Library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-principles">17.1. Design Principles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-management">17.2. Device Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-creation">17.2.1. Device Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-identification">17.2.2. Device Identification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-configuration">17.2.3. Device Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-queue-pairs">17.2.4. Configuration of Queue Pairs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logical-cores-memory-and-queues-pair-relationships">17.2.5. Logical Cores, Memory and Queues Pair Relationships</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#device-features-and-capabilities">17.3. Device Features and Capabilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-features">17.3.1. Device Features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-operation-capabilities">17.3.2. Device Operation Capabilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#capabilities-discovery">17.3.3. Capabilities Discovery</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#operation-processing">17.4. Operation Processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#private-data">17.4.1. Private data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enqueue-dequeue-burst-apis">17.4.2. Enqueue / Dequeue Burst APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operation-representation">17.4.3. Operation Representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operation-management-and-allocation">17.4.4. Operation Management and Allocation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#symmetric-cryptography-support">17.5. Symmetric Cryptography Support</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#session-and-session-management">17.5.1. Session and Session Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transforms-and-transform-chaining">17.5.2. Transforms and Transform Chaining</a></li>
<li class="toctree-l4"><a class="reference internal" href="#symmetric-operations">17.5.3. Symmetric Operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#synchronous-mode">17.6. Synchronous mode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cryptodev-raw-data-path-apis">17.6.1. Cryptodev Raw Data-path APIs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sample-code">17.7. Sample code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asymmetric-cryptography">17.8. Asymmetric Cryptography</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">17.8.1. Session and Session Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asymmetric-sessionless-support">17.8.2. Asymmetric Sessionless Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">17.8.3. Transforms and Transform Chaining</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asymmetric-operations">17.8.4. Asymmetric Operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#asymmetric-crypto-sample-code">17.9. Asymmetric crypto Sample code</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#asymmetric-crypto-device-api">17.9.1. Asymmetric Crypto Device API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="compressdev.html">18. Compression Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regexdev.html">19. RegEx Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rte_security.html">20. Security Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rawdev.html">21. Rawdevice Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="link_bonding_poll_mode_drv_lib.html">22. Link Bonding Poll Mode Driver Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer_lib.html">23. Timer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="hash_lib.html">24. Hash Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="efd_lib.html">25. Elastic Flow Distributor Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="member_lib.html">26. Membership Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm_lib.html">27. LPM Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm6_lib.html">28. LPM6 Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow_classify_lib.html">29. Flow Classification Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_distrib_lib.html">30. Packet Distributor Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="reorder_lib.html">31. Reorder Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_fragment_reassembly_lib.html">32. IP Fragmentation and Reassembly Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_receive_offload_lib.html">33. Generic Receive Offload Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_segmentation_offload_lib.html">34. Generic Segmentation Offload Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pdump_lib.html">35. The librte_pdump Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_proc_support.html">36. Multi-process Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel_nic_interface.html">37. Kernel NIC Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread_safety_dpdk_functions.html">38. Thread Safety of DPDK Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="eventdev.html">39. Event Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_ethernet_rx_adapter.html">40. Event Ethernet Rx Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_ethernet_tx_adapter.html">41. Event Ethernet Tx Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_timer_adapter.html">42. Event Timer Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_crypto_adapter.html">43. Event Crypto Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_framework.html">44. Quality of Service (QoS) Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_man.html">45. Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_classif_access_ctrl.html">46. Packet Classification and Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_framework.html">47. Packet Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost_lib.html">48. Vhost Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="metrics_lib.html">49. Metrics Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="telemetry_lib.html">50. Telemetry Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="bpf_lib.html">51. Berkeley Packet Filter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec_lib.html">52. IPsec Packet Processing Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_lib.html">53. Graph Library and Inbuilt Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_org.html">54. Source Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-sdk-meson.html">55. Installing DPDK Using the meson build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson_ut.html">56. Running DPDK Unit Tests with Meson</a></li>
<li class="toctree-l2"><a class="reference internal" href="build_app.html">57. Building Your Own Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="perf_opt_guidelines.html">58. Performance Optimization Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing_efficient_code.html">59. Writing Efficient Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="lto.html">60. Link Time Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile_app.html">61. Profile Your Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="glossary.html">62. Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributorâ€™s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Data Plane Development Kit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Programmerâ€™s Guide</a> &raquo;</li>
        
      <li><span class="section-number">17. </span>Cryptography Device Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/prog_guide/cryptodev_lib.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cryptography-device-library">
<h1><span class="section-number">17. </span>Cryptography Device Library</h1>
<p>The cryptodev library provides a Crypto device framework for management and
provisioning of hardware and software Crypto poll mode drivers, defining generic
APIs which support a number of different Crypto operations. The framework
currently only supports cipher, authentication, chained cipher/authentication
and AEAD symmetric and asymmetric Crypto operations.</p>
<div class="section" id="design-principles">
<h2><span class="section-number">17.1. </span>Design Principles</h2>
<p>The cryptodev library follows the same basic principles as those used in DPDKâ€™s
Ethernet Device framework. The Crypto framework provides a generic Crypto device
framework which supports both physical (hardware) and virtual (software) Crypto
devices as well as a generic Crypto API which allows Crypto devices to be
managed and configured and supports Crypto operations to be provisioned on
Crypto poll mode driver.</p>
</div>
<div class="section" id="device-management">
<h2><span class="section-number">17.2. </span>Device Management</h2>
<div class="section" id="device-creation">
<h3><span class="section-number">17.2.1. </span>Device Creation</h3>
<p>Physical Crypto devices are discovered during the PCI probe/enumeration of the
EAL function which is executed at DPDK initialization, based on
their PCI device identifier, each unique PCI BDF (bus/bridge, device,
function). Specific physical Crypto devices, like other physical devices in DPDK
can be listed using the EAL command line options.</p>
<p>Virtual devices can be created by two mechanisms, either using the EAL command
line options or from within the application using an EAL API directly.</p>
<p>From the command line using the â€“vdev EAL option</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">--vdev  &#39;crypto_aesni_mb0,max_nb_queue_pairs=2,socket_id=0&#39;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>If DPDK application requires multiple software crypto PMD devices then required
number of <code class="docutils literal notranslate"><span class="pre">--vdev</span></code> with appropriate libraries are to be added.</p></li>
<li><p>An Application with crypto PMD instances sharing the same library requires unique ID.</p></li>
</ul>
<p>Example: <code class="docutils literal notranslate"><span class="pre">--vdev</span>&#160; <span class="pre">'crypto_aesni_mb0'</span> <span class="pre">--vdev</span>&#160; <span class="pre">'crypto_aesni_mb1'</span></code></p>
</div>
<p>Or using the rte_vdev_init API within the application code.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rte_vdev_init</span><span class="p">(</span><span class="s">&quot;crypto_aesni_mb&quot;</span><span class="p">,</span>
                  <span class="s">&quot;max_nb_queue_pairs=2,socket_id=0&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>All virtual Crypto devices support the following initialization parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_nb_queue_pairs</span></code> - maximum number of queue pairs supported by the device.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">socket_id</span></code> - socket on which to allocate the device resources on.</p></li>
</ul>
</div>
<div class="section" id="device-identification">
<h3><span class="section-number">17.2.2. </span>Device Identification</h3>
<p>Each device, whether virtual or physical is uniquely designated by two
identifiers:</p>
<ul class="simple">
<li><p>A unique device index used to designate the Crypto device in all functions
exported by the cryptodev API.</p></li>
<li><p>A device name used to designate the Crypto device in console messages, for
administration or debugging purposes. For ease of use, the port name includes
the port index.</p></li>
</ul>
</div>
<div class="section" id="device-configuration">
<h3><span class="section-number">17.2.3. </span>Device Configuration</h3>
<p>The configuration of each Crypto device includes the following operations:</p>
<ul class="simple">
<li><p>Allocation of resources, including hardware resources if a physical device.</p></li>
<li><p>Resetting the device into a well-known default state.</p></li>
<li><p>Initialization of statistics counters.</p></li>
</ul>
<p>The rte_cryptodev_configure API is used to configure a Crypto device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">rte_cryptodev_configure</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">dev_id</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">rte_cryptodev_config</span> <span class="o">*</span><span class="n">config</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_config</span></code> structure is used to pass the configuration
parameters for socket selection and number of queue pairs.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_cryptodev_config</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">socket_id</span><span class="p">;</span>
    <span class="cm">/**&lt; Socket to allocate resources on */</span>
    <span class="kt">uint16_t</span> <span class="n">nb_queue_pairs</span><span class="p">;</span>
    <span class="cm">/**&lt; Number of queue pairs to configure on device */</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="configuration-of-queue-pairs">
<h3><span class="section-number">17.2.4. </span>Configuration of Queue Pairs</h3>
<p>Each Crypto devices queue pair is individually configured through the
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_queue_pair_setup</span></code> API.
Each queue pairs resources may be allocated on a specified socket.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span> <span class="kt">int</span> <span class="nf">rte_cryptodev_queue_pair_setup</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_pair_id</span><span class="p">,</span>
             <span class="k">const</span> <span class="k">struct</span> <span class="n">rte_cryptodev_qp_conf</span> <span class="o">*</span><span class="n">qp_conf</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">socket_id</span><span class="p">)</span>

<span class="k">struct</span> <span class="n">rte_cryptodev_qp_conf</span> <span class="p">{</span>
     <span class="kt">uint32_t</span> <span class="n">nb_descriptors</span><span class="p">;</span> <span class="cm">/**&lt; Number of descriptors per queue pair */</span>
     <span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mp_session</span><span class="p">;</span>
     <span class="cm">/**&lt; The mempool for creating session in sessionless mode */</span>
     <span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mp_session_private</span><span class="p">;</span>
     <span class="cm">/**&lt; The mempool for creating sess private data in sessionless mode */</span>
 <span class="p">};</span>
</pre></div>
</div>
<p>The fields <code class="docutils literal notranslate"><span class="pre">mp_session</span></code> and <code class="docutils literal notranslate"><span class="pre">mp_session_private</span></code> are used for creating
temporary session to process the crypto operations in the session-less mode.
They can be the same other different mempools. Please note not all Cryptodev
PMDs supports session-less mode.</p>
</div>
<div class="section" id="logical-cores-memory-and-queues-pair-relationships">
<h3><span class="section-number">17.2.5. </span>Logical Cores, Memory and Queues Pair Relationships</h3>
<p>The Crypto device Library as the Poll Mode Driver library support NUMA for when
a processorâ€™s logical cores and interfaces utilize its local memory. Therefore
Crypto operations, and in the case of symmetric Crypto operations, the session
and the mbuf being operated on, should be allocated from memory pools created
in the local memory. The buffers should, if possible, remain on the local
processor to obtain the best performance results and buffer descriptors should
be populated with mbufs allocated from a mempool allocated from local memory.</p>
<p>The run-to-completion model also performs better, especially in the case of
virtual Crypto devices, if the Crypto operation and session and data buffer is
in local memory instead of a remote processorâ€™s memory. This is also true for
the pipe-line model provided all logical cores used are located on the same
processor.</p>
<p>Multiple logical cores should never share the same queue pair for enqueuing
operations or dequeuing operations on the same Crypto device since this would
require global locks and hinder performance. It is however possible to use a
different logical core to dequeue an operation on a queue pair from the logical
core which it was enqueued on. This means that a crypto burst enqueue/dequeue
APIs are a logical place to transition from one logical core to another in a
packet processing pipeline.</p>
</div>
</div>
<div class="section" id="device-features-and-capabilities">
<h2><span class="section-number">17.3. </span>Device Features and Capabilities</h2>
<p>Crypto devices define their functionality through two mechanisms, global device
features and algorithm capabilities. Global devices features identify device
wide level features which are applicable to the whole device such as
the device having hardware acceleration or supporting symmetric and/or asymmetric
Crypto operations.</p>
<p>The capabilities mechanism defines the individual algorithms/functions which
the device supports, such as a specific symmetric Crypto cipher,
authentication operation or Authenticated Encryption with Associated Data
(AEAD) operation.</p>
<div class="section" id="device-features">
<h3><span class="section-number">17.3.1. </span>Device Features</h3>
<p>Currently the following Crypto device features are defined:</p>
<ul class="simple">
<li><p>Symmetric Crypto operations</p></li>
<li><p>Asymmetric Crypto operations</p></li>
<li><p>Chaining of symmetric Crypto operations</p></li>
<li><p>SSE accelerated SIMD vector operations</p></li>
<li><p>AVX accelerated SIMD vector operations</p></li>
<li><p>AVX2 accelerated SIMD vector operations</p></li>
<li><p>AESNI accelerated instructions</p></li>
<li><p>Hardware off-load processing</p></li>
</ul>
</div>
<div class="section" id="device-operation-capabilities">
<h3><span class="section-number">17.3.2. </span>Device Operation Capabilities</h3>
<p>Crypto capabilities which identify particular algorithm which the Crypto PMD
supports are  defined by the operation type, the operation transform, the
transform identifier and then the particulars of the transform. For the full
scope of the Crypto capability see the definition of the structure in the
<em>DPDK API Reference</em>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_cryptodev_capabilities</span><span class="p">;</span>
</pre></div>
</div>
<p>Each Crypto poll mode driver defines its own private array of capabilities
for the operations it supports. Below is an example of the capabilities for a
PMD which supports the authentication algorithm SHA1_HMAC and the cipher
algorithm AES_CBC.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rte_cryptodev_capabilities</span> <span class="n">pmd_capabilities</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span>    <span class="cm">/* SHA1 HMAC */</span>
        <span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_OP_TYPE_SYMMETRIC</span><span class="p">,</span>
        <span class="p">.</span><span class="n">sym</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">xform_type</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_SYM_XFORM_AUTH</span><span class="p">,</span>
            <span class="p">.</span><span class="n">auth</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">algo</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_AUTH_SHA1_HMAC</span><span class="p">,</span>
                <span class="p">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
                <span class="p">.</span><span class="n">key_size</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">increment</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="p">},</span>
                <span class="p">.</span><span class="n">digest_size</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">increment</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="p">},</span>
                <span class="p">.</span><span class="n">aad_size</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">},</span>
                <span class="p">.</span><span class="n">iv_size</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>    <span class="cm">/* AES CBC */</span>
        <span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_OP_TYPE_SYMMETRIC</span><span class="p">,</span>
        <span class="p">.</span><span class="n">sym</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">xform_type</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_SYM_XFORM_CIPHER</span><span class="p">,</span>
            <span class="p">.</span><span class="n">cipher</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">algo</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_CIPHER_AES_CBC</span><span class="p">,</span>
                <span class="p">.</span><span class="n">block_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
                <span class="p">.</span><span class="n">key_size</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">increment</span> <span class="o">=</span> <span class="mi">8</span>
                <span class="p">},</span>
                <span class="p">.</span><span class="n">iv_size</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="p">.</span><span class="n">min</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">increment</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="capabilities-discovery">
<h3><span class="section-number">17.3.3. </span>Capabilities Discovery</h3>
<p>Discovering the features and capabilities of a Crypto device poll mode driver
is achieved through the <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_info_get</span></code> function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">rte_cryptodev_info_get</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">dev_id</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">rte_cryptodev_info</span> <span class="o">*</span><span class="n">dev_info</span><span class="p">);</span>
</pre></div>
</div>
<p>This allows the user to query a specific Crypto PMD and get all the device
features and capabilities. The <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_info</span></code> structure contains all the
relevant information for the device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_cryptodev_info</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">driver_name</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">driver_id</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">feature_flags</span><span class="p">;</span>

    <span class="k">const</span> <span class="k">struct</span> <span class="n">rte_cryptodev_capabilities</span> <span class="o">*</span><span class="n">capabilities</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="n">max_nb_queue_pairs</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">max_nb_sessions</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">sym</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="operation-processing">
<h2><span class="section-number">17.4. </span>Operation Processing</h2>
<p>Scheduling of Crypto operations on DPDKâ€™s application data path is
performed using a burst oriented asynchronous API set. A queue pair on a Crypto
device accepts a burst of Crypto operations using enqueue burst API. On physical
Crypto devices the enqueue burst API will place the operations to be processed
on the devices hardware input queue, for virtual devices the processing of the
Crypto operations is usually completed during the enqueue call to the Crypto
device. The dequeue burst API will retrieve any processed operations available
from the queue pair on the Crypto device, from physical devices this is usually
directly from the devices processed queue, and for virtual deviceâ€™s from a
<code class="docutils literal notranslate"><span class="pre">rte_ring</span></code> where processed operations are placed after being processed on the
enqueue call.</p>
<div class="section" id="private-data">
<h3><span class="section-number">17.4.1. </span>Private data</h3>
<p>For session-based operations, the set and get API provides a mechanism for an
application to store and retrieve the private user data information stored along
with the crypto session.</p>
<p>For example, suppose an application is submitting a crypto operation with a session
associated and wants to indicate private user data information which is required to be
used after completion of the crypto operation. In this case, the application can use
the set API to set the user data and retrieve it using get API.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">rte_cryptodev_sym_session_set_user_data</span><span class="p">(</span>
        <span class="k">struct</span> <span class="n">rte_cryptodev_sym_session</span> <span class="o">*</span><span class="n">sess</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">size</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">rte_cryptodev_sym_session_get_user_data</span><span class="p">(</span>
        <span class="k">struct</span> <span class="n">rte_cryptodev_sym_session</span> <span class="o">*</span><span class="n">sess</span><span class="p">);</span>
</pre></div>
</div>
<p>Please note the <code class="docutils literal notranslate"><span class="pre">size</span></code> passed to set API cannot be bigger than the predefined
<code class="docutils literal notranslate"><span class="pre">user_data_sz</span></code> when creating the session header mempool, otherwise the
function will return error. Also when <code class="docutils literal notranslate"><span class="pre">user_data_sz</span></code> was defined as <code class="docutils literal notranslate"><span class="pre">0</span></code> when
creating the session header mempool, the get API will always return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>For session-less mode, the private user data information can be placed along with the
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_op</span></code>. The <code class="docutils literal notranslate"><span class="pre">rte_crypto_op::private_data_offset</span></code> indicates the
start of private data information. The offset is counted from the start of the
rte_crypto_op including other crypto information such as the IVs (since there can
be an IV also for authentication).</p>
</div>
<div class="section" id="enqueue-dequeue-burst-apis">
<h3><span class="section-number">17.4.2. </span>Enqueue / Dequeue Burst APIs</h3>
<p>The burst enqueue API uses a Crypto device identifier and a queue pair
identifier to specify the Crypto device queue pair to schedule the processing on.
The <code class="docutils literal notranslate"><span class="pre">nb_ops</span></code> parameter is the number of operations to process which are
supplied in the <code class="docutils literal notranslate"><span class="pre">ops</span></code> array of <code class="docutils literal notranslate"><span class="pre">rte_crypto_op</span></code> structures.
The enqueue function returns the number of operations it actually enqueued for
processing, a return value equal to <code class="docutils literal notranslate"><span class="pre">nb_ops</span></code> means that all packets have been
enqueued.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16_t</span> <span class="n">rte_cryptodev_enqueue_burst</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">qp_id</span><span class="p">,</span>
                                     <span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">nb_ops</span><span class="p">)</span>
</pre></div>
</div>
<p>The dequeue API uses the same format as the enqueue API of processed but
the <code class="docutils literal notranslate"><span class="pre">nb_ops</span></code> and <code class="docutils literal notranslate"><span class="pre">ops</span></code> parameters are now used to specify the max processed
operations the user wishes to retrieve and the location in which to store them.
The API call returns the actual number of processed operations returned, this
can never be larger than <code class="docutils literal notranslate"><span class="pre">nb_ops</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16_t</span> <span class="n">rte_cryptodev_dequeue_burst</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">qp_id</span><span class="p">,</span>
                                     <span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">nb_ops</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="operation-representation">
<h3><span class="section-number">17.4.3. </span>Operation Representation</h3>
<p>An Crypto operation is represented by an rte_crypto_op structure, which is a
generic metadata container for all necessary information required for the
Crypto operation to be processed on a particular Crypto device poll mode driver.</p>
<div class="figure align-default">
<img alt="../_images/crypto_op.svg" src="../_images/crypto_op.svg" /></div>
<p>The operation structure includes the operation type, the operation status
and the session type (session-based/less), a reference to the operation
specific data, which can vary in size and content depending on the operation
being provisioned. It also contains the source mempool for the operation,
if it allocated from a mempool.</p>
<p>If Crypto operations are allocated from a Crypto operation mempool, see next
section, there is also the ability to allocate private memory with the
operation for applications purposes.</p>
<p>Application software is responsible for specifying all the operation specific
fields in the <code class="docutils literal notranslate"><span class="pre">rte_crypto_op</span></code> structure which are then used by the Crypto PMD
to process the requested operation.</p>
</div>
<div class="section" id="operation-management-and-allocation">
<h3><span class="section-number">17.4.4. </span>Operation Management and Allocation</h3>
<p>The cryptodev library provides an API set for managing Crypto operations which
utilize the Mempool Library to allocate operation buffers. Therefore, it ensures
that the crypto operation is interleaved optimally across the channels and
ranks for optimal processing.
A <code class="docutils literal notranslate"><span class="pre">rte_crypto_op</span></code> contains a field indicating the pool that it originated from.
When calling <code class="docutils literal notranslate"><span class="pre">rte_crypto_op_free(op)</span></code>, the operation returns to its original pool.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span>
<span class="nf">rte_crypto_op_pool_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">enum</span> <span class="n">rte_crypto_op_type</span> <span class="n">type</span><span class="p">,</span>
                          <span class="kt">unsigned</span> <span class="n">nb_elts</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">cache_size</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">priv_size</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">socket_id</span><span class="p">);</span>
</pre></div>
</div>
<p>During pool creation <code class="docutils literal notranslate"><span class="pre">rte_crypto_op_init()</span></code> is called as a constructor to
initialize each Crypto operation which subsequently calls
<code class="docutils literal notranslate"><span class="pre">__rte_crypto_op_reset()</span></code> to configure any operation type specific fields based
on the type parameter.</p>
<p><code class="docutils literal notranslate"><span class="pre">rte_crypto_op_alloc()</span></code> and <code class="docutils literal notranslate"><span class="pre">rte_crypto_op_bulk_alloc()</span></code> are used to allocate
Crypto operations of a specific type from a given Crypto operation mempool.
<code class="docutils literal notranslate"><span class="pre">__rte_crypto_op_reset()</span></code> is called on each operation before being returned to
allocate to a user so the operation is always in a good known state before use
by the application.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">*</span><span class="n">rte_crypto_op_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mempool</span><span class="p">,</span>
                                          <span class="k">enum</span> <span class="n">rte_crypto_op_type</span> <span class="n">type</span><span class="p">)</span>

<span class="kt">unsigned</span> <span class="n">rte_crypto_op_bulk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mempool</span><span class="p">,</span>
                                  <span class="k">enum</span> <span class="n">rte_crypto_op_type</span> <span class="n">type</span><span class="p">,</span>
                                  <span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">nb_ops</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">rte_crypto_op_free()</span></code> is called by the application to return an operation to
its allocating pool.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">rte_crypto_op_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">*</span><span class="n">op</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="symmetric-cryptography-support">
<h2><span class="section-number">17.5. </span>Symmetric Cryptography Support</h2>
<p>The cryptodev library currently provides support for the following symmetric
Crypto operations; cipher, authentication, including chaining of these
operations, as well as also supporting AEAD operations.</p>
<div class="section" id="session-and-session-management">
<h3><span class="section-number">17.5.1. </span>Session and Session Management</h3>
<p>Sessions are used in symmetric cryptographic processing to store the immutable
data defined in a cryptographic transform which is used in the operation
processing of a packet flow. Sessions are used to manage information such as
expand cipher keys and HMAC IPADs and OPADs, which need to be calculated for a
particular Crypto operation, but are immutable on a packet to packet basis for
a flow. Crypto sessions cache this immutable data in a optimal way for the
underlying PMD and this allows further acceleration of the offload of
Crypto workloads.</p>
<div class="figure align-default">
<img alt="../_images/cryptodev_sym_sess.svg" src="../_images/cryptodev_sym_sess.svg" /></div>
<p>The Crypto device framework provides APIs to create session mempool and allocate
and initialize sessions for crypto devices, where sessions are mempool objects.
The application has to use <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_sym_session_pool_create()</span></code> to
create the session header mempool that creates a mempool with proper element
size automatically and stores necessary information for safely accessing the
session in the mempoolâ€™s private data field.</p>
<p>To create a mempool for storing session private data, the application has two
options. The first is to create another mempool with elt size equal to or
bigger than the maximum session private data size of all crypto devices that
will share the same session header. The creation of the mempool shall use the
traditional <code class="docutils literal notranslate"><span class="pre">rte_mempool_create()</span></code> with the correct <code class="docutils literal notranslate"><span class="pre">elt_size</span></code>. The other
option is to change the <code class="docutils literal notranslate"><span class="pre">elt_size</span></code> parameter in
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_sym_session_pool_create()</span></code> to the correct value. The first
option is more complex to implement but may result in better memory usage as
a session header normally takes smaller memory footprint as the session private
data.</p>
<p>Once the session mempools have been created, <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_sym_session_create()</span></code>
is used to allocate an uninitialized session from the given mempool.
The session then must be initialized using <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_sym_session_init()</span></code>
for each of the required crypto devices. A symmetric transform chain
is used to specify the operation and its parameters. See the section below for
details on transforms.</p>
<p>When a session is no longer used, user must call <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_sym_session_clear()</span></code>
for each of the crypto devices that are using the session, to free all driver
private session data. Once this is done, session should be freed using
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_sym_session_free</span></code> which returns them to their mempool.</p>
</div>
<div class="section" id="transforms-and-transform-chaining">
<h3><span class="section-number">17.5.2. </span>Transforms and Transform Chaining</h3>
<p>Symmetric Crypto transforms (<code class="docutils literal notranslate"><span class="pre">rte_crypto_sym_xform</span></code>) are the mechanism used
to specify the details of the Crypto operation. For chaining of symmetric
operations such as cipher encrypt and authentication generate, the next pointer
allows transform to be chained together. Crypto devices which support chaining
must publish the chaining of symmetric Crypto operations feature flag. Allocation of the
xform structure is in the application domain. To allow future API extensions in a
backwardly compatible manner, e.g. addition of a new parameter, the application should
zero the full xform struct before populating it.</p>
<p>Currently there are three transforms types cipher, authentication and AEAD.
Also it is important to note that the order in which the
transforms are passed indicates the order of the chaining.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_crypto_sym_xform</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_crypto_sym_xform</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="cm">/**&lt; next xform in chain */</span>
    <span class="k">enum</span> <span class="n">rte_crypto_sym_xform_type</span> <span class="n">type</span><span class="p">;</span>
    <span class="cm">/**&lt; xform type */</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_crypto_auth_xform</span> <span class="n">auth</span><span class="p">;</span>
        <span class="cm">/**&lt; Authentication / hash xform */</span>
        <span class="k">struct</span> <span class="n">rte_crypto_cipher_xform</span> <span class="n">cipher</span><span class="p">;</span>
        <span class="cm">/**&lt; Cipher xform */</span>
        <span class="k">struct</span> <span class="n">rte_crypto_aead_xform</span> <span class="n">aead</span><span class="p">;</span>
        <span class="cm">/**&lt; AEAD xform */</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The API does not place a limit on the number of transforms that can be chained
together but this will be limited by the underlying Crypto device poll mode
driver which is processing the operation.</p>
<div class="figure align-default">
<img alt="../_images/crypto_xform_chain.svg" src="../_images/crypto_xform_chain.svg" /></div>
</div>
<div class="section" id="symmetric-operations">
<h3><span class="section-number">17.5.3. </span>Symmetric Operations</h3>
<p>The symmetric Crypto operation structure contains all the mutable data relating
to performing symmetric cryptographic processing on a referenced mbuf data
buffer. It is used for either cipher, authentication, AEAD and chained
operations.</p>
<p>As a minimum the symmetric operation must have a source data buffer (<code class="docutils literal notranslate"><span class="pre">m_src</span></code>),
a valid session (or transform chain if in session-less mode) and the minimum
authentication/ cipher/ AEAD parameters required depending on the type of operation
specified in the session or the transform
chain.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_crypto_sym_op</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">m_src</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">m_dst</span><span class="p">;</span>

    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_cryptodev_sym_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
        <span class="cm">/**&lt; Handle for the initialised session context */</span>
        <span class="k">struct</span> <span class="n">rte_crypto_sym_xform</span> <span class="o">*</span><span class="n">xform</span><span class="p">;</span>
        <span class="cm">/**&lt; Session-less API Crypto operation parameters */</span>
    <span class="p">};</span>

    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="p">{</span>
                <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
                <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
            <span class="p">}</span> <span class="n">data</span><span class="p">;</span> <span class="cm">/**&lt; Data offsets and length for AEAD */</span>

            <span class="k">struct</span> <span class="p">{</span>
                <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
                <span class="n">rte_iova_t</span> <span class="n">phys_addr</span><span class="p">;</span>
            <span class="p">}</span> <span class="n">digest</span><span class="p">;</span> <span class="cm">/**&lt; Digest parameters */</span>

            <span class="k">struct</span> <span class="p">{</span>
                <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
                <span class="n">rte_iova_t</span> <span class="n">phys_addr</span><span class="p">;</span>
            <span class="p">}</span> <span class="n">aad</span><span class="p">;</span>
            <span class="cm">/**&lt; Additional authentication parameters */</span>
        <span class="p">}</span> <span class="n">aead</span><span class="p">;</span>

        <span class="k">struct</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="p">{</span>
                    <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
                    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
                <span class="p">}</span> <span class="n">data</span><span class="p">;</span> <span class="cm">/**&lt; Data offsets and length for ciphering */</span>
            <span class="p">}</span> <span class="n">cipher</span><span class="p">;</span>

            <span class="k">struct</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="p">{</span>
                    <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
                    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
                <span class="p">}</span> <span class="n">data</span><span class="p">;</span>
                <span class="cm">/**&lt; Data offsets and length for authentication */</span>

                <span class="k">struct</span> <span class="p">{</span>
                    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
                    <span class="n">rte_iova_t</span> <span class="n">phys_addr</span><span class="p">;</span>
                <span class="p">}</span> <span class="n">digest</span><span class="p">;</span> <span class="cm">/**&lt; Digest parameters */</span>
            <span class="p">}</span> <span class="n">auth</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="synchronous-mode">
<h2><span class="section-number">17.6. </span>Synchronous mode</h2>
<p>Some cryptodevs support synchronous mode alongside with a standard asynchronous
mode. In that case operations are performed directly when calling
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_sym_cpu_crypto_process</span></code> method instead of enqueuing and
dequeuing an operation before. This mode of operation allows cryptodevs which
utilize CPU cryptographic acceleration to have significant performance boost
comparing to standard asynchronous approach. Cryptodevs supporting synchronous
mode have <code class="docutils literal notranslate"><span class="pre">RTE_CRYPTODEV_FF_SYM_CPU_CRYPTO</span></code> feature flag set.</p>
<p>To perform a synchronous operation a call to
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_sym_cpu_crypto_process</span></code> has to be made with vectorized
operation descriptor (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_sym_vec</span></code>) containing:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num</span></code> - number of operations to perform,</p></li>
<li><p>pointer to an array of size <code class="docutils literal notranslate"><span class="pre">num</span></code> containing a scatter-gather list
descriptors of performed operations (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_sgl</span></code>). Each instance
of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_sgl</span></code> consists of a number of segments and a pointer to
an array of segment descriptors <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_vec</span></code>;</p></li>
<li><p>pointers to arrays of size <code class="docutils literal notranslate"><span class="pre">num</span></code> containing IV, AAD and digest information
in the <code class="docutils literal notranslate"><span class="pre">cpu_crypto</span></code> sub-structure,</p></li>
<li><p>pointer to an array of size <code class="docutils literal notranslate"><span class="pre">num</span></code> where status information will be stored
for each operation.</p></li>
</ul>
<p>Function returns a number of successfully completed operations and sets
appropriate status number for each operation in the status array provided as
a call argument. Status different than zero must be treated as error.</p>
<p>For more details, e.g. how to convert an mbuf to an SGL, please refer to an
example usage in the IPsec library implementation.</p>
<div class="section" id="cryptodev-raw-data-path-apis">
<h3><span class="section-number">17.6.1. </span>Cryptodev Raw Data-path APIs</h3>
<p>The Crypto Raw data-path APIs are a set of APIs designed to enable external
libraries/applications to leverage the cryptographic processing provided by
DPDK crypto PMDs through the cryptodev API but in a manner that is not
dependent on native DPDK data structures (eg. rte_mbuf, rte_crypto_op, â€¦ etc)
in their data-path implementation.</p>
<p>The raw data-path APIs have the following advantages:</p>
<ul class="simple">
<li><p>External data structure friendly design. The new APIs uses the operation
descriptor <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_sym_vec</span></code> that supports raw data pointer and
IOVA addresses as input. Moreover, the APIs does not require the user to
allocate the descriptor from mempool, nor requiring mbufs to describe input
dataâ€™s virtual and IOVA addresses. All these features made the translation
from userâ€™s own data structure into the descriptor easier and more efficient.</p></li>
<li><p>Flexible enqueue and dequeue operation. The raw data-path APIs gives the
user more control to the enqueue and dequeue operations, including the
capability of precious enqueue/dequeue count, abandoning enqueue or dequeue
at any time, and operation status translation and set on the fly.</p></li>
</ul>
<p>Cryptodev PMDs which support the raw data-path APIs will have
<code class="docutils literal notranslate"><span class="pre">RTE_CRYPTODEV_FF_SYM_RAW_DP</span></code> feature flag presented. To use this feature,
the user shall create a local <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_raw_dp_ctx</span></code> buffer and
extend to at least the length returned by <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_get_raw_dp_ctx_size</span></code>
function call. The created buffer is then initialized using
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_configure_raw_dp_ctx</span></code> function with the <code class="docutils literal notranslate"><span class="pre">is_update</span></code>
parameter as 0. The library and the crypto device driver will then set the
buffer and attach either the cryptodev sym session, the rte_security session,
or the cryptodev xform for session-less operation into the ctx buffer, and
set the corresponding enqueue and dequeue function handlers based on the
algorithm information stored in the session or xform. When the <code class="docutils literal notranslate"><span class="pre">is_update</span></code>
parameter passed into <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_configure_raw_dp_ctx</span></code> is 1, the driver
will not initialize the buffer but only update the session or xform and
the function handlers accordingly.</p>
<p>After the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_raw_dp_ctx</span></code> buffer is initialized, it is now
ready for enqueue and dequeue operation. There are two different enqueue
functions: <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue</span></code> to enqueue single raw data
operation, and <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue_burst</span></code> to enqueue a descriptor
with multiple operations. In case of the application uses similar approach to
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_sym_vec</span></code> to manage its data burst but with different
data structure, using the <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue_burst</span></code> function may be
less efficient as this is a situation where the application has to loop over
all crypto operations to assemble the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_sym_vec</span></code> descriptor
from its own data structure, and then the driver will loop over them again to
translate every operation in the descriptor to the driverâ€™s specific queue data.
The <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue</span></code> should be used to save one loop for each data
burst instead.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue</span></code> and <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue_burst</span></code>
functions will return or set the enqueue status. <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue</span></code>
will return the status directly, <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue_burst</span></code> will
return the number of operations enqueued or stored (explained as follows) and
set the <code class="docutils literal notranslate"><span class="pre">enqueue_status</span></code> buffer provided by the user. The possible
enqueue status values are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>: the operation(s) is/are enqueued successfully.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>: the operation(s) is/are cached successfully in the crypto device queue
but is not actually enqueued. The user shall call
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue_done</span></code> function after the expected operations
are stored. The crypto device will then start enqueuing all of them at
once.</p></li>
<li><p>The negative integer: error occurred during enqueue.</p></li>
</ul>
<p>Calling <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_configure_raw_dp_ctx</span></code> with the parameter <code class="docutils literal notranslate"><span class="pre">is_update</span></code>
set as 0 twice without the enqueue function returning or setting enqueue status
to 1 or <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_enqueue_done</span></code> function being called in between will
invalidate any operation stored in the device queue but not enqueued. This
feature is useful when the user wants to abandon partially enqueued operations
for a failed enqueue burst operation and try enqueuing in a whole later.</p>
<p>Similar as enqueue, there are two dequeue functions:
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_dequeue</span></code> for dequeing single operation, and
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_dequeue_burst</span></code> for dequeuing a burst of operations (e.g.
all operations in a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_sym_vec</span></code> descriptor). The
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_dequeue_burst</span></code> function allows the user to provide callback
functions to retrieve dequeue count from the enqueued user data and write the
expected status value to the user data on the fly. The dequeue functions also
set the dequeue status:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>: the operation(s) is/are dequeued successfully.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>: the operation(s) is/are completed but is not actually dequeued (hence
still kept in the device queue). The user shall call the
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_dequeue_done</span></code> function after the expected number of
operations (e.g. all operations in a descriptor) are dequeued. The crypto
device driver will then free them from the queue at once.</p></li>
<li><p>The negative integer: error occurred during dequeue.</p></li>
</ul>
<p>Calling <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_configure_raw_dp_ctx</span></code> with the parameter <code class="docutils literal notranslate"><span class="pre">is_update</span></code>
set as 0 twice without the dequeue functions execution changed dequeue_status
to 1 or <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_raw_dequeue_done</span></code> function being called in between will
revert the crypto device queueâ€™s dequeue effort to the moment when the
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_crypto_raw_dp_ctx</span></code> buffer is initialized. This feature is useful
when the user wants to abandon partially dequeued data and try dequeuing again
later in a whole.</p>
<p>There are a few limitations to the raw data path APIs:</p>
<ul class="simple">
<li><p>Only support in-place operations.</p></li>
<li><p>APIs are NOT thread-safe.</p></li>
<li><p>CANNOT mix the raw data-path APIâ€™s enqueue with rte_cryptodev_enqueue_burst,
or vice versa.</p></li>
</ul>
<p>See <em>DPDK API Reference</em> for details on each API definitions.</p>
</div>
</div>
<div class="section" id="sample-code">
<h2><span class="section-number">17.7. </span>Sample code</h2>
<p>There are various sample applications that show how to use the cryptodev library,
such as the L2fwd with Crypto sample application (L2fwd-crypto) and
the IPsec Security Gateway application (ipsec-secgw).</p>
<p>While these applications demonstrate how an application can be created to perform
generic crypto operation, the required complexity hides the basic steps of
how to use the cryptodev APIs.</p>
<p>The following sample code shows the basic steps to encrypt several buffers
with AES-CBC (although performing other crypto operations is similar),
using one of the crypto PMDs available in DPDK.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Simple example to encrypt several buffers with AES-CBC using</span>
<span class="cm"> * the Cryptodev APIs.</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_SESSIONS         1024</span>
<span class="cp">#define NUM_MBUFS            1024</span>
<span class="cp">#define POOL_CACHE_SIZE      128</span>
<span class="cp">#define BURST_SIZE           32</span>
<span class="cp">#define BUFFER_SIZE          1024</span>
<span class="cp">#define AES_CBC_IV_LENGTH    16</span>
<span class="cp">#define AES_CBC_KEY_LENGTH   16</span>
<span class="cp">#define IV_OFFSET            (sizeof(struct rte_crypto_op) + \</span>
<span class="cp">                             sizeof(struct rte_crypto_sym_op))</span>

<span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mbuf_pool</span><span class="p">,</span> <span class="o">*</span><span class="n">crypto_op_pool</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">session_pool</span><span class="p">,</span> <span class="o">*</span><span class="n">session_priv_pool</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">session_size</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="cm">/* Initialize EAL. */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eal_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Invalid EAL arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="kt">uint8_t</span> <span class="n">socket_id</span> <span class="o">=</span> <span class="n">rte_socket_id</span><span class="p">();</span>

<span class="cm">/* Create the mbuf pool. */</span>
<span class="n">mbuf_pool</span> <span class="o">=</span> <span class="n">rte_pktmbuf_pool_create</span><span class="p">(</span><span class="s">&quot;mbuf_pool&quot;</span><span class="p">,</span>
                                <span class="n">NUM_MBUFS</span><span class="p">,</span>
                                <span class="n">POOL_CACHE_SIZE</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">,</span>
                                <span class="n">RTE_MBUF_DEFAULT_BUF_SIZE</span><span class="p">,</span>
                                <span class="n">socket_id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mbuf_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Cannot create mbuf pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The IV is always placed after the crypto operation,</span>
<span class="cm"> * so some private data is required to be reserved.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">crypto_op_private_data</span> <span class="o">=</span> <span class="n">AES_CBC_IV_LENGTH</span><span class="p">;</span>

<span class="cm">/* Create crypto operation pool. */</span>
<span class="n">crypto_op_pool</span> <span class="o">=</span> <span class="n">rte_crypto_op_pool_create</span><span class="p">(</span><span class="s">&quot;crypto_op_pool&quot;</span><span class="p">,</span>
                                        <span class="n">RTE_CRYPTO_OP_TYPE_SYMMETRIC</span><span class="p">,</span>
                                        <span class="n">NUM_MBUFS</span><span class="p">,</span>
                                        <span class="n">POOL_CACHE_SIZE</span><span class="p">,</span>
                                        <span class="n">crypto_op_private_data</span><span class="p">,</span>
                                        <span class="n">socket_id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">crypto_op_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Cannot create crypto op pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Create the virtual crypto device. */</span>
<span class="kt">char</span> <span class="n">args</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">crypto_name</span> <span class="o">=</span> <span class="s">&quot;crypto_aesni_mb0&quot;</span><span class="p">;</span>
<span class="n">snprintf</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="s">&quot;socket_id=%d&quot;</span><span class="p">,</span> <span class="n">socket_id</span><span class="p">);</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_vdev_init</span><span class="p">(</span><span class="n">crypto_name</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Cannot create virtual device&quot;</span><span class="p">);</span>

<span class="kt">uint8_t</span> <span class="n">cdev_id</span> <span class="o">=</span> <span class="n">rte_cryptodev_get_dev_id</span><span class="p">(</span><span class="n">crypto_name</span><span class="p">);</span>

<span class="cm">/* Get private session data size. */</span>
<span class="n">session_size</span> <span class="o">=</span> <span class="n">rte_cryptodev_sym_get_private_session_size</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">);</span>

<span class="cp">#ifdef USE_TWO_MEMPOOLS</span>
<span class="cm">/* Create session mempool for the session header. */</span>
<span class="n">session_pool</span> <span class="o">=</span> <span class="n">rte_cryptodev_sym_session_pool_create</span><span class="p">(</span><span class="s">&quot;session_pool&quot;</span><span class="p">,</span>
                                <span class="n">MAX_SESSIONS</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">,</span>
                                <span class="n">POOL_CACHE_SIZE</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">,</span>
                                <span class="n">socket_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Create session private data mempool for the</span>
<span class="cm"> * private session data for the crypto device.</span>
<span class="cm"> */</span>
<span class="n">session_priv_pool</span> <span class="o">=</span> <span class="n">rte_mempool_create</span><span class="p">(</span><span class="s">&quot;session_pool&quot;</span><span class="p">,</span>
                                <span class="n">MAX_SESSIONS</span><span class="p">,</span>
                                <span class="n">session_size</span><span class="p">,</span>
                                <span class="n">POOL_CACHE_SIZE</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                <span class="nb">NULL</span><span class="p">,</span> <span class="n">socket_id</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="cm">/* Use of the same mempool for session header and private data */</span>
    <span class="n">session_pool</span> <span class="o">=</span> <span class="n">rte_cryptodev_sym_session_pool_create</span><span class="p">(</span><span class="s">&quot;session_pool&quot;</span><span class="p">,</span>
                                <span class="n">MAX_SESSIONS</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="n">session_size</span><span class="p">,</span>
                                <span class="n">POOL_CACHE_SIZE</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">,</span>
                                <span class="n">socket_id</span><span class="p">);</span>

    <span class="n">session_priv_pool</span> <span class="o">=</span> <span class="n">session_pool</span><span class="p">;</span>

<span class="cp">#endif</span>

<span class="cm">/* Configure the crypto device. */</span>
<span class="k">struct</span> <span class="n">rte_cryptodev_config</span> <span class="n">conf</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">nb_queue_pairs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">socket_id</span> <span class="o">=</span> <span class="n">socket_id</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rte_cryptodev_qp_conf</span> <span class="n">qp_conf</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">nb_descriptors</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">,</span>
    <span class="p">.</span><span class="n">mp_session</span> <span class="o">=</span> <span class="n">session_pool</span><span class="p">,</span>
    <span class="p">.</span><span class="n">mp_session_private</span> <span class="o">=</span> <span class="n">session_priv_pool</span>
<span class="p">};</span>

<span class="k">if</span> <span class="p">(</span><span class="n">rte_cryptodev_configure</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Failed to configure cryptodev %u&quot;</span><span class="p">,</span> <span class="n">cdev_id</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">rte_cryptodev_queue_pair_setup</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qp_conf</span><span class="p">,</span> <span class="n">socket_id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Failed to setup queue pair</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">rte_cryptodev_start</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Failed to start device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Create the crypto transform. */</span>
<span class="kt">uint8_t</span> <span class="n">cipher_key</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="k">struct</span> <span class="n">rte_crypto_sym_xform</span> <span class="n">cipher_xform</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_SYM_XFORM_CIPHER</span><span class="p">,</span>
    <span class="p">.</span><span class="n">cipher</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_CIPHER_OP_ENCRYPT</span><span class="p">,</span>
        <span class="p">.</span><span class="n">algo</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_CIPHER_AES_CBC</span><span class="p">,</span>
        <span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">cipher_key</span><span class="p">,</span>
            <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">AES_CBC_KEY_LENGTH</span>
        <span class="p">},</span>
        <span class="p">.</span><span class="n">iv</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">IV_OFFSET</span><span class="p">,</span>
            <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">AES_CBC_IV_LENGTH</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* Create crypto session and initialize it for the crypto device. */</span>
<span class="k">struct</span> <span class="n">rte_cryptodev_sym_session</span> <span class="o">*</span><span class="n">session</span><span class="p">;</span>
<span class="n">session</span> <span class="o">=</span> <span class="n">rte_cryptodev_sym_session_create</span><span class="p">(</span><span class="n">session_pool</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">session</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Session could not be created</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">rte_cryptodev_sym_session_init</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">cipher_xform</span><span class="p">,</span> <span class="n">session_priv_pool</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Session could not be initialized &quot;</span>
                <span class="s">&quot;for the crypto device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Get a burst of crypto operations. */</span>
<span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">*</span><span class="n">crypto_ops</span><span class="p">[</span><span class="n">BURST_SIZE</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rte_crypto_op_bulk_alloc</span><span class="p">(</span><span class="n">crypto_op_pool</span><span class="p">,</span>
                        <span class="n">RTE_CRYPTO_OP_TYPE_SYMMETRIC</span><span class="p">,</span>
                        <span class="n">crypto_ops</span><span class="p">,</span> <span class="n">BURST_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Not enough crypto operations available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Get a burst of mbufs. */</span>
<span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">mbufs</span><span class="p">[</span><span class="n">BURST_SIZE</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rte_pktmbuf_alloc_bulk</span><span class="p">(</span><span class="n">mbuf_pool</span><span class="p">,</span> <span class="n">mbufs</span><span class="p">,</span> <span class="n">BURST_SIZE</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Not enough mbufs available&quot;</span><span class="p">);</span>

<span class="cm">/* Initialize the mbufs and append them to the crypto operations. */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BURST_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rte_pktmbuf_append</span><span class="p">(</span><span class="n">mbufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">BUFFER_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Not enough room in the mbuf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">crypto_ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">m_src</span> <span class="o">=</span> <span class="n">mbufs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/* Set up the crypto operations. */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BURST_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">crypto_ops</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="cm">/* Modify bytes of the IV at the end of the crypto operation */</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">iv_ptr</span> <span class="o">=</span> <span class="n">rte_crypto_op_ctod_offset</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">,</span>
                                            <span class="n">IV_OFFSET</span><span class="p">);</span>

    <span class="n">generate_random_bytes</span><span class="p">(</span><span class="n">iv_ptr</span><span class="p">,</span> <span class="n">AES_CBC_IV_LENGTH</span><span class="p">);</span>

    <span class="n">op</span><span class="o">-&gt;</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">cipher</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">sym</span><span class="o">-&gt;</span><span class="n">cipher</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>

    <span class="cm">/* Attach the crypto session to the operation */</span>
    <span class="n">rte_crypto_op_attach_sym_session</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">session</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Enqueue the crypto operations in the crypto device. */</span>
<span class="kt">uint16_t</span> <span class="n">num_enqueued_ops</span> <span class="o">=</span> <span class="n">rte_cryptodev_enqueue_burst</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">crypto_ops</span><span class="p">,</span> <span class="n">BURST_SIZE</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Dequeue the crypto operations until all the operations</span>
<span class="cm"> * are processed in the crypto device.</span>
<span class="cm"> */</span>
<span class="kt">uint16_t</span> <span class="n">num_dequeued_ops</span><span class="p">,</span> <span class="n">total_num_dequeued_ops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">*</span><span class="n">dequeued_ops</span><span class="p">[</span><span class="n">BURST_SIZE</span><span class="p">];</span>
    <span class="n">num_dequeued_ops</span> <span class="o">=</span> <span class="n">rte_cryptodev_dequeue_burst</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                    <span class="n">dequeued_ops</span><span class="p">,</span> <span class="n">BURST_SIZE</span><span class="p">);</span>
    <span class="n">total_num_dequeued_ops</span> <span class="o">+=</span> <span class="n">num_dequeued_ops</span><span class="p">;</span>

    <span class="cm">/* Check if operation was processed successfully */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_dequeued_ops</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dequeued_ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">RTE_CRYPTO_OP_STATUS_SUCCESS</span><span class="p">)</span>
            <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
                    <span class="s">&quot;Some operations were not processed correctly&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">rte_mempool_put_bulk</span><span class="p">(</span><span class="n">crypto_op_pool</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">dequeued_ops</span><span class="p">,</span>
                                        <span class="n">num_dequeued_ops</span><span class="p">);</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">total_num_dequeued_ops</span> <span class="o">&lt;</span> <span class="n">num_enqueued_ops</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="asymmetric-cryptography">
<h2><span class="section-number">17.8. </span>Asymmetric Cryptography</h2>
<p>The cryptodev library currently provides support for the following asymmetric
Crypto operations; RSA, Modular exponentiation and inversion, Diffie-Hellman
public and/or private key generation and shared secret compute, DSA Signature
generation and verification.</p>
<div class="section" id="id1">
<h3><span class="section-number">17.8.1. </span>Session and Session Management</h3>
<p>Sessions are used in asymmetric cryptographic processing to store the immutable
data defined in asymmetric cryptographic transform which is further used in the
operation processing. Sessions typically stores information, such as, public
and private key information or domain params or prime modulus data i.e. immutable
across data sets. Crypto sessions cache this immutable data in a optimal way for the
underlying PMD and this allows further acceleration of the offload of Crypto workloads.</p>
<p>Like symmetric, the Crypto device framework provides APIs to allocate and initialize
asymmetric sessions for crypto devices, where sessions are mempool objects.
It is the applicationâ€™s responsibility to create and manage the session mempools.
Application using both symmetric and asymmetric sessions should allocate and maintain
different sessions pools for each type.</p>
<p>An application can use <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_get_asym_session_private_size()</span></code> to
get the private size of asymmetric session on a given crypto device. This
function would allow an application to calculate the max device asymmetric
session size of all crypto devices to create a single session mempool.
If instead an application creates multiple asymmetric session mempools,
the Crypto device framework also provides <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_asym_get_header_session_size()</span></code> to get
the size of an uninitialized session.</p>
<p>Once the session mempools have been created, <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_asym_session_create()</span></code>
is used to allocate an uninitialized asymmetric session from the given mempool.
The session then must be initialized using <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_asym_session_init()</span></code>
for each of the required crypto devices. An asymmetric transform chain
is used to specify the operation and its parameters. See the section below for
details on transforms.</p>
<p>When a session is no longer used, user must call <code class="docutils literal notranslate"><span class="pre">rte_cryptodev_asym_session_clear()</span></code>
for each of the crypto devices that are using the session, to free all driver
private asymmetric session data. Once this is done, session should be freed using
<code class="docutils literal notranslate"><span class="pre">rte_cryptodev_asym_session_free()</span></code> which returns them to their mempool.</p>
</div>
<div class="section" id="asymmetric-sessionless-support">
<h3><span class="section-number">17.8.2. </span>Asymmetric Sessionless Support</h3>
<p>Asymmetric crypto framework supports session-less operations as well.</p>
<p>Fields that should be set by user are:</p>
<p>Member xform of struct rte_crypto_asym_op should point to the user created rte_crypto_asym_xform.
Note that rte_crypto_asym_xform should be immutable for the lifetime of associated crypto_op.</p>
<p>Member sess_type of rte_crypto_op should also be set to RTE_CRYPTO_OP_SESSIONLESS.</p>
</div>
<div class="section" id="id2">
<h3><span class="section-number">17.8.3. </span>Transforms and Transform Chaining</h3>
<p>Asymmetric Crypto transforms (<code class="docutils literal notranslate"><span class="pre">rte_crypto_asym_xform</span></code>) are the mechanism used
to specify the details of the asymmetric Crypto operation. Next pointer within
xform allows transform to be chained together. Also it is important to note that
the order in which the transforms are passed indicates the order of the chaining. Allocation
of the xform structure is in the application domain. To allow future API extensions in a
backwardly compatible manner, e.g. addition of a new parameter, the application should
zero the full xform struct before populating it.</p>
<p>Not all asymmetric crypto xforms are supported for chaining. Currently supported
asymmetric crypto chaining is Diffie-Hellman private key generation followed by
public generation. Also, currently API does not support chaining of symmetric and
asymmetric crypto xforms.</p>
<p>Each xform defines specific asymmetric crypto algo. Currently supported are:
* RSA
* Modular operations (Exponentiation and Inverse)
* Diffie-Hellman
* DSA
* None - special case where PMD may support a passthrough mode. More for diagnostic purpose</p>
<p>See <em>DPDK API Reference</em> for details on each rte_crypto_xxx_xform struct</p>
</div>
<div class="section" id="asymmetric-operations">
<h3><span class="section-number">17.8.4. </span>Asymmetric Operations</h3>
<p>The asymmetric Crypto operation structure contains all the mutable data relating
to asymmetric cryptographic processing on an input data buffer. It uses either
RSA, Modular, Diffie-Hellman or DSA operations depending upon session it is attached
to.</p>
<p>Every operation must carry a valid session handle which further carries information
on xform or xform-chain to be performed on op. Every xform type defines its own set
of operational params in their respective rte_crypto_xxx_op_param struct. Depending
on xform information within session, PMD picks up and process respective op_param
struct.
Unlike symmetric, asymmetric operations do not use mbufs for input/output.
They operate on data buffer of type <code class="docutils literal notranslate"><span class="pre">rte_crypto_param</span></code>.</p>
<p>See <em>DPDK API Reference</em> for details on each rte_crypto_xxx_op_param struct</p>
</div>
</div>
<div class="section" id="asymmetric-crypto-sample-code">
<h2><span class="section-number">17.9. </span>Asymmetric crypto Sample code</h2>
<p>Thereâ€™s a unit test application test_cryptodev_asym.c inside unit test framework that
show how to setup and process asymmetric operations using cryptodev library.</p>
<p>The following sample code shows the basic steps to compute modular exponentiation
using 1024-bit modulus length using openssl PMD available in DPDK (performing other
crypto operations is similar except change to respective op and xform setup).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Simple example to compute modular exponentiation with 1024-bit key</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_ASYM_SESSIONS   10</span>
<span class="cp">#define NUM_ASYM_BUFS       10</span>

<span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">crypto_op_pool</span><span class="p">,</span> <span class="o">*</span><span class="n">asym_session_pool</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">asym_session_size</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="cm">/* Initialize EAL. */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eal_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Invalid EAL arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="kt">uint8_t</span> <span class="n">socket_id</span> <span class="o">=</span> <span class="n">rte_socket_id</span><span class="p">();</span>

<span class="cm">/* Create crypto operation pool. */</span>
<span class="n">crypto_op_pool</span> <span class="o">=</span> <span class="n">rte_crypto_op_pool_create</span><span class="p">(</span>
                                <span class="s">&quot;crypto_op_pool&quot;</span><span class="p">,</span>
                                <span class="n">RTE_CRYPTO_OP_TYPE_ASYMMETRIC</span><span class="p">,</span>
                                <span class="n">NUM_ASYM_BUFS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                <span class="n">socket_id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">crypto_op_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Cannot create crypto op pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Create the virtual crypto device. */</span>
<span class="kt">char</span> <span class="n">args</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">crypto_name</span> <span class="o">=</span> <span class="s">&quot;crypto_openssl&quot;</span><span class="p">;</span>
<span class="n">snprintf</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="s">&quot;socket_id=%d&quot;</span><span class="p">,</span> <span class="n">socket_id</span><span class="p">);</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_vdev_init</span><span class="p">(</span><span class="n">crypto_name</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Cannot create virtual device&quot;</span><span class="p">);</span>

<span class="kt">uint8_t</span> <span class="n">cdev_id</span> <span class="o">=</span> <span class="n">rte_cryptodev_get_dev_id</span><span class="p">(</span><span class="n">crypto_name</span><span class="p">);</span>

<span class="cm">/* Get private asym session data size. */</span>
<span class="n">asym_session_size</span> <span class="o">=</span> <span class="n">rte_cryptodev_get_asym_private_session_size</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Create session mempool, with two objects per session,</span>
<span class="cm"> * one for the session header and another one for the</span>
<span class="cm"> * private asym session data for the crypto device.</span>
<span class="cm"> */</span>
<span class="n">asym_session_pool</span> <span class="o">=</span> <span class="n">rte_mempool_create</span><span class="p">(</span><span class="s">&quot;asym_session_pool&quot;</span><span class="p">,</span>
                                <span class="n">MAX_ASYM_SESSIONS</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="n">asym_session_size</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                                <span class="nb">NULL</span><span class="p">,</span> <span class="n">socket_id</span><span class="p">,</span>
                                <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Configure the crypto device. */</span>
<span class="k">struct</span> <span class="n">rte_cryptodev_config</span> <span class="n">conf</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">nb_queue_pairs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">socket_id</span> <span class="o">=</span> <span class="n">socket_id</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">rte_cryptodev_qp_conf</span> <span class="n">qp_conf</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">nb_descriptors</span> <span class="o">=</span> <span class="mi">2048</span>
<span class="p">};</span>

<span class="k">if</span> <span class="p">(</span><span class="n">rte_cryptodev_configure</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Failed to configure cryptodev %u&quot;</span><span class="p">,</span> <span class="n">cdev_id</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">rte_cryptodev_queue_pair_setup</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qp_conf</span><span class="p">,</span>
                        <span class="n">socket_id</span><span class="p">,</span> <span class="n">asym_session_pool</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Failed to setup queue pair</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">rte_cryptodev_start</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Failed to start device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Setup crypto xform to do modular exponentiation with 1024 bit</span>
<span class="cm">     * length modulus</span>
<span class="cm">     */</span>
<span class="k">struct</span> <span class="n">rte_crypto_asym_xform</span> <span class="n">modex_xform</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
            <span class="p">.</span><span class="n">xform_type</span> <span class="o">=</span> <span class="n">RTE_CRYPTO_ASYM_XFORM_MODEX</span><span class="p">,</span>
            <span class="p">.</span><span class="n">modex</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="p">.</span><span class="n">modulus</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="p">.</span><span class="n">data</span> <span class="o">=</span>
                            <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span>
                            <span class="p">(</span><span class="s">&quot;</span><span class="se">\xb3\xa1\xaf\xb7\x13\x08\x00\x0a\x35\xdc\x2b\x20\x8d</span><span class="s">&quot;</span>
                            <span class="s">&quot;</span><span class="se">\xa1\xb5\xce\x47\x8a\xc3\x80\xf4\x7d\x4a\xa2\x62\xfd\x61\x7f</span><span class="s">&quot;</span>
                            <span class="s">&quot;</span><span class="se">\xb5\xa8\xde\x0a\x17\x97\xa0\xbf\xdf\x56\x5a\x3d\x51\x56\x4f</span><span class="s">&quot;</span>
                            <span class="s">&quot;</span><span class="se">\x70\x70\x3f\x63\x6a\x44\x5b\xad\x84\x0d\x3f\x27\x6e\x3b\x34</span><span class="s">&quot;</span>
                            <span class="s">&quot;</span><span class="se">\x91\x60\x14\xb9\xaa\x72\xfd\xa3\x64\xd2\x03\xa7\x53\x87\x9e</span><span class="s">&quot;</span>
                            <span class="s">&quot;</span><span class="se">\x88\x0b\xc1\x14\x93\x1a\x62\xff\xb1\x5d\x74\xcd\x59\x63\x18</span><span class="s">&quot;</span>
                            <span class="s">&quot;</span><span class="se">\x11\x3d\x4f\xba\x75\xd4\x33\x4e\x23\x6b\x7b\x57\x44\xe1\xd3</span><span class="s">&quot;</span>
                            <span class="s">&quot;</span><span class="se">\x03\x13\xa6\xf0\x8b\x60\xb0\x9e\xee\x75\x08\x9d\x71\x63\x13</span><span class="s">&quot;</span>
                            <span class="s">&quot;</span><span class="se">\xcb\xa6\x81\x92\x14\x03\x22\x2d\xde\x55</span><span class="s">&quot;</span><span class="p">),</span>
                            <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">128</span>
                    <span class="p">},</span>
                    <span class="p">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)(</span><span class="s">&quot;</span><span class="se">\x01\x00\x01</span><span class="s">&quot;</span><span class="p">),</span>
                            <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">3</span>
                    <span class="p">}</span>
            <span class="p">}</span>
<span class="p">};</span>
<span class="cm">/* Create asym crypto session and initialize it for the crypto device. */</span>
<span class="k">struct</span> <span class="n">rte_cryptodev_asym_session</span> <span class="o">*</span><span class="n">asym_session</span><span class="p">;</span>
<span class="n">asym_session</span> <span class="o">=</span> <span class="n">rte_cryptodev_asym_session_create</span><span class="p">(</span><span class="n">asym_session_pool</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">asym_session</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Session could not be created</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">rte_cryptodev_asym_session_init</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="n">asym_session</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">modex_xform</span><span class="p">,</span> <span class="n">asym_session_pool</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Session could not be initialized &quot;</span>
                <span class="s">&quot;for the crypto device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Get a burst of crypto operations. */</span>
<span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">*</span><span class="n">crypto_ops</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rte_crypto_op_bulk_alloc</span><span class="p">(</span><span class="n">crypto_op_pool</span><span class="p">,</span>
                        <span class="n">RTE_CRYPTO_OP_TYPE_ASYMMETRIC</span><span class="p">,</span>
                        <span class="n">crypto_ops</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Not enough crypto operations available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Set up the crypto operations. */</span>
<span class="k">struct</span> <span class="n">rte_crypto_asym_op</span> <span class="o">*</span><span class="n">asym_op</span> <span class="o">=</span> <span class="n">crypto_ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">asym</span><span class="p">;</span>

    <span class="cm">/* calculate mod exp of value 0xf8 */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">base</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0xF8</span><span class="p">};</span>
<span class="n">asym_op</span><span class="o">-&gt;</span><span class="n">modex</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
<span class="n">asym_op</span><span class="o">-&gt;</span><span class="n">modex</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
    <span class="n">asym_op</span><span class="o">-&gt;</span><span class="n">modex</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">iova</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>

<span class="cm">/* Attach the asym crypto session to the operation */</span>
<span class="n">rte_crypto_op_attach_asym_session</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">asym_session</span><span class="p">);</span>

<span class="cm">/* Enqueue the crypto operations in the crypto device. */</span>
<span class="kt">uint16_t</span> <span class="n">num_enqueued_ops</span> <span class="o">=</span> <span class="n">rte_cryptodev_enqueue_burst</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">crypto_ops</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Dequeue the crypto operations until all the operations</span>
<span class="cm"> * are processed in the crypto device.</span>
<span class="cm"> */</span>
<span class="kt">uint16_t</span> <span class="n">num_dequeued_ops</span><span class="p">,</span> <span class="n">total_num_dequeued_ops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_crypto_op</span> <span class="o">*</span><span class="n">dequeued_ops</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">num_dequeued_ops</span> <span class="o">=</span> <span class="n">rte_cryptodev_dequeue_burst</span><span class="p">(</span><span class="n">cdev_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                    <span class="n">dequeued_ops</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">total_num_dequeued_ops</span> <span class="o">+=</span> <span class="n">num_dequeued_ops</span><span class="p">;</span>

    <span class="cm">/* Check if operation was processed successfully */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dequeued_ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">RTE_CRYPTO_OP_STATUS_SUCCESS</span><span class="p">)</span>
            <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
                    <span class="s">&quot;Some operations were not processed correctly&quot;</span><span class="p">);</span>

<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">total_num_dequeued_ops</span> <span class="o">&lt;</span> <span class="n">num_enqueued_ops</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="asymmetric-crypto-device-api">
<h3><span class="section-number">17.9.1. </span>Asymmetric Crypto Device API</h3>
<p>The cryptodev Library API is described in the
<a class="reference external" href="https://doc.dpdk.org/api/">DPDK API Reference</a></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="compressdev.html" class="btn btn-neutral float-right" title="18. Compression Device Library" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="bbdev.html" class="btn btn-neutral float-left" title="16. Wireless Baseband Device Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>