

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>16. Wireless Baseband Device Library &mdash; Data Plane Development Kit 20.11.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="17. Cryptography Device Library" href="cryptodev_lib.html" />
    <link rel="prev" title="15. Traffic Management API" href="traffic_management.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Data Plane Development Kit
          

          
            
            <img src="../_static/DPDK_logo_vertical_rev_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                20.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_app_ug/index.html">Sample Applications User Guides</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programmer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html">2. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="env_abstraction_layer.html">3. Environment Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="service_cores.html">4. Service Cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="trace_lib.html">5. Trace Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rcu_lib.html">6. RCU Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ring_lib.html">7. Ring Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="stack_lib.html">8. Stack Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mempool_lib.html">9. Mempool Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mbuf_lib.html">10. Mbuf Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="poll_mode_drv.html">11. Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="rte_flow.html">12. Generic flow API (rte_flow)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switch_representation.html">13. Switch Representation within DPDK Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="traffic_metering_and_policing.html">14. Traffic Metering and Policing API</a></li>
<li class="toctree-l2"><a class="reference internal" href="traffic_management.html">15. Traffic Management API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">16. Wireless Baseband Device Library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-principles">16.1. Design Principles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-management">16.2. Device Management</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-creation">16.2.1. Device Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-identification">16.2.2. Device Identification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-configuration">16.2.3. Device Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#queues-configuration">16.2.4. Queues Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-queues-management">16.2.5. Device &amp; Queues Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logical-cores-memory-and-queues-relationships">16.2.6. Logical Cores, Memory and Queues Relationships</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#device-operation-capabilities">16.3. Device Operation Capabilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#capabilities-discovery">16.3.1. Capabilities Discovery</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#operation-processing">16.4. Operation Processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#enqueue-dequeue-burst-apis">16.4.1. Enqueue / Dequeue Burst APIs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operation-representation">16.4.2. Operation Representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#operation-management-and-allocation">16.4.3. Operation Management and Allocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bbdev-inbound-outbound-memory">16.4.4. BBDEV Inbound/Outbound Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bbdev-turbo-encode-operation">16.4.5. BBDEV Turbo Encode Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bbdev-turbo-decode-operation">16.4.6. BBDEV Turbo Decode Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bbdev-ldpc-encode-operation">16.4.7. BBDEV LDPC Encode Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bbdev-ldpc-decode-operation">16.4.8. BBDEV LDPC Decode Operation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sample-code">16.5. Sample code</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#bbdev-device-api">16.5.1. BBDEV Device API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cryptodev_lib.html">17. Cryptography Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="compressdev.html">18. Compression Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regexdev.html">19. RegEx Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rte_security.html">20. Security Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rawdev.html">21. Rawdevice Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="link_bonding_poll_mode_drv_lib.html">22. Link Bonding Poll Mode Driver Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer_lib.html">23. Timer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="hash_lib.html">24. Hash Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="efd_lib.html">25. Elastic Flow Distributor Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="member_lib.html">26. Membership Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm_lib.html">27. LPM Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm6_lib.html">28. LPM6 Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow_classify_lib.html">29. Flow Classification Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_distrib_lib.html">30. Packet Distributor Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="reorder_lib.html">31. Reorder Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_fragment_reassembly_lib.html">32. IP Fragmentation and Reassembly Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_receive_offload_lib.html">33. Generic Receive Offload Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_segmentation_offload_lib.html">34. Generic Segmentation Offload Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pdump_lib.html">35. The librte_pdump Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_proc_support.html">36. Multi-process Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel_nic_interface.html">37. Kernel NIC Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread_safety_dpdk_functions.html">38. Thread Safety of DPDK Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="eventdev.html">39. Event Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_ethernet_rx_adapter.html">40. Event Ethernet Rx Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_ethernet_tx_adapter.html">41. Event Ethernet Tx Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_timer_adapter.html">42. Event Timer Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_crypto_adapter.html">43. Event Crypto Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_framework.html">44. Quality of Service (QoS) Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_man.html">45. Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_classif_access_ctrl.html">46. Packet Classification and Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_framework.html">47. Packet Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost_lib.html">48. Vhost Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="metrics_lib.html">49. Metrics Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="telemetry_lib.html">50. Telemetry Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="bpf_lib.html">51. Berkeley Packet Filter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec_lib.html">52. IPsec Packet Processing Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_lib.html">53. Graph Library and Inbuilt Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_org.html">54. Source Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-sdk-meson.html">55. Installing DPDK Using the meson build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson_ut.html">56. Running DPDK Unit Tests with Meson</a></li>
<li class="toctree-l2"><a class="reference internal" href="build_app.html">57. Building Your Own Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="perf_opt_guidelines.html">58. Performance Optimization Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing_efficient_code.html">59. Writing Efficient Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="lto.html">60. Link Time Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile_app.html">61. Profile Your Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="glossary.html">62. Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor’s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Data Plane Development Kit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Programmer’s Guide</a> &raquo;</li>
        
      <li><span class="section-number">16. </span>Wireless Baseband Device Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/prog_guide/bbdev.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="wireless-baseband-device-library">
<h1><span class="section-number">16. </span>Wireless Baseband Device Library</h1>
<p>The Wireless Baseband library provides a common programming framework that
abstracts HW accelerators based on FPGA and/or Fixed Function Accelerators that
assist with 3GPP Physical Layer processing. Furthermore, it decouples the
application from the compute-intensive wireless functions by abstracting their
optimized libraries to appear as virtual bbdev devices.</p>
<p>The functional scope of the BBDEV library are those functions in relation to
the 3GPP Layer 1 signal processing (channel coding, modulation, …).</p>
<p>The framework currently only supports FEC function.</p>
<div class="section" id="design-principles">
<h2><span class="section-number">16.1. </span>Design Principles</h2>
<p>The Wireless Baseband library follows the same ideology of DPDK’s Ethernet
Device and Crypto Device frameworks. Wireless Baseband provides a generic
acceleration abstraction framework which supports both physical (hardware) and
virtual (software) wireless acceleration functions.</p>
</div>
<div class="section" id="device-management">
<h2><span class="section-number">16.2. </span>Device Management</h2>
<div class="section" id="device-creation">
<h3><span class="section-number">16.2.1. </span>Device Creation</h3>
<p>Physical bbdev devices are discovered during the PCI probe/enumeration of the
EAL function which is executed at DPDK initialization, based on
their PCI device identifier, each unique PCI BDF (bus/bridge, device,
function).</p>
<p>Virtual devices can be created by two mechanisms, either using the EAL command
line options or from within the application using an EAL API directly.</p>
<p>From the command line using the –vdev EAL option</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">--vdev &#39;baseband_turbo_sw,max_nb_queues=8,socket_id=0&#39;</span>
</pre></div>
</div>
<p>Or using the rte_vdev_init API within the application code.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">rte_vdev_init</span><span class="p">(</span><span class="s">&quot;baseband_turbo_sw&quot;</span><span class="p">,</span> <span class="s">&quot;max_nb_queues=2,socket_id=0&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>All virtual bbdev devices support the following initialization parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_nb_queues</span></code> - maximum number of queues supported by the device.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">socket_id</span></code> - socket on which to allocate the device resources on.</p></li>
</ul>
</div>
<div class="section" id="device-identification">
<h3><span class="section-number">16.2.2. </span>Device Identification</h3>
<p>Each device, whether virtual or physical is uniquely designated by two
identifiers:</p>
<ul class="simple">
<li><p>A unique device index used to designate the bbdev device in all functions
exported by the bbdev API.</p></li>
<li><p>A device name used to designate the bbdev device in console messages, for
administration or debugging purposes. For ease of use, the port name includes
the port index.</p></li>
</ul>
</div>
<div class="section" id="device-configuration">
<h3><span class="section-number">16.2.3. </span>Device Configuration</h3>
<p>From the application point of view, each instance of a bbdev device consists of
one or more queues identified by queue IDs. While different devices may have
different capabilities (e.g. support different operation types), all queues on
a device support identical configuration possibilities. A queue is configured
for only one type of operation and is configured at initialization time.
When an operation is enqueued to a specific queue ID, the result is dequeued
from the same queue ID.</p>
<p>Configuration of a device has two different levels: configuration that applies
to the whole device, and configuration that applies to a single queue.</p>
<p>Device configuration is applied with
<code class="docutils literal notranslate"><span class="pre">rte_bbdev_setup_queues(dev_id,num_queues,socket_id)</span></code>
and queue configuration is applied with
<code class="docutils literal notranslate"><span class="pre">rte_bbdev_queue_configure(dev_id,queue_id,conf)</span></code>. Note that, although all
queues on a device support same capabilities, they can be configured differently
and will then behave differently.
Devices supporting interrupts can enable them by using
<code class="docutils literal notranslate"><span class="pre">rte_bbdev_intr_enable(dev_id)</span></code>.</p>
<p>The configuration of each bbdev device includes the following operations:</p>
<ul class="simple">
<li><p>Allocation of resources, including hardware resources if a physical device.</p></li>
<li><p>Resetting the device into a well-known default state.</p></li>
<li><p>Initialization of statistics counters.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_bbdev_setup_queues</span></code> API is used to setup queues for a bbdev device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">rte_bbdev_setup_queues</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">num_queues</span><span class="p">,</span>
         <span class="kt">int</span> <span class="n">socket_id</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">num_queues</span></code> argument identifies the total number of queues to setup for
this device.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">socket_id</span></code> specifies which socket will be used to allocate the memory.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_bbdev_intr_enable</span></code> API is used to enable interrupts for a bbdev
device, if supported by the driver. Should be called before starting the device.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">rte_bbdev_intr_enable</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="queues-configuration">
<h3><span class="section-number">16.2.4. </span>Queues Configuration</h3>
<p>Each bbdev devices queue is individually configured through the
<code class="docutils literal notranslate"><span class="pre">rte_bbdev_queue_configure()</span></code> API.
Each queue resources may be allocated on a specified socket.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_queue_conf</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">socket</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">queue_size</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">priority</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">deferred_start</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">rte_bbdev_op_type</span> <span class="n">op_type</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="device-queues-management">
<h3><span class="section-number">16.2.5. </span>Device &amp; Queues Management</h3>
<p>After initialization, devices are in a stopped state, so must be started by the
application. If an application is finished using a device it can close the
device. Once closed, it cannot be restarted.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">rte_bbdev_start</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">rte_bbdev_stop</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">rte_bbdev_close</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">rte_bbdev_queue_start</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_id</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">rte_bbdev_queue_stop</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_id</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, all queues are started when the device is started, but they can be
stopped individually.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">rte_bbdev_queue_start</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_id</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">rte_bbdev_queue_stop</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_id</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="logical-cores-memory-and-queues-relationships">
<h3><span class="section-number">16.2.6. </span>Logical Cores, Memory and Queues Relationships</h3>
<p>The bbdev poll mode device driver library supports NUMA architecture, in which
a processor’s logical cores and interfaces utilize it’s local memory. Therefore
with baseband operations, the mbuf being operated on should be allocated from memory
pools created in the local memory. The buffers should, if possible, remain on
the local processor to obtain the best performance results and buffer
descriptors should be populated with mbufs allocated from a mempool allocated
from local memory.</p>
<p>The run-to-completion model also performs better, especially in the case of
virtual bbdev devices, if the baseband operation and data buffers are in local
memory instead of a remote processor’s memory. This is also true for the
pipe-line model provided all logical cores used are located on the same processor.</p>
<p>Multiple logical cores should never share the same queue for enqueuing
operations or dequeuing operations on the same bbdev device since this would
require global locks and hinder performance. It is however possible to use a
different logical core to dequeue an operation on a queue pair from the logical
core which it was enqueued on. This means that a baseband burst enqueue/dequeue
APIs are a logical place to transition from one logical core to another in a
packet processing pipeline.</p>
</div>
</div>
<div class="section" id="device-operation-capabilities">
<h2><span class="section-number">16.3. </span>Device Operation Capabilities</h2>
<p>Capabilities (in terms of operations supported, max number of queues, etc.)
identify what a bbdev is capable of performing that differs from one device to
another. For the full scope of the bbdev capability see the definition of the
structure in the <em>DPDK API Reference</em>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_op_cap</span><span class="p">;</span>
</pre></div>
</div>
<p>A device reports its capabilities when registering itself in the bbdev framework.
With the aid of this capabilities mechanism, an application can query devices to
discover which operations within the 3GPP physical layer they are capable of
performing. Below is an example of the capabilities for a PMD it supports in
relation to Turbo Encoding and Decoding operations.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rte_bbdev_op_cap</span> <span class="n">bbdev_capabilities</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">RTE_BBDEV_OP_TURBO_DEC</span><span class="p">,</span>
        <span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">turbo_dec</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">capability_flags</span> <span class="o">=</span>
                <span class="n">RTE_BBDEV_TURBO_SUBBLOCK_DEINTERLEAVE</span> <span class="o">|</span>
                <span class="n">RTE_BBDEV_TURBO_POS_LLR_1_BIT_IN</span> <span class="o">|</span>
                <span class="n">RTE_BBDEV_TURBO_NEG_LLR_1_BIT_IN</span> <span class="o">|</span>
                <span class="n">RTE_BBDEV_TURBO_CRC_TYPE_24B</span> <span class="o">|</span>
                <span class="n">RTE_BBDEV_TURBO_DEC_TB_CRC_24B_KEEP</span> <span class="o">|</span>
                <span class="n">RTE_BBDEV_TURBO_EARLY_TERMINATION</span><span class="p">,</span>
            <span class="p">.</span><span class="n">max_llr_modulus</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
            <span class="p">.</span><span class="n">num_buffers_src</span> <span class="o">=</span> <span class="n">RTE_BBDEV_TURBO_MAX_CODE_BLOCKS</span><span class="p">,</span>
            <span class="p">.</span><span class="n">num_buffers_hard_out</span> <span class="o">=</span>
                    <span class="n">RTE_BBDEV_TURBO_MAX_CODE_BLOCKS</span><span class="p">,</span>
            <span class="p">.</span><span class="n">num_buffers_soft_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="p">.</span><span class="n">type</span>   <span class="o">=</span> <span class="n">RTE_BBDEV_OP_TURBO_ENC</span><span class="p">,</span>
        <span class="p">.</span><span class="n">cap</span><span class="p">.</span><span class="n">turbo_enc</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">.</span><span class="n">capability_flags</span> <span class="o">=</span>
                    <span class="n">RTE_BBDEV_TURBO_CRC_24B_ATTACH</span> <span class="o">|</span>
                    <span class="n">RTE_BBDEV_TURBO_CRC_24A_ATTACH</span> <span class="o">|</span>
                    <span class="n">RTE_BBDEV_TURBO_RATE_MATCH</span> <span class="o">|</span>
                    <span class="n">RTE_BBDEV_TURBO_RV_INDEX_BYPASS</span><span class="p">,</span>
            <span class="p">.</span><span class="n">num_buffers_src</span> <span class="o">=</span> <span class="n">RTE_BBDEV_TURBO_MAX_CODE_BLOCKS</span><span class="p">,</span>
            <span class="p">.</span><span class="n">num_buffers_dst</span> <span class="o">=</span> <span class="n">RTE_BBDEV_TURBO_MAX_CODE_BLOCKS</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="n">RTE_BBDEV_END_OF_CAPABILITIES_LIST</span><span class="p">()</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="capabilities-discovery">
<h3><span class="section-number">16.3.1. </span>Capabilities Discovery</h3>
<p>Discovering the features and capabilities of a bbdev device poll mode driver
is achieved through the <code class="docutils literal notranslate"><span class="pre">rte_bbdev_info_get()</span></code> function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">rte_bbdev_info_get</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rte_bbdev_info</span> <span class="o">*</span><span class="n">dev_info</span><span class="p">)</span>
</pre></div>
</div>
<p>This allows the user to query a specific bbdev PMD and get all the device
capabilities. The <code class="docutils literal notranslate"><span class="pre">rte_bbdev_info</span></code> structure provides two levels of
information:</p>
<ul class="simple">
<li><p>Device relevant information, like: name and related rte_bus.</p></li>
<li><p>Driver specific information, as defined by the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">rte_bbdev_driver_info</span></code>
structure, this is where capabilities reside along with other specifics like:
maximum queue sizes and priority level.</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_info</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">socket_id</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">rte_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">num_queues</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">started</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_driver_info</span> <span class="n">drv</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="operation-processing">
<h2><span class="section-number">16.4. </span>Operation Processing</h2>
<p>Scheduling of baseband operations on DPDK’s application data path is
performed using a burst oriented asynchronous API set. A queue on a bbdev
device accepts a burst of baseband operations using enqueue burst API. On physical
bbdev devices the enqueue burst API will place the operations to be processed
on the device’s hardware input queue, for virtual devices the processing of the
baseband operations is usually completed during the enqueue call to the bbdev
device. The dequeue burst API will retrieve any processed operations available
from the queue on the bbdev device, from physical devices this is usually
directly from the device’s processed queue, and for virtual device’s from a
<code class="docutils literal notranslate"><span class="pre">rte_ring</span></code> where processed operations are placed after being processed on the
enqueue call.</p>
<div class="section" id="enqueue-dequeue-burst-apis">
<h3><span class="section-number">16.4.1. </span>Enqueue / Dequeue Burst APIs</h3>
<p>The burst enqueue API uses a bbdev device identifier and a queue
identifier to specify the bbdev device queue to schedule the processing on.
The <code class="docutils literal notranslate"><span class="pre">num_ops</span></code> parameter is the number of operations to process which are
supplied in the <code class="docutils literal notranslate"><span class="pre">ops</span></code> array of <code class="docutils literal notranslate"><span class="pre">rte_bbdev_*_op</span></code> structures.
The enqueue function returns the number of operations it actually enqueued for
processing, a return value equal to <code class="docutils literal notranslate"><span class="pre">num_ops</span></code> means that all packets have been
enqueued.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16_t</span> <span class="n">rte_bbdev_enqueue_enc_ops</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_id</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_enc_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">num_ops</span><span class="p">)</span>

<span class="kt">uint16_t</span> <span class="n">rte_bbdev_enqueue_dec_ops</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_id</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_dec_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">num_ops</span><span class="p">)</span>
</pre></div>
</div>
<p>The dequeue API uses the same format as the enqueue API of processed but
the <code class="docutils literal notranslate"><span class="pre">num_ops</span></code> and <code class="docutils literal notranslate"><span class="pre">ops</span></code> parameters are now used to specify the max processed
operations the user wishes to retrieve and the location in which to store them.
The API call returns the actual number of processed operations returned, this
can never be larger than <code class="docutils literal notranslate"><span class="pre">num_ops</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16_t</span> <span class="n">rte_bbdev_dequeue_enc_ops</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_id</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_enc_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">num_ops</span><span class="p">)</span>

<span class="kt">uint16_t</span> <span class="n">rte_bbdev_dequeue_dec_ops</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">dev_id</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">queue_id</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_dec_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">num_ops</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="operation-representation">
<h3><span class="section-number">16.4.2. </span>Operation Representation</h3>
<p>An encode bbdev operation is represented by <code class="docutils literal notranslate"><span class="pre">rte_bbdev_enc_op</span></code> structure,
and by <code class="docutils literal notranslate"><span class="pre">rte_bbdev_dec_op</span></code> for decode. These structures act as metadata
containers for all necessary information required for the bbdev operation to be
processed on a particular bbdev device poll mode driver.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_enc_op</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mempool</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_turbo_enc</span> <span class="n">turbo_enc</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_ldpc_enc</span> <span class="n">ldpc_enc</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rte_bbdev_dec_op</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mempool</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">opaque_data</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_turbo_dec</span> <span class="n">turbo_enc</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_ldpc_dec</span> <span class="n">ldpc_enc</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The operation structure by itself defines the operation type. It includes an
operation status, a reference to the operation specific data, which can vary in
size and content depending on the operation being provisioned. It also contains
the source mempool for the operation, if it is allocated from a mempool.</p>
<p>If bbdev operations are allocated from a bbdev operation mempool, see next
section, there is also the ability to allocate private memory with the
operation for applications purposes.</p>
<p>Application software is responsible for specifying all the operation specific
fields in the <code class="docutils literal notranslate"><span class="pre">rte_bbdev_*_op</span></code> structure which are then used by the bbdev PMD
to process the requested operation.</p>
</div>
<div class="section" id="operation-management-and-allocation">
<h3><span class="section-number">16.4.3. </span>Operation Management and Allocation</h3>
<p>The bbdev library provides an API set for managing bbdev operations which
utilize the Mempool Library to allocate operation buffers. Therefore, it ensures
that the bbdev operation is interleaved optimally across the channels and
ranks for optimal processing.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span>
<span class="n">rte_bbdev_op_pool_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">enum</span> <span class="n">rte_bbdev_op_type</span> <span class="n">type</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_elements</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cache_size</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">socket_id</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">rte_bbdev_*_op_alloc_bulk()</span></code> and <code class="docutils literal notranslate"><span class="pre">rte_bbdev_*_op_free_bulk()</span></code> are used to
allocate bbdev operations of a specific type from a given bbdev operation mempool.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">rte_bbdev_enc_op_alloc_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mempool</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_enc_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">num_ops</span><span class="p">)</span>

<span class="kt">int</span> <span class="n">rte_bbdev_dec_op_alloc_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mempool</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_dec_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">num_ops</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">rte_bbdev_*_op_free_bulk()</span></code> is called by the application to return an
operation to its allocating pool.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">rte_bbdev_dec_op_free_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_bbdev_dec_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_ops</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">rte_bbdev_enc_op_free_bulk</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_bbdev_enc_op</span> <span class="o">**</span><span class="n">ops</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_ops</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="bbdev-inbound-outbound-memory">
<h3><span class="section-number">16.4.4. </span>BBDEV Inbound/Outbound Memory</h3>
<p>The bbdev operation structure contains all the mutable data relating to
performing Turbo and LDPC coding on a referenced mbuf data buffer. It is used for either
encode or decode operations.</p>
<table class="colwidths-given docutils align-default" id="id1">
<caption><span class="caption-number">Table 16.1 </span><span class="caption-text">Operation I/O</span></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 38%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>FEC</p></th>
<th class="head"><p>In</p></th>
<th class="head"><p>Out</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Turbo Encode</p></td>
<td><p>input</p></td>
<td><p>output</p></td>
</tr>
<tr class="row-odd"><td><p>Turbo Decode</p></td>
<td><p>input</p></td>
<td><p>hard output</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>soft output (optional)</p></td>
</tr>
<tr class="row-odd"><td><p>LDPC Encode</p></td>
<td><p>input</p></td>
<td><p>output</p></td>
</tr>
<tr class="row-even"><td><p>LDPC Decode</p></td>
<td><p>input</p></td>
<td><p>hard output</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>HQ combine (optional)</p></td>
<td><p>HQ combine (optional)</p></td>
</tr>
<tr class="row-even"><td></td>
<td></td>
<td><p>soft output (optional)</p></td>
</tr>
</tbody>
</table>
<p>It is expected that the application provides input and output mbuf pointers
allocated and ready to use.</p>
<p>The baseband framework supports FEC coding on Code Blocks (CB) and
Transport Blocks (TB).</p>
<p>For the output buffer(s), the application is required to provide an allocated
and free mbuf, to which the resulting output will be written.</p>
<p>The support of split “scattered” buffers is a driver-specific feature, so it is
reported individually by the supporting driver as a capability.</p>
<p>Input and output data buffers are identified by <code class="docutils literal notranslate"><span class="pre">rte_bbdev_op_data</span></code> structure,
as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This structure has three elements:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: This is the mbuf data structure representing the data for BBDEV
operation.</p>
<p>This mbuf pointer can point to one Code Block (CB) data buffer or multiple CBs
contiguously located next to each other. A Transport Block (TB) represents a
whole piece of data that is divided into one or more CBs. Maximum number of
CBs can be contained in one TB is defined by
<code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_(TURBO/LDPC)MAX_CODE_BLOCKS</span></code>.</p>
<p>An mbuf data structure cannot represent more than one TB. The smallest piece
of data that can be contained in one mbuf is one CB.
An mbuf can include one contiguous CB, subset of contiguous CBs that are
belonging to one TB, or all contiguous CBs that belong to one TB.</p>
<p>If a BBDEV PMD supports the extended capability “Scatter-Gather”, then it is
capable of collecting (gathering) non-contiguous (scattered) data from
multiple locations in the memory.
This capability is reported by the capability flags:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_TURBO_ENC_SCATTER_GATHER</span></code>, <code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_TURBO_DEC_SCATTER_GATHER</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_LDPC_ENC_SCATTER_GATHER</span></code>, <code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_LDPC_DEC_SCATTER_GATHER</span></code>.</p></li>
</ul>
<p>Chained mbuf data structures are only accepted if a BBDEV PMD supports this
feature. A chained mbuf can represent one non-contiguous CB or multiple non-contiguous
CBs. The first mbuf segment in the given chained mbuf represents the first piece
of the CB. Offset is only applicable to the first segment. <code class="docutils literal notranslate"><span class="pre">length</span></code> is the
total length of the CB.</p>
<p>BBDEV driver is responsible for identifying where the split is and enqueue
the split data to its internal queues.</p>
<p>If BBDEV PMD does not support this feature, it will assume inbound mbuf data
contains one segment.</p>
<p>The output mbuf data though is always one segment, even if the input was a
chained mbuf.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">offset</span></code>: This is the starting point of the BBDEV (encode/decode) operation,
in bytes.</p>
<p>BBDEV starts to read data past this offset.
In case of chained mbuf, this offset applies only to the first mbuf segment.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code>: This is the total data length to be processed in one operation,
in bytes.</p>
<p>In case the mbuf data is representing one CB, this is the length of the CB
undergoing the operation.
If it is for multiple CBs, this is the total length of those CBs undergoing
the operation.
If it is for one TB, this is the total length of the TB under operation.
In case of chained mbuf, this data length includes the lengths of the
“scattered” data segments undergoing the operation.</p>
</li>
</ul>
</div>
<div class="section" id="bbdev-turbo-encode-operation">
<h3><span class="section-number">16.4.5. </span>BBDEV Turbo Encode Operation</h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_op_turbo_enc</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">output</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">op_flags</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rv_index</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">code_block_mode</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_enc_cb_params</span> <span class="n">cb_params</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_enc_tb_params</span> <span class="n">tb_params</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The Turbo encode structure includes the <code class="docutils literal notranslate"><span class="pre">input</span></code> and <code class="docutils literal notranslate"><span class="pre">output</span></code> mbuf
data pointers. The provided mbuf pointer of <code class="docutils literal notranslate"><span class="pre">input</span></code> needs to be big
enough to stretch for extra CRC trailers.</p>
<table class="colwidths-given docutils align-default" id="id2">
<caption><span class="caption-number">Table 16.2 </span><span class="caption-text"><strong>struct rte_bbdev_op_turbo_enc</strong> parameters</span></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>input</p></td>
<td><p>input CB or TB data</p></td>
</tr>
<tr class="row-odd"><td><p>output</p></td>
<td><p>rate matched CB or TB output buffer</p></td>
</tr>
<tr class="row-even"><td><p>op_flags</p></td>
<td><p>bitmask of all active operation capabilities</p></td>
</tr>
<tr class="row-odd"><td><p>rv_index</p></td>
<td><p>redundancy version index [0..3]</p></td>
</tr>
<tr class="row-even"><td><p>code_block_mode</p></td>
<td><p>code block or transport block mode</p></td>
</tr>
<tr class="row-odd"><td><p>cb_params</p></td>
<td><p>code block specific parameters (code block mode only)</p></td>
</tr>
<tr class="row-even"><td><p>tb_params</p></td>
<td><p>transport block specific parameters (transport block mode only)</p></td>
</tr>
</tbody>
</table>
<p>The encode interface works on both the code block (CB) and the transport block
(TB). An operation executes in “CB-mode” when the CB is standalone. While
“TB-mode” executes when an operation performs on one or multiple CBs that
belong to a TB. Therefore, a given data can be standalone CB, full-size TB or
partial TB. Partial TB means that only a subset of CBs belonging to a bigger TB
are being enqueued.</p>
<blockquote>
<div><p><strong>NOTE:</strong> It is assumed that all enqueued ops in one <code class="docutils literal notranslate"><span class="pre">rte_bbdev_enqueue_enc_ops()</span></code>
call belong to one mode, either CB-mode or TB-mode.</p>
</div></blockquote>
<p>In case that the TB is smaller than Z (6144 bits), then effectively the TB = CB.
CRC24A is appended to the tail of the CB. The application is responsible for
calculating and appending CRC24A before calling BBDEV in case that the
underlying driver does not support CRC24A generation.</p>
<p>In CB-mode, CRC24A/B is an optional operation.
The CB parameter <code class="docutils literal notranslate"><span class="pre">k</span></code> is the size of the CB (this maps to K as described
in 3GPP TS 36.212 section 5.1.2), this size is inclusive of CRC24A/B.
The <code class="docutils literal notranslate"><span class="pre">length</span></code> is inclusive of CRC24A/B and equals to <code class="docutils literal notranslate"><span class="pre">k</span></code> in this case.</p>
<p>Not all BBDEV PMDs are capable of CRC24A/B calculation. Flags
<code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_TURBO_CRC_24A_ATTACH</span></code> and <code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_TURBO_CRC_24B_ATTACH</span></code>
informs the application with relevant capability. These flags can be set in the
<code class="docutils literal notranslate"><span class="pre">op_flags</span></code> parameter to indicate to BBDEV to calculate and append CRC24A/B
to CB before going forward with Turbo encoding.</p>
<p>Output format of the CB encode will have the encoded CB in <code class="docutils literal notranslate"><span class="pre">e</span></code> size output
(this maps to E described in 3GPP TS 36.212 section 5.1.4.1.2). The output mbuf
buffer size needs to be big enough to hold the encoded buffer of size <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<p>In TB-mode, CRC24A is assumed to be pre-calculated and appended to the inbound
TB mbuf data buffer.
The output mbuf data structure is expected to be allocated by the application
with enough room for the output data.</p>
<p>The difference between the partial and full-size TB is that we need to know the
index of the first CB in this group and the number of CBs contained within.
The first CB index is given by <code class="docutils literal notranslate"><span class="pre">r</span></code> but the number of the remaining CBs is
calculated automatically by BBDEV before passing down to the driver.</p>
<p>The number of remaining CBs should not be confused with <code class="docutils literal notranslate"><span class="pre">c</span></code>. <code class="docutils literal notranslate"><span class="pre">c</span></code> is the
total number of CBs that composes the whole TB (this maps to C as
described in 3GPP TS 36.212 section 5.1.2).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">length</span></code> is total size of the CBs inclusive of any CRC24A and CRC24B in
case they were appended by the application.</p>
<p>The case when one CB belongs to TB and is being enqueued individually to BBDEV,
this case is considered as a special case of partial TB where its number of CBs
is 1. Therefore, it requires to get processed in TB-mode.</p>
<p>The figure below visualizes the encoding of CBs using BBDEV interface in
TB-mode. CB-mode is a reduced version, where only one CB exists:</p>
<div class="figure align-default" id="id3">
<span id="figure-turbo-tb-encode"></span><img alt="../_images/turbo_tb_encode.svg" src="../_images/turbo_tb_encode.svg" /><p class="caption"><span class="caption-number">Fig. 16.2 </span><span class="caption-text">Turbo encoding of Code Blocks in mbuf structure</span></p>
</div>
</div>
<div class="section" id="bbdev-turbo-decode-operation">
<h3><span class="section-number">16.4.6. </span>BBDEV Turbo Decode Operation</h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_op_turbo_dec</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">hard_output</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">soft_output</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">op_flags</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rv_index</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="nl">iter_min</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="nl">iter_max</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">iter_count</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">ext_scale</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">num_maps</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">code_block_mode</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_dec_cb_params</span> <span class="n">cb_params</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_dec_tb_params</span> <span class="n">tb_params</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The Turbo decode structure includes the <code class="docutils literal notranslate"><span class="pre">input</span></code>, <code class="docutils literal notranslate"><span class="pre">hard_output</span></code> and
optionally the <code class="docutils literal notranslate"><span class="pre">soft_output</span></code> mbuf data pointers.</p>
<table class="colwidths-given docutils align-default" id="id4">
<caption><span class="caption-number">Table 16.3 </span><span class="caption-text"><strong>struct rte_bbdev_op_turbo_dec</strong> parameters</span></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>input</p></td>
<td><p>virtual circular buffer, wk, size 3*Kpi for each CB</p></td>
</tr>
<tr class="row-odd"><td><p>hard output</p></td>
<td><p>hard decisions buffer, decoded output, size K for each CB</p></td>
</tr>
<tr class="row-even"><td><p>soft output</p></td>
<td><p>soft LLR output buffer (optional)</p></td>
</tr>
<tr class="row-odd"><td><p>op_flags</p></td>
<td><p>bitmask of all active operation capabilities</p></td>
</tr>
<tr class="row-even"><td><p>rv_index</p></td>
<td><p>redundancy version index [0..3]</p></td>
</tr>
<tr class="row-odd"><td><p>iter_max</p></td>
<td><p>maximum number of iterations to perofrm in decode all CBs</p></td>
</tr>
<tr class="row-even"><td><p>iter_min</p></td>
<td><p>minimum number of iterations to perform in decoding all CBs</p></td>
</tr>
<tr class="row-odd"><td><p>iter_count</p></td>
<td><p>number of iterations to performed in decoding all CBs</p></td>
</tr>
<tr class="row-even"><td><p>ext_scale</p></td>
<td><p>scale factor on extrinsic info (5 bits)</p></td>
</tr>
<tr class="row-odd"><td><p>num_maps</p></td>
<td><p>number of MAP engines to use in decode</p></td>
</tr>
<tr class="row-even"><td><p>code_block_mode</p></td>
<td><p>code block or transport block mode</p></td>
</tr>
<tr class="row-odd"><td><p>cb_params</p></td>
<td><p>code block specific parameters (code block mode only)</p></td>
</tr>
<tr class="row-even"><td><p>tb_params</p></td>
<td><p>transport block specific parameters (transport block mode only)</p></td>
</tr>
</tbody>
</table>
<p>Similarly, the decode interface works on both the code block (CB) and the
transport block (TB). An operation executes in “CB-mode” when the CB is
standalone. While “TB-mode” executes when an operation performs on one or
multiple CBs that belong to a TB. Therefore, a given data can be standalone CB,
full-size TB or partial TB. Partial TB means that only a subset of CBs belonging
to a bigger TB are being enqueued.</p>
<blockquote>
<div><p><strong>NOTE:</strong> It is assumed that all enqueued ops in one <code class="docutils literal notranslate"><span class="pre">rte_bbdev_enqueue_dec_ops()</span></code>
call belong to one mode, either CB-mode or TB-mode.</p>
</div></blockquote>
<p>The CB parameter <code class="docutils literal notranslate"><span class="pre">k</span></code> is the size of the decoded CB (this maps to K as described in
3GPP TS 36.212 section 5.1.2), this size is inclusive of CRC24A/B.
The <code class="docutils literal notranslate"><span class="pre">length</span></code> is inclusive of CRC24A/B and equals to <code class="docutils literal notranslate"><span class="pre">k</span></code> in this case.</p>
<p>The input encoded CB data is the Virtual Circular Buffer data stream, wk, with
the null padding included as described in 3GPP TS 36.212 section 5.1.4.1.2 and
shown in 3GPP TS 36.212 section 5.1.4.1 Figure 5.1.4-1.
The size of the virtual circular buffer is 3*Kpi, where Kpi is the 32 byte
aligned value of K, as specified in 3GPP TS 36.212 section 5.1.4.1.1.</p>
<p>Each byte in the input circular buffer is the LLR value of each bit of the
original CB.</p>
<p><code class="docutils literal notranslate"><span class="pre">hard_output</span></code> is a mandatory capability that all BBDEV PMDs support. This is
the decoded CBs of K sizes (CRC24A/B is the last 24-bit in each decoded CB).
Soft output is an optional capability for BBDEV PMDs. Setting flag
<code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_TURBO_DEC_TB_CRC_24B_KEEP</span></code> in <code class="docutils literal notranslate"><span class="pre">op_flags</span></code> directs BBDEV to retain
CRC24B at the end of each CB. This might be useful for the application in debug
mode.
An LLR rate matched output is computed in the <code class="docutils literal notranslate"><span class="pre">soft_output</span></code> buffer structure
for the given CB parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> size (this maps to E described in
3GPP TS 36.212 section 5.1.4.1.2). The output mbuf buffer size needs to be big
enough to hold the encoded buffer of size <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<p>The first CB Virtual Circular Buffer (VCB) index is given by <code class="docutils literal notranslate"><span class="pre">r</span></code> but the
number of the remaining CB VCBs is calculated automatically by BBDEV before
passing down to the driver.</p>
<p>The number of remaining CB VCBs should not be confused with <code class="docutils literal notranslate"><span class="pre">c</span></code>. <code class="docutils literal notranslate"><span class="pre">c</span></code> is the
total number of CBs that composes the whole TB (this maps to C as
described in 3GPP TS 36.212 section 5.1.2).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">length</span></code> is total size of the CBs inclusive of any CRC24A and CRC24B in
case they were appended by the application.</p>
<p>The case when one CB belongs to TB and is being enqueued individually to BBDEV,
this case is considered as a special case of partial TB where its number of CBs
is 1. Therefore, it requires to get processed in TB-mode.</p>
<p>The output mbuf data structure is expected to be allocated by the application
with enough room for the output data.</p>
<p>The figure below visualizes the decoding of CBs using BBDEV interface in
TB-mode. CB-mode is a reduced version, where only one CB exists:</p>
<div class="figure align-default" id="id5">
<span id="figure-turbo-tb-decode"></span><img alt="../_images/turbo_tb_decode.svg" src="../_images/turbo_tb_decode.svg" /><p class="caption"><span class="caption-number">Fig. 16.3 </span><span class="caption-text">Turbo decoding of Code Blocks in mbuf structure</span></p>
</div>
</div>
<div class="section" id="bbdev-ldpc-encode-operation">
<h3><span class="section-number">16.4.7. </span>BBDEV LDPC Encode Operation</h3>
<p>The operation flags that can be set for each LDPC encode operation are
given below.</p>
<blockquote>
<div><p><strong>NOTE:</strong> The actual operation flags that may be used with a specific
BBDEV PMD are dependent on the driver capabilities as reported via
<code class="docutils literal notranslate"><span class="pre">rte_bbdev_info_get()</span></code>, and may be a subset of those below.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Description of LDPC encode capability flags</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_INTERLEAVER_BYPASS</dt><dd><p>Set to bypass bit-level interleaver on output stream</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_RATE_MATCH</dt><dd><p>Set to enabling the RATE_MATCHING processing</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_CRC_24A_ATTACH</dt><dd><p>Set to attach transport block CRC-24A</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_CRC_24B_ATTACH</dt><dd><p>Set to attach code block CRC-24B</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_CRC_16_ATTACH</dt><dd><p>Set to attach code block CRC-16</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_ENC_INTERRUPTS</dt><dd><p>Set if a device supports encoder dequeue interrupts</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_ENC_SCATTER_GATHER</dt><dd><p>Set if a device supports scatter-gather functionality</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_ENC_CONCATENATION</dt><dd><p>Set if a device supports concatenation of non byte aligned output</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>The structure passed for each LDPC encode operation is given below,
with the operation flags forming a bitmask in the <code class="docutils literal notranslate"><span class="pre">op_flags</span></code> field.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_op_ldpc_enc</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">output</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">op_flags</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rv_index</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">basegraph</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">z_c</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">n_cb</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">q_m</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">n_filler</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">code_block_mode</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_enc_ldpc_cb_params</span> <span class="n">cb_params</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_enc_ldpc_tb_params</span> <span class="n">tb_params</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The LDPC encode parameters are set out in the table below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head" colspan="2"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>input</p></td>
<td colspan="2"><p>input CB or TB data</p></td>
</tr>
<tr class="row-odd"><td><p>output</p></td>
<td colspan="2"><p>rate matched CB or TB output buffer</p></td>
</tr>
<tr class="row-even"><td><p>op_flags</p></td>
<td colspan="2"><p>bitmask of all active operation capabilities</p></td>
</tr>
<tr class="row-odd"><td><p>rv_index</p></td>
<td colspan="2"><p>redundancy version index [0..3]</p></td>
</tr>
<tr class="row-even"><td><p>basegraph</p></td>
<td colspan="2"><p>Basegraph 1 or 2</p></td>
</tr>
<tr class="row-odd"><td><p>z_c</p></td>
<td colspan="2"><p>Zc, LDPC lifting size</p></td>
</tr>
<tr class="row-even"><td><p>n_cb</p></td>
<td colspan="2"><p>Ncb, length of the circular buffer in bits.</p></td>
</tr>
<tr class="row-odd"><td><p>q_m</p></td>
<td colspan="2"><p>Qm, modulation order {2,4,6,8,10}</p></td>
</tr>
<tr class="row-even"><td><p>n_filler</p></td>
<td colspan="2"><p>number of filler bits</p></td>
</tr>
<tr class="row-odd"><td><p>code_block_mode</p></td>
<td colspan="2"><p>code block or transport block mode</p></td>
</tr>
<tr class="row-even"><td><p>op_flags</p></td>
<td colspan="2"><p>bitmask of all active operation capabilities</p></td>
</tr>
<tr class="row-odd"><td><p><strong>cb_params</strong></p></td>
<td colspan="2"><p>code block specific parameters (code block mode only)</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>e</p></td>
<td><p>E, length of the rate matched output sequence in bits</p></td>
</tr>
<tr class="row-odd"><td><p><strong>tb_params</strong></p></td>
<td colspan="2"><p>transport block specific parameters (transport block mode only)</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>c</p></td>
<td><p>number of CBs in the TB or partial TB</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>r</p></td>
<td><p>index of the first CB in the inbound mbuf data</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>c_ab</p></td>
<td><p>number of CBs that use Ea before switching to Eb</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>ea</p></td>
<td><p>Ea, length of the RM output sequence in bits, r &lt; cab</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>eb</p></td>
<td><p>Eb, length of the RM output sequence in bits, r &gt;= cab</p></td>
</tr>
</tbody>
</table>
<p>The mbuf input <code class="docutils literal notranslate"><span class="pre">input</span></code> is mandatory for all BBDEV PMDs and is the
incoming code block or transport block data.</p>
<p>The mbuf output <code class="docutils literal notranslate"><span class="pre">output</span></code> is mandatory and is the encoded CB(s). In
CB-mode ut contains the encoded CB of size <code class="docutils literal notranslate"><span class="pre">e</span></code> (E  in 3GPP TS 38.212
section 6.2.5). In TB-mode it contains multiple contiguous encoded CBs
of size <code class="docutils literal notranslate"><span class="pre">ea</span></code> or <code class="docutils literal notranslate"><span class="pre">eb</span></code>.
The <code class="docutils literal notranslate"><span class="pre">output</span></code> buffer is allocated by the application with enough room
for the output data.</p>
<p>The encode interface works on both a code block (CB) and a transport
block (TB) basis.</p>
<blockquote>
<div><p><strong>NOTE:</strong> All enqueued ops in one <code class="docutils literal notranslate"><span class="pre">rte_bbdev_enqueue_enc_ops()</span></code>
call belong to one mode, either CB-mode or TB-mode.</p>
</div></blockquote>
<p>The valid modes of operation are:</p>
<ul class="simple">
<li><p>CB-mode: one CB (attach CRC24B if required)</p></li>
<li><p>CB-mode: one CB making up one TB (attach CRC24A if required)</p></li>
<li><p>TB-mode: one or more CB of a partial TB (attach CRC24B(s) if required)</p></li>
<li><p>TB-mode: one or more CB of a complete TB (attach CRC24AB(s) if required)</p></li>
</ul>
<p>In CB-mode if <code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_LDPC_CRC_24A_ATTACH</span></code> is set then CRC24A
is appended to the CB. If <code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_LDPC_CRC_24A_ATTACH</span></code> is not
set the application is responsible for calculating and appending CRC24A
before calling BBDEV. The input data mbuf <code class="docutils literal notranslate"><span class="pre">length</span></code> is inclusive of
CRC24A/B where present and is equal to the code block size <code class="docutils literal notranslate"><span class="pre">K</span></code>.</p>
<p>In TB-mode, CRC24A is assumed to be pre-calculated and appended to the
inbound TB data buffer, unless the <code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_LDPC_CRC_24A_ATTACH</span></code>
flag is set when it is the  responsibility of BBDEV. The input data
mbuf <code class="docutils literal notranslate"><span class="pre">length</span></code> is total size of the CBs inclusive of any CRC24A and
CRC24B in the case they were appended by the application.</p>
<p>Not all BBDEV PMDs may be capable of CRC24A/B calculation. Flags
<code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_LDPC_CRC_24A_ATTACH</span></code> and <code class="docutils literal notranslate"><span class="pre">RTE_BBDEV_LDPC_CRC_24B_ATTACH</span></code>
inform the application of the relevant capability. These flags can be set
in the <code class="docutils literal notranslate"><span class="pre">op_flags</span></code> parameter to indicate BBDEV to calculate and append
CRC24A to CB before going forward with LDPC encoding.</p>
<p>The difference between the partial and full-size TB is that BBDEV needs
the index of the first CB in this group and the number of CBs in the group.
The first CB index is given by <code class="docutils literal notranslate"><span class="pre">r</span></code> but the number of the CBs is
calculated by BBDEV before signalling to the driver.</p>
<p>The number of CBs in the group should not be confused with <code class="docutils literal notranslate"><span class="pre">c</span></code>, the
total number of CBs in the full TB (<code class="docutils literal notranslate"><span class="pre">C</span></code> as per 3GPP TS 38.212 section 5.2.2)</p>
<p>Figure <a class="reference internal" href="#figure-turbo-tb-encode"><span class="std std-numref">Fig. 16.2</span></a> above
showing the Turbo encoding of CBs using BBDEV interface in TB-mode
is also valid for LDPC encode.</p>
</div>
<div class="section" id="bbdev-ldpc-decode-operation">
<h3><span class="section-number">16.4.8. </span>BBDEV LDPC Decode Operation</h3>
<p>The operation flags that can be set for each LDPC decode operation are
given below.</p>
<blockquote>
<div><p><strong>NOTE:</strong> The actual operation flags that may be used with a specific
BBDEV PMD are dependent on the driver capabilities as reported via
<code class="docutils literal notranslate"><span class="pre">rte_bbdev_info_get()</span></code>, and may be a subset of those below.</p>
</div></blockquote>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Description of LDPC decode capability flags</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_CRC_TYPE_24A_CHECK</dt><dd><p>Set for transport block CRC-24A checking</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_CRC_TYPE_24B_CHECK</dt><dd><p>Set for code block CRC-24B checking</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_CRC_TYPE_24B_DROP</dt><dd><p>Set to drop the last CRC bits decoding output</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_DEINTERLEAVER_BYPASS</dt><dd><p>Set for bit-level de-interleaver bypass on input stream</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_HQ_COMBINE_IN_ENABLE</dt><dd><p>Set for HARQ combined input stream enable</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_HQ_COMBINE_OUT_ENABLE</dt><dd><p>Set for HARQ combined output stream enable</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl>
<dt>RTE_BBDEV_LDPC_DECODE_BYPASS</dt><dd><p>Set for LDPC decoder bypass</p>
<p>RTE_BBDEV_LDPC_HQ_COMBINE_OUT_ENABLE must be set</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_DECODE_SOFT_OUT</dt><dd><p>Set for soft-output stream  enable</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_SOFT_OUT_RM_BYPASS</dt><dd><p>Set for Rate-Matching bypass on soft-out stream</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_SOFT_OUT_DEINTERLEAVER_BYPASS</dt><dd><p>Set for bit-level de-interleaver bypass on soft-output stream</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl>
<dt>RTE_BBDEV_LDPC_ITERATION_STOP_ENABLE</dt><dd><p>Set for iteration stopping on successful decode condition enable</p>
<p>Where a successful decode is a successful syndrome check</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_DEC_INTERRUPTS</dt><dd><p>Set if a device supports decoder dequeue interrupts</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_DEC_SCATTER_GATHER</dt><dd><p>Set if a device supports scatter-gather functionality</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_HARQ_6BIT_COMPRESSION</dt><dd><p>Set if a device supports input/output HARQ compression
Data is packed as 6 bits by dropping and saturating the MSBs</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_LLR_COMPRESSION</dt><dd><p>Set if a device supports input LLR compression
Data is packed as 6 bits by dropping and saturating the MSBs</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_IN_ENABLE</dt><dd><p>Set if a device supports HARQ input to device’s internal memory</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_OUT_ENABLE</dt><dd><p>Set if a device supports HARQ output to device’s internal memory</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><dl class="simple">
<dt>RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_LOOPBACK</dt><dd><p>Set if a device supports loopback access to HARQ internal memory</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>The structure passed for each LDPC decode operation is given below,
with the operation flags forming a bitmask in the <code class="docutils literal notranslate"><span class="pre">op_flags</span></code> field.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_bbdev_op_ldpc_dec</span> <span class="p">{</span>

    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">hard_output</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">soft_output</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">harq_combined_input</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rte_bbdev_op_data</span> <span class="n">harq_combined_output</span><span class="p">;</span>

    <span class="kt">uint32_t</span> <span class="n">op_flags</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">rv_index</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">basegraph</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">z_c</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">n_cb</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">q_m</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">n_filler</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">iter_max</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">iter_count</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">code_block_mode</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_dec_ldpc_cb_params</span> <span class="n">cb_params</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">rte_bbdev_op_dec_ldpc_tb_params</span> <span class="n">tb_params</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The LDPC decode parameters are set out in the table below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head" colspan="2"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>input</p></td>
<td colspan="2"><p>input CB or TB data</p></td>
</tr>
<tr class="row-odd"><td><p>hard_output</p></td>
<td colspan="2"><p>hard decisions buffer, decoded output</p></td>
</tr>
<tr class="row-even"><td><p>soft_output</p></td>
<td colspan="2"><p>soft LLR output buffer (optional)</p></td>
</tr>
<tr class="row-odd"><td><p>harq_comb_input</p></td>
<td colspan="2"><p>HARQ combined input buffer (optional)</p></td>
</tr>
<tr class="row-even"><td><p>harq_comb_output</p></td>
<td colspan="2"><p>HARQ combined output buffer (optional)</p></td>
</tr>
<tr class="row-odd"><td><p>op_flags</p></td>
<td colspan="2"><p>bitmask of all active operation capabilities</p></td>
</tr>
<tr class="row-even"><td><p>rv_index</p></td>
<td colspan="2"><p>redundancy version index [0..3]</p></td>
</tr>
<tr class="row-odd"><td><p>basegraph</p></td>
<td colspan="2"><p>Basegraph 1 or 2</p></td>
</tr>
<tr class="row-even"><td><p>z_c</p></td>
<td colspan="2"><p>Zc, LDPC lifting size</p></td>
</tr>
<tr class="row-odd"><td><p>n_cb</p></td>
<td colspan="2"><p>Ncb, length of the circular buffer in bits.</p></td>
</tr>
<tr class="row-even"><td><p>q_m</p></td>
<td colspan="2"><p>Qm, modulation order {1,2,4,6,8} from pi/2-BPSK to 256QAM</p></td>
</tr>
<tr class="row-odd"><td><p>n_filler</p></td>
<td colspan="2"><p>number of filler bits</p></td>
</tr>
<tr class="row-even"><td><p>iter_max</p></td>
<td colspan="2"><p>maximum number of iterations to perform in decode all CBs</p></td>
</tr>
<tr class="row-odd"><td><p>iter_count</p></td>
<td colspan="2"><p>number of iterations performed in decoding all CBs</p></td>
</tr>
<tr class="row-even"><td><p>code_block_mode</p></td>
<td colspan="2"><p>code block or transport block mode</p></td>
</tr>
<tr class="row-odd"><td><p>op_flags</p></td>
<td colspan="2"><p>bitmask of all active operation capabilities</p></td>
</tr>
<tr class="row-even"><td><p><strong>cb_params</strong></p></td>
<td colspan="2"><p>code block specific parameters (code block mode only)</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>e</p></td>
<td><p>E, length of the rate matched output sequence in bits</p></td>
</tr>
<tr class="row-even"><td><p><strong>tb_params</strong></p></td>
<td colspan="2"><p>transport block specific parameters (transport block mode only)</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>c</p></td>
<td><p>number of CBs in the TB or partial TB</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>r</p></td>
<td><p>index of the first CB in the inbound mbuf data</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>c_ab</p></td>
<td><p>number of CBs that use Ea before switching to Eb</p></td>
</tr>
<tr class="row-even"><td></td>
<td><p>ea</p></td>
<td><p>Ea, length of the RM output sequence in bits, r &lt; cab</p></td>
</tr>
<tr class="row-odd"><td></td>
<td><p>eb</p></td>
<td><p>Eb, length of the RM output sequence in bits  r &gt;= cab</p></td>
</tr>
</tbody>
</table>
<p>The mbuf input <code class="docutils literal notranslate"><span class="pre">input</span></code> encoded CB data is mandatory for all BBDEV PMDs
and is the Virtual Circular Buffer data stream with null padding.
Each byte in the input circular buffer is the LLR value of each bit of
the original CB.</p>
<p>The mbuf output <code class="docutils literal notranslate"><span class="pre">hard_output</span></code> is mandatory and is the decoded CBs size
K (CRC24A/B is the last 24-bit in each decoded CB).</p>
<p>The mbuf output <code class="docutils literal notranslate"><span class="pre">soft_output</span></code> is optional and is an LLR rate matched
output of size <code class="docutils literal notranslate"><span class="pre">e</span></code> (this is <code class="docutils literal notranslate"><span class="pre">E</span></code> as per 3GPP TS 38.212 section 6.2.5).</p>
<p>The mbuf input <code class="docutils literal notranslate"><span class="pre">harq_combine_input</span></code> is optional and is a buffer with
the input to the HARQ combination function of the device. If the
capability RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_IN_ENABLE is set
then the HARQ is stored in memory internal to the device and not visible
to BBDEV.</p>
<p>The mbuf output <code class="docutils literal notranslate"><span class="pre">harq_combine_output</span></code> is optional and is a buffer for
the output of the HARQ combination function of the device. If the
capability RTE_BBDEV_LDPC_INTERNAL_HARQ_MEMORY_OUT_ENABLE is set
then the HARQ is stored in memory internal to the device and not visible
to BBDEV.</p>
<p>The output mbuf data structures are expected to be allocated by the
application with enough room for the output data.</p>
<p>As with the LDPC encode, the decode interface works on both a code block
(CB) and a transport block (TB) basis.</p>
<blockquote>
<div><p><strong>NOTE:</strong> All enqueued ops in one <code class="docutils literal notranslate"><span class="pre">rte_bbdev_enqueue_dec_ops()</span></code>
call belong to one mode, either CB-mode or TB-mode.</p>
</div></blockquote>
<p>The valid modes of operation are:</p>
<ul class="simple">
<li><p>CB-mode: one CB (check CRC24B if required)</p></li>
<li><p>CB-mode: one CB making up one TB (check CRC24A if required)</p></li>
<li><p>TB-mode: one or more CB making up a partial TB (check CRC24B(s) if required)</p></li>
<li><p>TB-mode: one or more CB making up a complete TB (check CRC24B(s) if required)</p></li>
</ul>
<p>The mbuf <code class="docutils literal notranslate"><span class="pre">length</span></code> is inclusive of CRC24A/B where present and is equal
the code block size <code class="docutils literal notranslate"><span class="pre">K</span></code>.</p>
<p>The first CB Virtual Circular Buffer (VCB) index is given by <code class="docutils literal notranslate"><span class="pre">r</span></code> but the
number of the remaining CB VCBs is calculated automatically by BBDEV
and passed down to the driver.</p>
<p>The number of remaining CB VCBs should not be confused with <code class="docutils literal notranslate"><span class="pre">c</span></code>, the
total number of CBs in the full TB (<code class="docutils literal notranslate"><span class="pre">C</span></code> as per 3GPP TS 38.212 section 5.2.2)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">length</span></code> is total size of the CBs inclusive of any CRC24A and CRC24B in
case they were appended by the application.</p>
<p>Figure <a class="reference internal" href="#figure-turbo-tb-decode"><span class="std std-numref">Fig. 16.3</span></a> above
showing the Turbo decoding of CBs using BBDEV interface in TB-mode
is also valid for LDPC decode.</p>
</div>
</div>
<div class="section" id="sample-code">
<h2><span class="section-number">16.5. </span>Sample code</h2>
<p>The baseband device sample application gives an introduction on how to use the
bbdev framework, by giving a sample code performing a loop-back operation with a
baseband processor capable of transceiving data packets.</p>
<p>The following sample C-like pseudo-code shows the basic steps to encode several
buffers using (<strong>sw_turbo</strong>) bbdev PMD.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* EAL Init */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eal_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;Invalid EAL arguments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Get number of available bbdev devices */</span>
<span class="n">nb_bbdevs</span> <span class="o">=</span> <span class="n">rte_bbdev_count</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">nb_bbdevs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">&quot;No bbdevs detected!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Create bbdev op pools */</span>
<span class="n">bbdev_op_pool</span><span class="p">[</span><span class="n">RTE_BBDEV_OP_TURBO_ENC</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">rte_bbdev_op_pool_create</span><span class="p">(</span><span class="s">&quot;bbdev_op_pool_enc&quot;</span><span class="p">,</span>
        <span class="n">RTE_BBDEV_OP_TURBO_ENC</span><span class="p">,</span> <span class="n">NB_MBUF</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">rte_socket_id</span><span class="p">());</span>

<span class="cm">/* Get information for this device */</span>
<span class="n">rte_bbdev_info_get</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

<span class="cm">/* Setup BBDEV device queues */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_bbdev_setup_queues</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">qs_nb</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">socket_id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
            <span class="s">&quot;ERROR(%d): BBDEV %u not configured properly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
            <span class="n">ret</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>

<span class="cm">/* setup device queues */</span>
<span class="n">qconf</span><span class="p">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">socket_id</span><span class="p">;</span>
<span class="n">qconf</span><span class="p">.</span><span class="n">queue_size</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">drv</span><span class="p">.</span><span class="n">queue_size_lim</span><span class="p">;</span>
<span class="n">qconf</span><span class="p">.</span><span class="n">op_type</span> <span class="o">=</span> <span class="n">RTE_BBDEV_OP_TURBO_ENC</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">q_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">q_id</span> <span class="o">&lt;</span> <span class="n">qs_nb</span><span class="p">;</span> <span class="n">q_id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Configure all queues belonging to this bbdev device */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_bbdev_queue_configure</span><span class="p">(</span><span class="n">dev_id</span><span class="p">,</span> <span class="n">q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qconf</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
                <span class="s">&quot;ERROR(%d): BBDEV %u queue %u not configured properly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="n">ret</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">,</span> <span class="n">q_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Start bbdev device */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">rte_bbdev_start</span><span class="p">(</span><span class="n">dev_id</span><span class="p">);</span>

<span class="cm">/* Create the mbuf mempool for pkts */</span>
<span class="n">mbuf_pool</span> <span class="o">=</span> <span class="n">rte_pktmbuf_pool_create</span><span class="p">(</span><span class="s">&quot;bbdev_mbuf_pool&quot;</span><span class="p">,</span>
        <span class="n">NB_MBUF</span><span class="p">,</span> <span class="n">MEMPOOL_CACHE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">RTE_MBUF_DEFAULT_BUF_SIZE</span><span class="p">,</span> <span class="n">rte_socket_id</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mbuf_pool</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span>
            <span class="s">&quot;Unable to create &#39;%s&#39; pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pool_name</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">global_exit_flag</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/* Allocate burst of op structures in preparation for enqueue */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rte_bbdev_enc_op_alloc_bulk</span><span class="p">(</span><span class="n">bbdev_op_pool</span><span class="p">[</span><span class="n">RTE_BBDEV_OP_TURBO_ENC</span><span class="p">],</span>
        <span class="n">ops_burst</span><span class="p">,</span> <span class="n">op_num</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>

    <span class="cm">/* Allocate input mbuf pkts */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_pktmbuf_alloc_bulk</span><span class="p">(</span><span class="n">mbuf_pool</span><span class="p">,</span> <span class="n">input_pkts_burst</span><span class="p">,</span> <span class="n">MAX_PKT_BURST</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>

    <span class="cm">/* Allocate output mbuf pkts */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_pktmbuf_alloc_bulk</span><span class="p">(</span><span class="n">mbuf_pool</span><span class="p">,</span> <span class="n">output_pkts_burst</span><span class="p">,</span> <span class="n">MAX_PKT_BURST</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">op_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Append the size of the ethernet header */</span>
        <span class="n">rte_pktmbuf_append</span><span class="p">(</span><span class="n">input_pkts_burst</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_ether_hdr</span><span class="p">));</span>

        <span class="cm">/* set op */</span>

        <span class="n">ops_burst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">turbo_enc</span><span class="p">.</span><span class="n">input</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_ether_hdr</span><span class="p">);</span>

        <span class="n">ops_burst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">turbo_enc</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span>
            <span class="n">rte_pktmbuf_pkt_len</span><span class="p">(</span><span class="n">bbdev_pkts</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

        <span class="n">ops_burst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">turbo_enc</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span>
            <span class="n">input_pkts_burst</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

        <span class="n">ops_burst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">turbo_enc</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_ether_hdr</span><span class="p">);</span>

        <span class="n">ops_burst</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">turbo_enc</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span>
                <span class="n">output_pkts_burst</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="cm">/* Enqueue packets on BBDEV device */</span>
    <span class="n">op_num</span> <span class="o">=</span> <span class="n">rte_bbdev_enqueue_enc_ops</span><span class="p">(</span><span class="n">qconf</span><span class="o">-&gt;</span><span class="n">bbdev_id</span><span class="p">,</span>
            <span class="n">qconf</span><span class="o">-&gt;</span><span class="n">bbdev_qs</span><span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">ops_burst</span><span class="p">,</span>
            <span class="n">MAX_PKT_BURST</span><span class="p">);</span>

    <span class="cm">/* Dequeue packets from BBDEV device*/</span>
    <span class="n">op_num</span> <span class="o">=</span> <span class="n">rte_bbdev_dequeue_enc_ops</span><span class="p">(</span><span class="n">qconf</span><span class="o">-&gt;</span><span class="n">bbdev_id</span><span class="p">,</span>
            <span class="n">qconf</span><span class="o">-&gt;</span><span class="n">bbdev_qs</span><span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">ops_burst</span><span class="p">,</span>
            <span class="n">MAX_PKT_BURST</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="bbdev-device-api">
<h3><span class="section-number">16.5.1. </span>BBDEV Device API</h3>
<p>The bbdev Library API is described in the <em>DPDK API Reference</em> document.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="cryptodev_lib.html" class="btn btn-neutral float-right" title="17. Cryptography Device Library" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="traffic_management.html" class="btn btn-neutral float-left" title="15. Traffic Management API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>