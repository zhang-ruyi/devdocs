

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>26. Membership Library &mdash; Data Plane Development Kit 20.11.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="27. LPM Library" href="lpm_lib.html" />
    <link rel="prev" title="25. Elastic Flow Distributor Library" href="efd_lib.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Data Plane Development Kit
          

          
            
            <img src="../_static/DPDK_logo_vertical_rev_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                20.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_app_ug/index.html">Sample Applications User Guides</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programmer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html">2. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="env_abstraction_layer.html">3. Environment Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="service_cores.html">4. Service Cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="trace_lib.html">5. Trace Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rcu_lib.html">6. RCU Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ring_lib.html">7. Ring Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="stack_lib.html">8. Stack Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mempool_lib.html">9. Mempool Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mbuf_lib.html">10. Mbuf Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="poll_mode_drv.html">11. Poll Mode Driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="rte_flow.html">12. Generic flow API (rte_flow)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switch_representation.html">13. Switch Representation within DPDK Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="traffic_metering_and_policing.html">14. Traffic Metering and Policing API</a></li>
<li class="toctree-l2"><a class="reference internal" href="traffic_management.html">15. Traffic Management API</a></li>
<li class="toctree-l2"><a class="reference internal" href="bbdev.html">16. Wireless Baseband Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="cryptodev_lib.html">17. Cryptography Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="compressdev.html">18. Compression Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regexdev.html">19. RegEx Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rte_security.html">20. Security Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rawdev.html">21. Rawdevice Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="link_bonding_poll_mode_drv_lib.html">22. Link Bonding Poll Mode Driver Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer_lib.html">23. Timer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="hash_lib.html">24. Hash Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="efd_lib.html">25. Elastic Flow Distributor Library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">26. Membership Library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">26.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vector-of-bloom-filters">26.2. Vector of Bloom Filters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hash-table-based-set-summaries">26.3. Hash-Table based Set-Summaries</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#set-summaries-with-false-negative-probability">26.3.1. Set-Summaries with False Negative Probability</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#library-api-overview">26.4. Library API Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#set-summary-create">26.4.1. Set-summary Create</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-summary-element-insertion">26.4.2. Set-summary Element Insertion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-summary-element-lookup">26.4.3. Set-summary Element Lookup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#set-summary-element-delete">26.4.4. Set-summary Element Delete</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#references">26.5. References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lpm_lib.html">27. LPM Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm6_lib.html">28. LPM6 Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow_classify_lib.html">29. Flow Classification Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_distrib_lib.html">30. Packet Distributor Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="reorder_lib.html">31. Reorder Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_fragment_reassembly_lib.html">32. IP Fragmentation and Reassembly Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_receive_offload_lib.html">33. Generic Receive Offload Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_segmentation_offload_lib.html">34. Generic Segmentation Offload Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pdump_lib.html">35. The librte_pdump Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_proc_support.html">36. Multi-process Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel_nic_interface.html">37. Kernel NIC Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread_safety_dpdk_functions.html">38. Thread Safety of DPDK Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="eventdev.html">39. Event Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_ethernet_rx_adapter.html">40. Event Ethernet Rx Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_ethernet_tx_adapter.html">41. Event Ethernet Tx Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_timer_adapter.html">42. Event Timer Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_crypto_adapter.html">43. Event Crypto Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_framework.html">44. Quality of Service (QoS) Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_man.html">45. Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_classif_access_ctrl.html">46. Packet Classification and Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_framework.html">47. Packet Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost_lib.html">48. Vhost Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="metrics_lib.html">49. Metrics Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="telemetry_lib.html">50. Telemetry Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="bpf_lib.html">51. Berkeley Packet Filter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec_lib.html">52. IPsec Packet Processing Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_lib.html">53. Graph Library and Inbuilt Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_org.html">54. Source Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-sdk-meson.html">55. Installing DPDK Using the meson build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson_ut.html">56. Running DPDK Unit Tests with Meson</a></li>
<li class="toctree-l2"><a class="reference internal" href="build_app.html">57. Building Your Own Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="perf_opt_guidelines.html">58. Performance Optimization Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing_efficient_code.html">59. Writing Efficient Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="lto.html">60. Link Time Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile_app.html">61. Profile Your Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="glossary.html">62. Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor’s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Data Plane Development Kit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Programmer’s Guide</a> &raquo;</li>
        
      <li><span class="section-number">26. </span>Membership Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/prog_guide/member_lib.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="membership-library">
<span id="member-library"></span><h1><span class="section-number">26. </span>Membership Library</h1>
<div class="section" id="introduction">
<h2><span class="section-number">26.1. </span>Introduction</h2>
<p>The DPDK Membership Library provides an API for DPDK applications to insert a
new member, delete an existing member, or query the existence of a member in a
given set, or a group of sets. For the case of a group of sets, the library
will return not only whether the element has been inserted before in one of
the sets but also which set it belongs to.  The Membership Library is an
extension and generalization of a traditional filter structure (for example
Bloom Filter [Member-bloom]) that has multiple usages in a wide variety of
workloads and applications. In general, the Membership Library is a data
structure that provides a “set-summary” on whether a member belongs to a set,
and as discussed in detail later, there are two advantages of using such a
set-summary rather than operating on a “full-blown” complete list of elements:
first, it has a much smaller storage requirement than storing the whole list of
elements themselves, and secondly checking an element membership (or other
operations) in this set-summary is much faster than checking it for the
original full-blown complete list of elements.</p>
<p>We use the term “Set-Summary” in this guide to refer to the space-efficient,
probabilistic membership data structure that is provided by the library. A
membership test for an element will return the set this element belongs to or
that the element is “not-found” with very high probability of accuracy. Set-summary
is a fundamental data aggregation component that can be used in many network
(and other) applications. It is a crucial structure to address performance and
scalability issues of diverse network applications including overlay networks,
data-centric networks, flow table summaries, network statistics and
traffic monitoring. A set-summary is useful for applications who need to
include a list of elements while a complete list requires too much space
and/or too much processing cost. In these situations, the set-summary works as
a lossy hash-based representation of a set of members. It can dramatically
reduce space requirement and significantly improve the performance of set
membership queries at the cost of introducing a very small membership test error
probability.</p>
<div class="figure align-default" id="id3">
<span id="figure-membership1"></span><img alt="../_images/member_i1.svg" src="../_images/member_i1.svg" /><p class="caption"><span class="caption-number">Fig. 26.2 </span><span class="caption-text">Example Usages of Membership Library</span></p>
</div>
<p>There are various usages for a Membership Library in a very
large set of applications and workloads. Interested readers can refer to
[Member-survey] for a survey of possible networking usages. The above figure
provide a small set of examples of using the Membership Library:</p>
<ul class="simple">
<li><p>Sub-figure (a)
depicts a distributed web cache architecture where a collection of proxies
attempt to share their web caches (cached from a set of back-end web servers) to
provide faster responses to clients, and the proxies use the Membership
Library to share summaries of what web pages/objects they are caching. With the
Membership Library, a proxy receiving an http request will inquire the
set-summary to find its location and quickly determine whether to retrieve the
requested web page from a nearby proxy or from a back-end web server.</p></li>
<li><p>Sub-figure (b) depicts another example for using the Membership Library to
prevent routing loops which is typically done using slow TTL countdown and
dropping packets when TTL expires. As shown in Sub-figure (b), an embedded
set-summary in the packet header itself can be used to summarize the set of
nodes a packet has gone through, and each node upon receiving a packet can check
whether its id is a member of the set of visited nodes, and if it is, then a
routing loop is detected.</p></li>
<li><p>Sub-Figure (c) presents another usage of the Membership
Library to load-balance flows to worker threads with in-order guarantee where a
set-summary is used to query if a packet belongs to an existing flow or a new
flow. Packets belonging to a new flow are forwarded to the current least loaded
worker thread, while those belonging to an existing flow are forwarded to the
pre-assigned thread to guarantee in-order processing.</p></li>
<li><p>Sub-figure (d) highlights
yet another usage example in the database domain where a set-summary is used to
determine joins between sets instead of creating a join by comparing each
element of a set against the other elements in a different set, a join is done
on the summaries since they can efficiently encode members of a given set.</p></li>
</ul>
<p>Membership Library is a configurable library that is optimized to cover set
membership functionality for both a single set and multi-set scenarios. Two set-summary
schemes are presented including (a) vector of Bloom Filters and (b) Hash-Table based
set-summary schemes with and without false negative probability.
This guide first briefly describes these different types of set-summaries, usage examples for each,
and then it highlights the Membership Library API.</p>
</div>
<div class="section" id="vector-of-bloom-filters">
<h2><span class="section-number">26.2. </span>Vector of Bloom Filters</h2>
<p>Bloom Filter (BF) [Member-bloom] is a well-known space-efficient
probabilistic data structure that answers set membership queries (test whether
an element is a member of a set) with some probability of false positives and
zero false negatives; a query for an element returns either it is “possibly in
a set” (with very high probability) or “definitely not in a set”.</p>
<p>The BF is a method for representing a set of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements (for example flow keys
in network applications domain) to support membership queries. The idea of BF is
to allocate a bit-vector <code class="docutils literal notranslate"><span class="pre">v</span></code> with <code class="docutils literal notranslate"><span class="pre">m</span></code> bits, which are initially all set to 0. Then
it chooses <code class="docutils literal notranslate"><span class="pre">k</span></code> independent hash functions <code class="docutils literal notranslate"><span class="pre">h1</span></code>, <code class="docutils literal notranslate"><span class="pre">h2</span></code>, … <code class="docutils literal notranslate"><span class="pre">hk</span></code> with hash values range from
<code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">m-1</span></code> to perform hashing calculations on each element to be inserted. Every time when an
element <code class="docutils literal notranslate"><span class="pre">X</span></code> being inserted into the set, the bits at positions <code class="docutils literal notranslate"><span class="pre">h1(X)</span></code>, <code class="docutils literal notranslate"><span class="pre">h2(X)</span></code>, …
<code class="docutils literal notranslate"><span class="pre">hk(X)</span></code> in <code class="docutils literal notranslate"><span class="pre">v</span></code> are set to 1 (any particular bit might be set to 1 multiple times
for multiple different inserted elements). Given a query for any element <code class="docutils literal notranslate"><span class="pre">Y</span></code>, the
bits at positions <code class="docutils literal notranslate"><span class="pre">h1(Y)</span></code>, <code class="docutils literal notranslate"><span class="pre">h2(Y)</span></code>, … <code class="docutils literal notranslate"><span class="pre">hk(Y)</span></code> are checked. If any of them is 0,
then Y is definitely not in the set. Otherwise there is a high probability that
Y is a member of the set with certain false positive probability. As shown in
the next equation, the false positive probability can be made arbitrarily small
by changing the number of hash functions (<code class="docutils literal notranslate"><span class="pre">k</span></code>) and the vector length (<code class="docutils literal notranslate"><span class="pre">m</span></code>).</p>
<div class="figure align-default" id="id4">
<span id="figure-membership2"></span><img alt="../_images/member_i2.svg" src="../_images/member_i2.svg" /><p class="caption"><span class="caption-number">Fig. 26.3 </span><span class="caption-text">Bloom Filter False Positive Probability</span></p>
</div>
<p>Without BF, an accurate membership testing could involve a costly hash table
lookup and full element comparison. The advantage of using a BF is to simplify
the membership test into a series of hash calculations and memory accesses for a
small bit-vector, which can be easily optimized. Hence the lookup throughput
(set membership test) can be significantly faster than a normal hash table
lookup with element comparison.</p>
<div class="figure align-default" id="id5">
<span id="figure-membership3"></span><img alt="../_images/member_i3.svg" src="../_images/member_i3.svg" /><p class="caption"><span class="caption-number">Fig. 26.4 </span><span class="caption-text">Detecting Routing Loops Using BF</span></p>
</div>
<p>BF is used for applications that need only one set, and the
membership of elements is checked against the BF. The example discussed
in the above figure is one example of potential applications that uses only one
set to capture the node IDs that have been visited so far by the packet. Each
node will then check this embedded BF in the packet header for its own id, and
if the BF indicates that the current node is definitely not in the set then a
loop-free route is guaranteed.</p>
<div class="figure align-default" id="id6">
<span id="figure-membership4"></span><img alt="../_images/member_i4.svg" src="../_images/member_i4.svg" /><p class="caption"><span class="caption-number">Fig. 26.5 </span><span class="caption-text">Vector Bloom Filter (vBF) Overview</span></p>
</div>
<p>To support membership test for both multiple sets and a single set,
the library implements a Vector Bloom Filter (vBF) scheme.
vBF basically composes multiple bloom filters into a vector of bloom filers.
The membership test is conducted on all of the
bloom filters concurrently to determine which set(s) it belongs to or none of
them. The basic idea of vBF is shown in the above figure where an element is
used to address multiple bloom filters concurrently and the bloom filter
index(es) with a hit is returned.</p>
<div class="figure align-default" id="id7">
<span id="figure-membership5"></span><img alt="../_images/member_i5.svg" src="../_images/member_i5.svg" /><p class="caption"><span class="caption-number">Fig. 26.6 </span><span class="caption-text">vBF for Flow Scheduling to Worker Thread</span></p>
</div>
<p>As previously mentioned, there are many usages of such structures. vBF is used
for applications that need to check membership against multiple sets
simultaneously. The example shown in the above figure uses a set to capture
all flows being assigned for processing at a given worker thread. Upon receiving
a packet the vBF is used to quickly figure out if this packet belongs to a new flow
so as to be forwarded to the current least loaded worker thread, or otherwise it
should be queued for an existing thread to guarantee in-order processing (i.e.
the property of vBF to indicate right away that a given flow is a new one or
not is critical to minimize response time latency).</p>
<p>It should be noted that vBF can be implemented using a set of single bloom
filters with sequential lookup of each BF. However, being able to concurrently
search all set-summaries is a big throughput advantage. In the library, certain
parallelism is realized by the implementation of checking all bloom filters
together.</p>
</div>
<div class="section" id="hash-table-based-set-summaries">
<h2><span class="section-number">26.3. </span>Hash-Table based Set-Summaries</h2>
<p>Hash-table based set-summary (HTSS) is another scheme in the membership library.
Cuckoo filter [Member-cfilter] is an example of HTSS.
HTSS supports multi-set membership testing like
vBF does. However, while vBF is better for a small number of targets, HTSS is more suitable
and can easily outperform vBF when the number of sets is
large, since HTSS uses a single hash table for membership testing while vBF
requires testing a series of Bloom Filters each corresponding to one set.
As a result, generally speaking vBF is more adequate for the case of a small limited number of sets
while HTSS should be used with a larger number of sets.</p>
<div class="figure align-default" id="id8">
<span id="figure-membership6"></span><img alt="../_images/member_i6.svg" src="../_images/member_i6.svg" /><p class="caption"><span class="caption-number">Fig. 26.7 </span><span class="caption-text">Using HTSS for Attack Signature Matching</span></p>
</div>
<p>As shown in the above figure, attack signature matching where each set
represents a certain signature length (for correctness of this example, an
attack signature should not be a subset of another one) in the payload is a good
example for using HTSS with 0% false negative (i.e., when an element returns not
found, it has a 100% certainty that it is not a member of any set).  The packet
inspection application benefits from knowing right away that the current payload
does not match any attack signatures in the database to establish its
legitimacy, otherwise a deep inspection of the packet is needed.</p>
<p>HTSS employs a similar but simpler data structure to a traditional hash table,
and the major difference is that HTSS stores only the signatures but not the
full keys/elements which can significantly reduce the footprint of the table.
Along with the signature, HTSS also stores a value to indicate the target set.
When looking up an element, the element is hashed and the HTSS is addressed
to retrieve the signature stored. If the signature matches then the value is
retrieved corresponding to the index of the target set which the element belongs
to. Because signatures can collide, HTSS can still has false positive
probability. Furthermore, if elements are allowed to be
overwritten or evicted when the hash table becomes full, it will also have a
false negative probability. We discuss this case in the next section.</p>
<div class="section" id="set-summaries-with-false-negative-probability">
<h3><span class="section-number">26.3.1. </span>Set-Summaries with False Negative Probability</h3>
<p>As previously mentioned, traditional set-summaries (e.g. Bloom Filters) do not
have a false negative probability, i.e., it is 100% certain when an element
returns “not to be present” for a given set. However, the Membership Library
also supports a set-summary probabilistic data structure based on HTSS which
allows for false negative probability.</p>
<p>In HTSS, when the hash table becomes full, keys/elements will fail to be added
into the table and the hash table has to be resized to accommodate for these new
elements, which can be expensive. However, if we allow new elements to overwrite
or evict existing elements (as a cache typically does), then the resulting
set-summary will begin to have false negative probability. This is because the
element that was evicted from the set-summary may still be present in the target
set. For subsequent inquiries the set-summary will falsely report the element
not being in the set, hence having a false negative probability.</p>
<p>The major usage of HTSS with false negative is to use it as a cache for
distributing elements to different target sets. By allowing HTSS to evict old
elements, the set-summary can keep track of the most recent elements
(i.e. active) as a cache typically does. Old inactive elements (infrequently
used elements) will automatically and eventually get evicted from the
set-summary. It is worth noting that the set-summary still has false positive
probability, which means the application either can tolerate certain false positive
or it has fall-back path when false positive happens.</p>
<div class="figure align-default" id="id9">
<span id="figure-membership7"></span><img alt="../_images/member_i7.svg" src="../_images/member_i7.svg" /><p class="caption"><span class="caption-number">Fig. 26.8 </span><span class="caption-text">Using HTSS with False Negatives for Wild Card Classification</span></p>
</div>
<p>HTSS with false negative (i.e. a cache) also has its wide set of applications.
For example wild card flow classification (e.g. ACL rules) highlighted in the
above figure is an example of such application. In that case each target set
represents a sub-table with rules defined by a certain flow mask. The flow masks
are non-overlapping, and for flows matching more than one rule only the highest
priority one is inserted in the corresponding sub-table (interested readers can
refer to the Open vSwitch (OvS) design of Mega Flow Cache (MFC) [Member-OvS]
for further details). Typically the rules will have a large number of distinct
unique masks and hence, a large number of target sets each corresponding to one
mask. Because the active set of flows varies widely based on the network
traffic, HTSS with false negative will act as a cache for &lt;flowid, target ACL
sub-table&gt; pair for the current active set of flows. When a miss occurs (as
shown in red in the above figure) the sub-tables will be searched sequentially
one by one for a possible match, and when found the flow key and target
sub-table will be inserted into the set-summary (i.e. cache insertion) so
subsequent packets from the same flow don’t incur the overhead of the
sequential search of sub-tables.</p>
</div>
</div>
<div class="section" id="library-api-overview">
<h2><span class="section-number">26.4. </span>Library API Overview</h2>
<p>The design goal of the Membership Library API is to be as generic as possible to
support all the different types of set-summaries we discussed in previous
sections and beyond. Fundamentally, the APIs need to include creation,
insertion, deletion, and lookup.</p>
<div class="section" id="set-summary-create">
<h3><span class="section-number">26.4.1. </span>Set-summary Create</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_member_create()</span></code> function is used to create a set-summary structure, the input parameter
is a struct to pass in parameters that needed to initialize the set-summary, while the function returns the
pointer to the created set-summary or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> if the creation failed.</p>
<p>The general input arguments used when creating the set-summary should include <code class="docutils literal notranslate"><span class="pre">name</span></code>
which is the name of the created set-summary, <em>type</em> which is one of the types
supported by the library (e.g. <code class="docutils literal notranslate"><span class="pre">RTE_MEMBER_TYPE_HT</span></code> for HTSS or <code class="docutils literal notranslate"><span class="pre">RTE_MEMBER_TYPE_VBF</span></code> for vBF), and <code class="docutils literal notranslate"><span class="pre">key_len</span></code>
which is the length of the element/key. There are other parameters
are only used for certain type of set-summary, or which have a slightly different meaning for different types of set-summary.
For example, <code class="docutils literal notranslate"><span class="pre">num_keys</span></code> parameter means the maximum number of entries for Hash table based set-summary.
However, for bloom filter, this value means the expected number of keys that could be
inserted into the bloom filter(s). The value is used to calculate the size of each
bloom filter.</p>
<p>We also pass two seeds: <code class="docutils literal notranslate"><span class="pre">prim_hash_seed</span></code> and
<code class="docutils literal notranslate"><span class="pre">sec_hash_seed</span></code> for the primary and secondary hash functions to calculate two independent hash values.
<code class="docutils literal notranslate"><span class="pre">socket_id</span></code> parameter is the NUMA socket ID for the memory used to create the
set-summary. For HTSS, another parameter <code class="docutils literal notranslate"><span class="pre">is_cache</span></code> is used to indicate
if this set-summary is a cache (i.e. with false negative probability) or not.
For vBF, extra parameters are needed. For example, <code class="docutils literal notranslate"><span class="pre">num_set</span></code> is the number of
sets needed to initialize the vector bloom filters. This number is equal to the
number of bloom filters will be created.
<code class="docutils literal notranslate"><span class="pre">false_pos_rate</span></code> is the false positive rate. num_keys and false_pos_rate will be used to determine
the number of hash functions and the bloom filter size.</p>
</div>
<div class="section" id="set-summary-element-insertion">
<h3><span class="section-number">26.4.2. </span>Set-summary Element Insertion</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_member_add()</span></code> function is used to insert an element/key into a set-summary structure. If it fails an
error is returned. For success the returned value is dependent on the
set-summary mode to provide extra information for the users. For vBF
mode, a return value of 0 means a successful insert. For HTSS mode without false negative, the insert
could fail with <code class="docutils literal notranslate"><span class="pre">-ENOSPC</span></code> if the table is full. With false negative (i.e. cache mode),
for insert that does not cause any eviction (i.e. no overwriting happens to an
existing entry) the return value is 0. For insertion that causes eviction, the return
value is 1 to indicate such situation, but it is not an error.</p>
<p>The input arguments for the function should include the <code class="docutils literal notranslate"><span class="pre">key</span></code> which is a pointer to the element/key that needs to
be added to the set-summary, and <code class="docutils literal notranslate"><span class="pre">set_id</span></code> which is the set id associated
with the key that needs to be added.</p>
</div>
<div class="section" id="set-summary-element-lookup">
<h3><span class="section-number">26.4.3. </span>Set-summary Element Lookup</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_member_lookup()</span></code> function looks up a single key/element in the set-summary structure. It
returns as soon as the first match is found. The return value is 1 if a
match is found and 0 otherwise. The arguments for the function include <code class="docutils literal notranslate"><span class="pre">key</span></code> which is a pointer to the
element/key that needs to be looked up, and <code class="docutils literal notranslate"><span class="pre">set_id</span></code> which is used to return the
first target set id where the key has matched, if any.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_member_lookup_bulk()</span></code> function is used to look up a bulk of keys/elements in the
set-summary structure for their first match. Each key lookup returns as soon as the first match is found. The
return value is the number of keys that find a match. The arguments of the function include <code class="docutils literal notranslate"><span class="pre">keys</span></code>
which is a pointer to a bulk of keys that are to be looked up,
<code class="docutils literal notranslate"><span class="pre">num_keys</span></code> is the number
of keys that will be looked up, and <code class="docutils literal notranslate"><span class="pre">set_ids</span></code> are the return target set
ids for the first match found for each of the input keys. <code class="docutils literal notranslate"><span class="pre">set_ids</span></code> is an array
needs to be sized according to the <code class="docutils literal notranslate"><span class="pre">num_keys</span></code>. If there is no match, the set id
for that key will be set to RTE_MEMBER_NO_MATCH.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_member_lookup_multi()</span></code> function looks up a single key/element in the
set-summary structure for multiple matches. It
returns ALL the matches (possibly more than one) found for this key when it
is matched against all target sets (it is worth noting that for cache mode HTSS,
the current implementation matches at most one target set). The return value is
the number of matches
that was found for this key (for cache mode HTSS the return value
should be at most 1). The arguments for the function include <code class="docutils literal notranslate"><span class="pre">key</span></code> which is a pointer to the
element/key that needs to be looked up, <code class="docutils literal notranslate"><span class="pre">max_match_per_key</span></code> which is to indicate the maximum number of matches
the user expects to find for each key, and <code class="docutils literal notranslate"><span class="pre">set_id</span></code> which is used to return all
target set ids where the key has matched, if any. The <code class="docutils literal notranslate"><span class="pre">set_id</span></code> array should be sized
according to <code class="docutils literal notranslate"><span class="pre">max_match_per_key</span></code>. For vBF, the maximum number of matches per key is equal
to the number of sets. For HTSS, the maximum number of matches per key is equal to two time
entry count per bucket. <code class="docutils literal notranslate"><span class="pre">max_match_per_key</span></code> should be equal or smaller than the maximum number of
possible matches.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_membership_lookup_multi_bulk()</span></code> function looks up a bulk of keys/elements in the
set-summary structure for multiple matches, each key lookup returns ALL the matches (possibly more
than one) found for this key when it is matched against all target sets (cache mode HTSS
matches at most one target set). The
return value is the number of keys that find one or more matches in the
set-summary structure. The arguments of the
function include <code class="docutils literal notranslate"><span class="pre">keys</span></code> which is
a pointer to a bulk of keys that are to be looked up, <code class="docutils literal notranslate"><span class="pre">num_keys</span></code> is the number
of keys that will be looked up, <code class="docutils literal notranslate"><span class="pre">max_match_per_key</span></code> is the possible
maximum number of matches for each key, <code class="docutils literal notranslate"><span class="pre">match_count</span></code> which is the returned number
of matches for each key, and <code class="docutils literal notranslate"><span class="pre">set_ids</span></code> are the returned target set
ids for all matches found for each keys. <code class="docutils literal notranslate"><span class="pre">set_ids</span></code> is 2-D array
containing a 1-D array for each key (the size of 1-D array per key should be set by the user according to <code class="docutils literal notranslate"><span class="pre">max_match_per_key</span></code>).
<code class="docutils literal notranslate"><span class="pre">max_match_per_key</span></code> should be equal or smaller than the maximum number of
possible matches, similar to <code class="docutils literal notranslate"><span class="pre">rte_member_lookup_multi</span></code>.</p>
</div>
<div class="section" id="set-summary-element-delete">
<h3><span class="section-number">26.4.4. </span>Set-summary Element Delete</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">rte_membership_delete()</span></code> function deletes an element/key from a set-summary structure, if it fails
an error is returned. The input arguments should include <code class="docutils literal notranslate"><span class="pre">key</span></code> which is a pointer to the
element/key that needs to be deleted from the set-summary, and <code class="docutils literal notranslate"><span class="pre">set_id</span></code>
which is the set id associated with the key to delete. It is worth noting that current
implementation of vBF does not support deletion <a class="footnote-reference brackets" href="#id2" id="id1">1</a>. An error code <code class="docutils literal notranslate"><span class="pre">-EINVAL</span></code> will be returned.</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Traditional bloom filter does not support proactive deletion. Supporting proactive deletion require additional implementation and performance overhead.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="references">
<h2><span class="section-number">26.5. </span>References</h2>
<p>[Member-bloom] B H Bloom, “Space/Time Trade-offs in Hash Coding with Allowable Errors,” Communications of the ACM, 1970.</p>
<p>[Member-survey] A Broder and M Mitzenmacher, “Network Applications of Bloom Filters: A Survey,” in Internet Mathematics, 2005.</p>
<p>[Member-cfilter] B Fan, D G Andersen and M Kaminsky, “Cuckoo Filter: Practically Better Than Bloom,” in Conference on emerging Networking Experiments and Technologies, 2014.</p>
<p>[Member-OvS] B Pfaff, “The Design and Implementation of Open vSwitch,” in NSDI, 2015.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="lpm_lib.html" class="btn btn-neutral float-right" title="27. LPM Library" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="efd_lib.html" class="btn btn-neutral float-left" title="25. Elastic Flow Distributor Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>