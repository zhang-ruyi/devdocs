

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>11. Poll Mode Driver &mdash; Data Plane Development Kit 20.11.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="12. Generic flow API (rte_flow)" href="rte_flow.html" />
    <link rel="prev" title="10. Mbuf Library" href="mbuf_lib.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Data Plane Development Kit
          

          
            
            <img src="../_static/DPDK_logo_vertical_rev_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                20.11.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_gsg/index.html">Getting Started Guide for Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../freebsd_gsg/index.html">Getting Started Guide for FreeBSD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../windows_gsg/index.html">Getting Started Guide for Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sample_app_ug/index.html">Sample Applications User Guides</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programmer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="overview.html">2. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="env_abstraction_layer.html">3. Environment Abstraction Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="service_cores.html">4. Service Cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="trace_lib.html">5. Trace Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rcu_lib.html">6. RCU Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ring_lib.html">7. Ring Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="stack_lib.html">8. Stack Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mempool_lib.html">9. Mempool Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="mbuf_lib.html">10. Mbuf Library</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">11. Poll Mode Driver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirements-and-assumptions">11.1. Requirements and Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#design-principles">11.2. Design Principles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logical-cores-memory-and-nic-queues-relationships">11.3. Logical Cores, Memory and NIC Queues Relationships</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-identification-ownership-and-configuration">11.4. Device Identification, Ownership and Configuration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#device-identification">11.4.1. Device Identification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#port-ownership">11.4.2. Port Ownership</a></li>
<li class="toctree-l4"><a class="reference internal" href="#device-configuration">11.4.3. Device Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#on-the-fly-configuration">11.4.4. On-the-Fly Configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-transmit-queues">11.4.5. Configuration of Transmit Queues</a></li>
<li class="toctree-l4"><a class="reference internal" href="#free-tx-mbuf-on-demand">11.4.6. Free Tx mbuf on Demand</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hardware-offload">11.4.7. Hardware Offload</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#poll-mode-driver-api">11.5. Poll Mode Driver API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generalities">11.5.1. Generalities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-packet-representation">11.5.2. Generic Packet Representation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ethernet-device-api">11.5.3. Ethernet Device API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ethernet-device-standard-device-arguments">11.5.4. Ethernet Device Standard Device Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extended-statistics-api">11.5.5. Extended Statistics API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nic-reset-api">11.5.6. NIC Reset API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="rte_flow.html">12. Generic flow API (rte_flow)</a></li>
<li class="toctree-l2"><a class="reference internal" href="switch_representation.html">13. Switch Representation within DPDK Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="traffic_metering_and_policing.html">14. Traffic Metering and Policing API</a></li>
<li class="toctree-l2"><a class="reference internal" href="traffic_management.html">15. Traffic Management API</a></li>
<li class="toctree-l2"><a class="reference internal" href="bbdev.html">16. Wireless Baseband Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="cryptodev_lib.html">17. Cryptography Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="compressdev.html">18. Compression Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="regexdev.html">19. RegEx Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rte_security.html">20. Security Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="rawdev.html">21. Rawdevice Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="link_bonding_poll_mode_drv_lib.html">22. Link Bonding Poll Mode Driver Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer_lib.html">23. Timer Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="hash_lib.html">24. Hash Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="efd_lib.html">25. Elastic Flow Distributor Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="member_lib.html">26. Membership Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm_lib.html">27. LPM Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="lpm6_lib.html">28. LPM6 Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="flow_classify_lib.html">29. Flow Classification Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_distrib_lib.html">30. Packet Distributor Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="reorder_lib.html">31. Reorder Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ip_fragment_reassembly_lib.html">32. IP Fragmentation and Reassembly Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_receive_offload_lib.html">33. Generic Receive Offload Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="generic_segmentation_offload_lib.html">34. Generic Segmentation Offload Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="pdump_lib.html">35. The librte_pdump Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="multi_proc_support.html">36. Multi-process Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="kernel_nic_interface.html">37. Kernel NIC Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread_safety_dpdk_functions.html">38. Thread Safety of DPDK Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="eventdev.html">39. Event Device Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_ethernet_rx_adapter.html">40. Event Ethernet Rx Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_ethernet_tx_adapter.html">41. Event Ethernet Tx Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_timer_adapter.html">42. Event Timer Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="event_crypto_adapter.html">43. Event Crypto Adapter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="qos_framework.html">44. Quality of Service (QoS) Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="power_man.html">45. Power Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_classif_access_ctrl.html">46. Packet Classification and Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="packet_framework.html">47. Packet Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="vhost_lib.html">48. Vhost Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="metrics_lib.html">49. Metrics Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="telemetry_lib.html">50. Telemetry Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="bpf_lib.html">51. Berkeley Packet Filter Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="ipsec_lib.html">52. IPsec Packet Processing Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="graph_lib.html">53. Graph Library and Inbuilt Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="source_org.html">54. Source Organization</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-sdk-meson.html">55. Installing DPDK Using the meson build system</a></li>
<li class="toctree-l2"><a class="reference internal" href="meson_ut.html">56. Running DPDK Unit Tests with Meson</a></li>
<li class="toctree-l2"><a class="reference internal" href="build_app.html">57. Building Your Own Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="perf_opt_guidelines.html">58. Performance Optimization Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing_efficient_code.html">59. Writing Efficient Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="lto.html">60. Link Time Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="profile_app.html">61. Profile Your Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="glossary.html">62. Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index.html">HowTo Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">DPDK Tools User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testpmd_app_ug/index.html">Testpmd Application User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nics/index.html">Network Interface Controller Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bbdevs/index.html">Baseband Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cryptodevs/index.html">Crypto Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../compressdevs/index.html">Compression Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vdpadevs/index.html">vDPA Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regexdevs/index.html">REGEX Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../eventdevs/index.html">Event Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rawdevs/index.html">Rawdev Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mempool/index.html">Mempool Device Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">Platform Specific Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributor’s Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rel_notes/index.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Data Plane Development Kit</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Programmer’s Guide</a> &raquo;</li>
        
      <li><span class="section-number">11. </span>Poll Mode Driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/prog_guide/poll_mode_drv.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="poll-mode-driver">
<span id="id1"></span><h1><span class="section-number">11. </span>Poll Mode Driver</h1>
<p>The DPDK includes 1 Gigabit, 10 Gigabit and 40 Gigabit and para virtualized virtio Poll Mode Drivers.</p>
<p>A Poll Mode Driver (PMD) consists of APIs, provided through the BSD driver running in user space,
to configure the devices and their respective queues.
In addition, a PMD accesses the RX and TX descriptors directly without any interrupts
(with the exception of Link Status Change interrupts) to quickly receive,
process and deliver packets in the user’s application.
This section describes the requirements of the PMDs,
their global design principles and proposes a high-level architecture and a generic external API for the Ethernet PMDs.</p>
<div class="section" id="requirements-and-assumptions">
<h2><span class="section-number">11.1. </span>Requirements and Assumptions</h2>
<p>The DPDK environment for packet processing applications allows for two models, run-to-completion and pipe-line:</p>
<ul class="simple">
<li><p>In the <em>run-to-completion</em>  model, a specific port’s RX descriptor ring is polled for packets through an API.
Packets are then processed on the same core and placed on a port’s TX descriptor ring through an API for transmission.</p></li>
<li><p>In the <em>pipe-line</em>  model, one core polls one or more port’s RX descriptor ring through an API.
Packets are received and passed to another core via a ring.
The other core continues to process the packet which then may be placed on a port’s TX descriptor ring through an API for transmission.</p></li>
</ul>
<p>In a synchronous run-to-completion model,
each logical core assigned to the DPDK executes a packet processing loop that includes the following steps:</p>
<ul class="simple">
<li><p>Retrieve input packets through the PMD receive API</p></li>
<li><p>Process each received packet one at a time, up to its forwarding</p></li>
<li><p>Send pending output packets through the PMD transmit API</p></li>
</ul>
<p>Conversely, in an asynchronous pipe-line model, some logical cores may be dedicated to the retrieval of received packets and
other logical cores to the processing of previously received packets.
Received packets are exchanged between logical cores through rings.
The loop for packet retrieval includes the following steps:</p>
<ul class="simple">
<li><p>Retrieve input packets through the PMD receive API</p></li>
<li><p>Provide received packets to processing lcores through packet queues</p></li>
</ul>
<p>The loop for packet processing includes the following steps:</p>
<ul class="simple">
<li><p>Retrieve the received packet from the packet queue</p></li>
<li><p>Process the received packet, up to its retransmission if forwarded</p></li>
</ul>
<p>To avoid any unnecessary interrupt processing overhead, the execution environment must not use any asynchronous notification mechanisms.
Whenever needed and appropriate, asynchronous communication should be introduced as much as possible through the use of rings.</p>
<p>Avoiding lock contention is a key issue in a multi-core environment.
To address this issue, PMDs are designed to work with per-core private resources as much as possible.
For example, a PMD maintains a separate transmit queue per-core, per-port, if the PMD is not <code class="docutils literal notranslate"><span class="pre">DEV_TX_OFFLOAD_MT_LOCKFREE</span></code> capable.
In the same way, every receive queue of a port is assigned to and polled by a single logical core (lcore).</p>
<p>To comply with Non-Uniform Memory Access (NUMA), memory management is designed to assign to each logical core
a private buffer pool in local memory to minimize remote memory access.
The configuration of packet buffer pools should take into account the underlying physical memory architecture in terms of DIMMS,
channels and ranks.
The application must ensure that appropriate parameters are given at memory pool creation time.
See <a class="reference internal" href="mempool_lib.html#mempool-library"><span class="std std-ref">Mempool Library</span></a>.</p>
</div>
<div class="section" id="design-principles">
<h2><span class="section-number">11.2. </span>Design Principles</h2>
<p>The API and architecture of the Ethernet* PMDs are designed with the following guidelines in mind.</p>
<p>PMDs must help global policy-oriented decisions to be enforced at the upper application level.
Conversely, NIC PMD functions should not impede the benefits expected by upper-level global policies,
or worse prevent such policies from being applied.</p>
<p>For instance, both the receive and transmit functions of a PMD have a maximum number of packets/descriptors to poll.
This allows a run-to-completion processing stack to statically fix or
to dynamically adapt its overall behavior through different global loop policies, such as:</p>
<ul class="simple">
<li><p>Receive, process immediately and transmit packets one at a time in a piecemeal fashion.</p></li>
<li><p>Receive as many packets as possible, then process all received packets, transmitting them immediately.</p></li>
<li><p>Receive a given maximum number of packets, process the received packets, accumulate them and finally send all accumulated packets to transmit.</p></li>
</ul>
<p>To achieve optimal performance, overall software design choices and pure software optimization techniques must be considered and
balanced against available low-level hardware-based optimization features (CPU cache properties, bus speed, NIC PCI bandwidth, and so on).
The case of packet transmission is an example of this software/hardware tradeoff issue when optimizing burst-oriented network packet processing engines.
In the initial case, the PMD could export only an rte_eth_tx_one function to transmit one packet at a time on a given queue.
On top of that, one can easily build an rte_eth_tx_burst function that loops invoking the rte_eth_tx_one function to transmit several packets at a time.
However, an rte_eth_tx_burst function is effectively implemented by the PMD to minimize the driver-level transmit cost per packet through the following optimizations:</p>
<ul class="simple">
<li><p>Share among multiple packets the un-amortized cost of invoking the rte_eth_tx_one function.</p></li>
<li><p>Enable the rte_eth_tx_burst function to take advantage of burst-oriented hardware features (prefetch data in cache, use of NIC head/tail registers)
to minimize the number of CPU cycles per packet, for example by avoiding unnecessary read memory accesses to ring transmit descriptors,
or by systematically using arrays of pointers that exactly fit cache line boundaries and sizes.</p></li>
<li><p>Apply burst-oriented software optimization techniques to remove operations that would otherwise be unavoidable, such as ring index wrap back management.</p></li>
</ul>
<p>Burst-oriented functions are also introduced via the API for services that are intensively used by the PMD.
This applies in particular to buffer allocators used to populate NIC rings, which provide functions to allocate/free several buffers at a time.
For example, an mbuf_multiple_alloc function returning an array of pointers to rte_mbuf buffers which speeds up the receive poll function of the PMD when
replenishing multiple descriptors of the receive ring.</p>
</div>
<div class="section" id="logical-cores-memory-and-nic-queues-relationships">
<h2><span class="section-number">11.3. </span>Logical Cores, Memory and NIC Queues Relationships</h2>
<p>The DPDK supports NUMA allowing for better performance when a processor’s logical cores and interfaces utilize its local memory.
Therefore, mbuf allocation associated with local PCIe* interfaces should be allocated from memory pools created in the local memory.
The buffers should, if possible, remain on the local processor to obtain the best performance results and RX and TX buffer descriptors
should be populated with mbufs allocated from a mempool allocated from local memory.</p>
<p>The run-to-completion model also performs better if packet or data manipulation is in local memory instead of a remote processors memory.
This is also true for the pipe-line model provided all logical cores used are located on the same processor.</p>
<p>Multiple logical cores should never share receive or transmit queues for interfaces since this would require global locks and hinder performance.</p>
<p>If the PMD is <code class="docutils literal notranslate"><span class="pre">DEV_TX_OFFLOAD_MT_LOCKFREE</span></code> capable, multiple threads can invoke <code class="docutils literal notranslate"><span class="pre">rte_eth_tx_burst()</span></code>
concurrently on the same tx queue without SW lock. This PMD feature found in some NICs and useful in the following use cases:</p>
<ul class="simple">
<li><p>Remove explicit spinlock in some applications where lcores are not mapped to Tx queues with 1:1 relation.</p></li>
<li><p>In the eventdev use case, avoid dedicating a separate TX core for transmitting and thus
enables more scaling as all workers can send the packets.</p></li>
</ul>
<p>See <a class="reference internal" href="#hardware-offload">Hardware Offload</a> for <code class="docutils literal notranslate"><span class="pre">DEV_TX_OFFLOAD_MT_LOCKFREE</span></code> capability probing details.</p>
</div>
<div class="section" id="device-identification-ownership-and-configuration">
<h2><span class="section-number">11.4. </span>Device Identification, Ownership and Configuration</h2>
<div class="section" id="device-identification">
<h3><span class="section-number">11.4.1. </span>Device Identification</h3>
<p>Each NIC port is uniquely designated by its (bus/bridge, device, function) PCI
identifiers assigned by the PCI probing/enumeration function executed at DPDK initialization.
Based on their PCI identifier, NIC ports are assigned two other identifiers:</p>
<ul class="simple">
<li><p>A port index used to designate the NIC port in all functions exported by the PMD API.</p></li>
<li><p>A port name used to designate the port in console messages, for administration or debugging purposes.
For ease of use, the port name includes the port index.</p></li>
</ul>
</div>
<div class="section" id="port-ownership">
<h3><span class="section-number">11.4.2. </span>Port Ownership</h3>
<p>The Ethernet devices ports can be owned by a single DPDK entity (application, library, PMD, process, etc).
The ownership mechanism is controlled by ethdev APIs and allows to set/remove/get a port owner by DPDK entities.
Allowing this should prevent any multiple management of Ethernet port by different entities.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is the DPDK entity responsibility to set the port owner before using it and to manage the port usage synchronization between different threads or processes.</p>
</div>
</div>
<div class="section" id="device-configuration">
<h3><span class="section-number">11.4.3. </span>Device Configuration</h3>
<p>The configuration of each NIC port includes the following operations:</p>
<ul class="simple">
<li><p>Allocate PCI resources</p></li>
<li><p>Reset the hardware (issue a Global Reset) to a well-known default state</p></li>
<li><p>Set up the PHY and the link</p></li>
<li><p>Initialize statistics counters</p></li>
</ul>
<p>The PMD API must also export functions to start/stop the all-multicast feature of a port and functions to set/unset the port in promiscuous mode.</p>
<p>Some hardware offload features must be individually configured at port initialization through specific configuration parameters.
This is the case for the Receive Side Scaling (RSS) and Data Center Bridging (DCB) features for example.</p>
</div>
<div class="section" id="on-the-fly-configuration">
<h3><span class="section-number">11.4.4. </span>On-the-Fly Configuration</h3>
<p>All device features that can be started or stopped “on the fly” (that is, without stopping the device) do not require the PMD API to export dedicated functions for this purpose.</p>
<p>All that is required is the mapping address of the device PCI registers to implement the configuration of these features in specific functions outside of the drivers.</p>
<p>For this purpose,
the PMD API exports a function that provides all the information associated with a device that can be used to set up a given device feature outside of the driver.
This includes the PCI vendor identifier, the PCI device identifier, the mapping address of the PCI device registers, and the name of the driver.</p>
<p>The main advantage of this approach is that it gives complete freedom on the choice of the API used to configure, to start, and to stop such features.</p>
<p>As an example, refer to the configuration of the IEEE1588 feature for the Intel® 82576 Gigabit Ethernet Controller and
the Intel® 82599 10 Gigabit Ethernet Controller controllers in the testpmd application.</p>
<p>Other features such as the L3/L4 5-Tuple packet filtering feature of a port can be configured in the same way.
Ethernet* flow control (pause frame) can be configured on the individual port.
Refer to the testpmd source code for details.
Also, L4 (UDP/TCP/ SCTP) checksum offload by the NIC can be enabled for an individual packet as long as the packet mbuf is set up correctly. See <a class="reference internal" href="#hardware-offload">Hardware Offload</a> for details.</p>
</div>
<div class="section" id="configuration-of-transmit-queues">
<h3><span class="section-number">11.4.5. </span>Configuration of Transmit Queues</h3>
<p>Each transmit queue is independently configured with the following information:</p>
<ul class="simple">
<li><p>The number of descriptors of the transmit ring</p></li>
<li><p>The socket identifier used to identify the appropriate DMA memory zone from which to allocate the transmit ring in NUMA architectures</p></li>
<li><p>The values of the Prefetch, Host and Write-Back threshold registers of the transmit queue</p></li>
<li><p>The <em>minimum</em> transmit packets to free threshold (tx_free_thresh).
When the number of descriptors used to transmit packets exceeds this threshold, the network adaptor should be checked to see if it has written back descriptors.
A value of 0 can be passed during the TX queue configuration to indicate the default value should be used.
The default value for tx_free_thresh is 32.
This ensures that the PMD does not search for completed descriptors until at least 32 have been processed by the NIC for this queue.</p></li>
<li><p>The <em>minimum</em>  RS bit threshold. The minimum number of transmit descriptors to use before setting the Report Status (RS) bit in the transmit descriptor.
Note that this parameter may only be valid for Intel 10 GbE network adapters.
The RS bit is set on the last descriptor used to transmit a packet if the number of descriptors used since the last RS bit setting,
up to the first descriptor used to transmit the packet, exceeds the transmit RS bit threshold (tx_rs_thresh).
In short, this parameter controls which transmit descriptors are written back to host memory by the network adapter.
A value of 0 can be passed during the TX queue configuration to indicate that the default value should be used.
The default value for tx_rs_thresh is 32.
This ensures that at least 32 descriptors are used before the network adapter writes back the most recently used descriptor.
This saves upstream PCIe* bandwidth resulting from TX descriptor write-backs.
It is important to note that the TX Write-back threshold (TX wthresh) should be set to 0 when tx_rs_thresh is greater than 1.
Refer to the Intel® 82599 10 Gigabit Ethernet Controller Datasheet for more details.</p></li>
</ul>
<p>The following constraints must be satisfied for tx_free_thresh and tx_rs_thresh:</p>
<ul class="simple">
<li><p>tx_rs_thresh must be greater than 0.</p></li>
<li><p>tx_rs_thresh must be less than the size of the ring minus 2.</p></li>
<li><p>tx_rs_thresh must be less than or equal to tx_free_thresh.</p></li>
<li><p>tx_free_thresh must be greater than 0.</p></li>
<li><p>tx_free_thresh must be less than the size of the ring minus 3.</p></li>
<li><p>For optimal performance, TX wthresh should be set to 0 when tx_rs_thresh is greater than 1.</p></li>
</ul>
<p>One descriptor in the TX ring is used as a sentinel to avoid a hardware race condition, hence the maximum threshold constraints.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When configuring for DCB operation, at port initialization, both the number of transmit queues and the number of receive queues must be set to 128.</p>
</div>
</div>
<div class="section" id="free-tx-mbuf-on-demand">
<h3><span class="section-number">11.4.6. </span>Free Tx mbuf on Demand</h3>
<p>Many of the drivers do not release the mbuf back to the mempool, or local cache,
immediately after the packet has been transmitted.
Instead, they leave the mbuf in their Tx ring and
either perform a bulk release when the <code class="docutils literal notranslate"><span class="pre">tx_rs_thresh</span></code> has been crossed
or free the mbuf when a slot in the Tx ring is needed.</p>
<p>An application can request the driver to release used mbufs with the <code class="docutils literal notranslate"><span class="pre">rte_eth_tx_done_cleanup()</span></code> API.
This API requests the driver to release mbufs that are no longer in use,
independent of whether or not the <code class="docutils literal notranslate"><span class="pre">tx_rs_thresh</span></code> has been crossed.
There are two scenarios when an application may want the mbuf released immediately:</p>
<ul class="simple">
<li><p>When a given packet needs to be sent to multiple destination interfaces
(either for Layer 2 flooding or Layer 3 multi-cast).
One option is to make a copy of the packet or a copy of the header portion that needs to be manipulated.
A second option is to transmit the packet and then poll the <code class="docutils literal notranslate"><span class="pre">rte_eth_tx_done_cleanup()</span></code> API
until the reference count on the packet is decremented.
Then the same packet can be transmitted to the next destination interface.
The application is still responsible for managing any packet manipulations needed
between the different destination interfaces, but a packet copy can be avoided.
This API is independent of whether the packet was transmitted or dropped,
only that the mbuf is no longer in use by the interface.</p></li>
<li><p>Some applications are designed to make multiple runs, like a packet generator.
For performance reasons and consistency between runs,
the application may want to reset back to an initial state
between each run, where all mbufs are returned to the mempool.
In this case, it can call the <code class="docutils literal notranslate"><span class="pre">rte_eth_tx_done_cleanup()</span></code> API
for each destination interface it has been using
to request it to release of all its used mbufs.</p></li>
</ul>
<p>To determine if a driver supports this API, check for the <em>Free Tx mbuf on demand</em> feature
in the <em>Network Interface Controller Drivers</em> document.</p>
</div>
<div class="section" id="hardware-offload">
<h3><span class="section-number">11.4.7. </span>Hardware Offload</h3>
<p>Depending on driver capabilities advertised by
<code class="docutils literal notranslate"><span class="pre">rte_eth_dev_info_get()</span></code>, the PMD may support hardware offloading
feature like checksumming, TCP segmentation, VLAN insertion or
lockfree multithreaded TX burst on the same TX queue.</p>
<p>The support of these offload features implies the addition of dedicated
status bit(s) and value field(s) into the rte_mbuf data structure, along
with their appropriate handling by the receive/transmit functions
exported by each PMD. The list of flags and their precise meaning is
described in the mbuf API documentation and in the in <a class="reference internal" href="mbuf_lib.html#mbuf-library"><span class="std std-ref">Mbuf Library</span></a>, section “Meta Information”.</p>
<div class="section" id="per-port-and-per-queue-offloads">
<h4><span class="section-number">11.4.7.1. </span>Per-Port and Per-Queue Offloads</h4>
<p>In the DPDK offload API, offloads are divided into per-port and per-queue offloads as follows:</p>
<ul class="simple">
<li><p>A per-queue offloading can be enabled on a queue and disabled on another queue at the same time.</p></li>
<li><p>A pure per-port offload is the one supported by device but not per-queue type.</p></li>
<li><p>A pure per-port offloading can’t be enabled on a queue and disabled on another queue at the same time.</p></li>
<li><p>A pure per-port offloading must be enabled or disabled on all queues at the same time.</p></li>
<li><p>Any offloading is per-queue or pure per-port type, but can’t be both types at same devices.</p></li>
<li><p>Port capabilities = per-queue capabilities + pure per-port capabilities.</p></li>
<li><p>Any supported offloading can be enabled on all queues.</p></li>
</ul>
<p>The different offloads capabilities can be queried using <code class="docutils literal notranslate"><span class="pre">rte_eth_dev_info_get()</span></code>.
The <code class="docutils literal notranslate"><span class="pre">dev_info-&gt;[rt]x_queue_offload_capa</span></code> returned from <code class="docutils literal notranslate"><span class="pre">rte_eth_dev_info_get()</span></code> includes all per-queue offloading capabilities.
The <code class="docutils literal notranslate"><span class="pre">dev_info-&gt;[rt]x_offload_capa</span></code> returned from <code class="docutils literal notranslate"><span class="pre">rte_eth_dev_info_get()</span></code> includes all pure per-port and per-queue offloading capabilities.
Supported offloads can be either per-port or per-queue.</p>
<p>Offloads are enabled using the existing <code class="docutils literal notranslate"><span class="pre">DEV_TX_OFFLOAD_*</span></code> or <code class="docutils literal notranslate"><span class="pre">DEV_RX_OFFLOAD_*</span></code> flags.
Any requested offloading by an application must be within the device capabilities.
Any offloading is disabled by default if it is not set in the parameter
<code class="docutils literal notranslate"><span class="pre">dev_conf-&gt;[rt]xmode.offloads</span></code> to <code class="docutils literal notranslate"><span class="pre">rte_eth_dev_configure()</span></code> and
<code class="docutils literal notranslate"><span class="pre">[rt]x_conf-&gt;offloads</span></code> to <code class="docutils literal notranslate"><span class="pre">rte_eth_[rt]x_queue_setup()</span></code>.</p>
<p>If any offloading is enabled in <code class="docutils literal notranslate"><span class="pre">rte_eth_dev_configure()</span></code> by an application,
it is enabled on all queues no matter whether it is per-queue or
per-port type and no matter whether it is set or cleared in
<code class="docutils literal notranslate"><span class="pre">[rt]x_conf-&gt;offloads</span></code> to <code class="docutils literal notranslate"><span class="pre">rte_eth_[rt]x_queue_setup()</span></code>.</p>
<p>If a per-queue offloading hasn’t been enabled in <code class="docutils literal notranslate"><span class="pre">rte_eth_dev_configure()</span></code>,
it can be enabled or disabled in <code class="docutils literal notranslate"><span class="pre">rte_eth_[rt]x_queue_setup()</span></code> for individual queue.
A newly added offloads in <code class="docutils literal notranslate"><span class="pre">[rt]x_conf-&gt;offloads</span></code> to <code class="docutils literal notranslate"><span class="pre">rte_eth_[rt]x_queue_setup()</span></code> input by application
is the one which hasn’t been enabled in <code class="docutils literal notranslate"><span class="pre">rte_eth_dev_configure()</span></code> and is requested to be enabled
in <code class="docutils literal notranslate"><span class="pre">rte_eth_[rt]x_queue_setup()</span></code>. It must be per-queue type, otherwise trigger an error log.</p>
</div>
</div>
</div>
<div class="section" id="poll-mode-driver-api">
<h2><span class="section-number">11.5. </span>Poll Mode Driver API</h2>
<div class="section" id="generalities">
<h3><span class="section-number">11.5.1. </span>Generalities</h3>
<p>By default, all functions exported by a PMD are lock-free functions that are assumed
not to be invoked in parallel on different logical cores to work on the same target object.
For instance, a PMD receive function cannot be invoked in parallel on two logical cores to poll the same RX queue of the same port.
Of course, this function can be invoked in parallel by different logical cores on different RX queues.
It is the responsibility of the upper-level application to enforce this rule.</p>
<p>If needed, parallel accesses by multiple logical cores to shared queues can be explicitly protected by dedicated inline lock-aware functions
built on top of their corresponding lock-free functions of the PMD API.</p>
</div>
<div class="section" id="generic-packet-representation">
<h3><span class="section-number">11.5.2. </span>Generic Packet Representation</h3>
<p>A packet is represented by an rte_mbuf structure, which is a generic metadata structure containing all necessary housekeeping information.
This includes fields and status bits corresponding to offload hardware features, such as checksum computation of IP headers or VLAN tags.</p>
<p>The rte_mbuf data structure includes specific fields to represent, in a generic way, the offload features provided by network controllers.
For an input packet, most fields of the rte_mbuf structure are filled in by the PMD receive function with the information contained in the receive descriptor.
Conversely, for output packets, most fields of rte_mbuf structures are used by the PMD transmit function to initialize transmit descriptors.</p>
<p>The mbuf structure is fully described in the <a class="reference internal" href="mbuf_lib.html#mbuf-library"><span class="std std-ref">Mbuf Library</span></a> chapter.</p>
</div>
<div class="section" id="ethernet-device-api">
<h3><span class="section-number">11.5.3. </span>Ethernet Device API</h3>
<p>The Ethernet device API exported by the Ethernet PMDs is described in the <em>DPDK API Reference</em>.</p>
</div>
<div class="section" id="ethernet-device-standard-device-arguments">
<span id="id2"></span><h3><span class="section-number">11.5.4. </span>Ethernet Device Standard Device Arguments</h3>
<p>Standard Ethernet device arguments allow for a set of commonly used arguments/
parameters which are applicable to all Ethernet devices to be available to for
specification of specific device and for passing common configuration
parameters to those ports.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">representor</span></code> for a device which supports the creation of representor ports
this argument allows user to specify which switch ports to enable port
representors for.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-a DBDF,representor=0
-a DBDF,representor=[0,4,6,9]
-a DBDF,representor=[0-31]
</pre></div>
</div>
</li>
</ul>
<p>Note: PMDs are not required to support the standard device arguments and users
should consult the relevant PMD documentation to see support devargs.</p>
</div>
<div class="section" id="extended-statistics-api">
<h3><span class="section-number">11.5.5. </span>Extended Statistics API</h3>
<p>The extended statistics API allows a PMD to expose all statistics that are
available to it, including statistics that are unique to the device.
Each statistic has three properties <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">value</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: A human readable string formatted by the scheme detailed below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code>: An integer that represents only that statistic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: A unsigned 64-bit integer that is the value of the statistic.</p></li>
</ul>
<p>Note that extended statistic identifiers are
driver-specific, and hence might not be the same for different ports.
The API consists of various <code class="docutils literal notranslate"><span class="pre">rte_eth_xstats_*()</span></code> functions, and allows an
application to be flexible in how it retrieves statistics.</p>
<div class="section" id="scheme-for-human-readable-names">
<h4><span class="section-number">11.5.5.1. </span>Scheme for Human Readable Names</h4>
<p>A naming scheme exists for the strings exposed to clients of the API. This is
to allow scraping of the API for statistics of interest. The naming scheme uses
strings split by a single underscore <code class="docutils literal notranslate"><span class="pre">_</span></code>. The scheme is as follows:</p>
<ul class="simple">
<li><p>direction</p></li>
<li><p>detail 1</p></li>
<li><p>detail 2</p></li>
<li><p>detail n</p></li>
<li><p>unit</p></li>
</ul>
<p>Examples of common statistics xstats strings, formatted to comply to the scheme
proposed above:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rx_bytes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rx_crc_errors</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tx_multicast_packets</span></code></p></li>
</ul>
<p>The scheme, although quite simple, allows flexibility in presenting and reading
information from the statistic strings. The following example illustrates the
naming scheme:<code class="docutils literal notranslate"><span class="pre">rx_packets</span></code>. In this example, the string is split into two
components. The first component <code class="docutils literal notranslate"><span class="pre">rx</span></code> indicates that the statistic is
associated with the receive side of the NIC.  The second component <code class="docutils literal notranslate"><span class="pre">packets</span></code>
indicates that the unit of measure is packets.</p>
<p>A more complicated example: <code class="docutils literal notranslate"><span class="pre">tx_size_128_to_255_packets</span></code>. In this example,
<code class="docutils literal notranslate"><span class="pre">tx</span></code> indicates transmission, <code class="docutils literal notranslate"><span class="pre">size</span></code>  is the first detail, <code class="docutils literal notranslate"><span class="pre">128</span></code> etc are
more details, and <code class="docutils literal notranslate"><span class="pre">packets</span></code> indicates that this is a packet counter.</p>
<p>Some additions in the metadata scheme are as follows:</p>
<ul class="simple">
<li><p>If the first part does not match <code class="docutils literal notranslate"><span class="pre">rx</span></code> or <code class="docutils literal notranslate"><span class="pre">tx</span></code>, the statistic does not
have an affinity with either receive of transmit.</p></li>
<li><p>If the first letter of the second part is <code class="docutils literal notranslate"><span class="pre">q</span></code> and this <code class="docutils literal notranslate"><span class="pre">q</span></code> is followed
by a number, this statistic is part of a specific queue.</p></li>
</ul>
<p>An example where queue numbers are used is as follows: <code class="docutils literal notranslate"><span class="pre">tx_q7_bytes</span></code> which
indicates this statistic applies to queue number 7, and represents the number
of transmitted bytes on that queue.</p>
</div>
<div class="section" id="api-design">
<h4><span class="section-number">11.5.5.2. </span>API Design</h4>
<p>The xstats API uses the <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">id</span></code>, and <code class="docutils literal notranslate"><span class="pre">value</span></code> to allow performant
lookup of specific statistics. Performant lookup means two things;</p>
<ul class="simple">
<li><p>No string comparisons with the <code class="docutils literal notranslate"><span class="pre">name</span></code> of the statistic in fast-path</p></li>
<li><p>Allow requesting of only the statistics of interest</p></li>
</ul>
<p>The API ensures these requirements are met by mapping the <code class="docutils literal notranslate"><span class="pre">name</span></code> of the
statistic to a unique <code class="docutils literal notranslate"><span class="pre">id</span></code>, which is used as a key for lookup in the fast-path.
The API allows applications to request an array of <code class="docutils literal notranslate"><span class="pre">id</span></code> values, so that the
PMD only performs the required calculations. Expected usage is that the
application scans the <code class="docutils literal notranslate"><span class="pre">name</span></code> of each statistic, and caches the <code class="docutils literal notranslate"><span class="pre">id</span></code>
if it has an interest in that statistic. On the fast-path, the integer can be used
to retrieve the actual <code class="docutils literal notranslate"><span class="pre">value</span></code> of the statistic that the <code class="docutils literal notranslate"><span class="pre">id</span></code> represents.</p>
</div>
<div class="section" id="api-functions">
<h4><span class="section-number">11.5.5.3. </span>API Functions</h4>
<p>The API is built out of a small number of functions, which can be used to
retrieve the number of statistics and the names, IDs and values of those
statistics.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rte_eth_xstats_get_names_by_id()</span></code>: returns the names of the statistics. When given a
<code class="docutils literal notranslate"><span class="pre">NULL</span></code> parameter the function returns the number of statistics that are available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rte_eth_xstats_get_id_by_name()</span></code>: Searches for the statistic ID that matches
<code class="docutils literal notranslate"><span class="pre">xstat_name</span></code>. If found, the <code class="docutils literal notranslate"><span class="pre">id</span></code> integer is set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rte_eth_xstats_get_by_id()</span></code>: Fills in an array of <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code> values
with matching the provided <code class="docutils literal notranslate"><span class="pre">ids</span></code> array. If the <code class="docutils literal notranslate"><span class="pre">ids</span></code> array is NULL, it
returns all statistics that are available.</p></li>
</ul>
</div>
<div class="section" id="application-usage">
<h4><span class="section-number">11.5.5.4. </span>Application Usage</h4>
<p>Imagine an application that wants to view the dropped packet count. If no
packets are dropped, the application does not read any other metrics for
performance reasons. If packets are dropped, the application has a particular
set of statistics that it requests. This “set” of statistics allows the app to
decide what next steps to perform. The following code-snippets show how the
xstats API can be used to achieve this goal.</p>
<p>First step is to get all statistics names and list them:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">rte_eth_xstat_name</span> <span class="o">*</span><span class="n">xstats_names</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="o">*</span><span class="n">values</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

<span class="cm">/* Get number of stats */</span>
<span class="n">len</span> <span class="o">=</span> <span class="n">rte_eth_xstats_get_names_by_id</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot get xstats count</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">xstats_names</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rte_eth_xstat_name</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">xstats_names</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot allocate memory for xstat names</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Retrieve xstats names, passing NULL for IDs to return all statistics */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">rte_eth_xstats_get_names_by_id</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="n">xstats_names</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot get xstat names</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">values</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">values</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot allocate memory for xstats</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Getting xstats values */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">!=</span> <span class="n">rte_eth_xstats_get_by_id</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot get xstat values</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Print all xstats names and values */</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: %&quot;</span><span class="n">PRIu64</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xstats_names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The application has access to the names of all of the statistics that the PMD
exposes. The application can decide which statistics are of interest, cache the
ids of those statistics by looking up the name as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span> <span class="n">id</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">value</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">xstat_name</span> <span class="o">=</span> <span class="s">&quot;rx_errors&quot;</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rte_eth_xstats_get_id_by_name</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="n">xstat_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">rte_eth_xstats_get_by_id</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: %&quot;</span><span class="n">PRIu64</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">xstat_name</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot find xstats with a given name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The API provides flexibility to the application so that it can look up multiple
statistics using an array containing multiple <code class="docutils literal notranslate"><span class="pre">id</span></code> numbers. This reduces the
function call overhead of retrieving statistics, and makes lookup of multiple
statistics simpler for the application.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define APP_NUM_STATS 4</span>
<span class="cm">/* application cached these ids previously; see above */</span>
<span class="kt">uint64_t</span> <span class="n">ids_array</span><span class="p">[</span><span class="n">APP_NUM_STATS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">21</span><span class="p">};</span>
<span class="kt">uint64_t</span> <span class="n">value_array</span><span class="p">[</span><span class="n">APP_NUM_STATS</span><span class="p">];</span>

<span class="cm">/* Getting multiple xstats values from array of IDs */</span>
<span class="n">rte_eth_xstats_get_by_id</span><span class="p">(</span><span class="n">port_id</span><span class="p">,</span> <span class="n">ids_array</span><span class="p">,</span> <span class="n">value_array</span><span class="p">,</span> <span class="n">APP_NUM_STATS</span><span class="p">);</span>

<span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">APP_NUM_STATS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d: %&quot;</span><span class="n">PRIu64</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ids_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">value_array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This array lookup API for xstats allows the application create multiple
“groups” of statistics, and look up the values of those IDs using a single API
call. As an end result, the application is able to achieve its goal of
monitoring a single statistic (“rx_errors” in this case), and if that shows
packets being dropped, it can easily retrieve a “set” of statistics using the
IDs array parameter to <code class="docutils literal notranslate"><span class="pre">rte_eth_xstats_get_by_id</span></code> function.</p>
</div>
</div>
<div class="section" id="nic-reset-api">
<h3><span class="section-number">11.5.6. </span>NIC Reset API</h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">rte_eth_dev_reset</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">port_id</span><span class="p">);</span>
</pre></div>
</div>
<p>Sometimes a port has to be reset passively. For example when a PF is
reset, all its VFs should also be reset by the application to make them
consistent with the PF. A DPDK application also can call this function
to trigger a port reset. Normally, a DPDK application would invokes this
function when an RTE_ETH_EVENT_INTR_RESET event is detected.</p>
<p>It is the duty of the PMD to trigger RTE_ETH_EVENT_INTR_RESET events and
the application should register a callback function to handle these
events. When a PMD needs to trigger a reset, it can trigger an
RTE_ETH_EVENT_INTR_RESET event. On receiving an RTE_ETH_EVENT_INTR_RESET
event, applications can handle it as follows: Stop working queues, stop
calling Rx and Tx functions, and then call rte_eth_dev_reset(). For
thread safety all these operations should be called from the same thread.</p>
<p>For example when PF is reset, the PF sends a message to notify VFs of
this event and also trigger an interrupt to VFs. Then in the interrupt
service routine the VFs detects this notification message and calls
rte_eth_dev_callback_process(dev, RTE_ETH_EVENT_INTR_RESET, NULL).
This means that a PF reset triggers an RTE_ETH_EVENT_INTR_RESET
event within VFs. The function rte_eth_dev_callback_process() will
call the registered callback function. The callback function can trigger
the application to handle all operations the VF reset requires including
stopping Rx/Tx queues and calling rte_eth_dev_reset().</p>
<p>The rte_eth_dev_reset() itself is a generic function which only does
some hardware reset operations through calling dev_unint() and
dev_init(), and itself does not handle synchronization, which is handled
by application.</p>
<p>The PMD itself should not call rte_eth_dev_reset(). The PMD can trigger
the application to handle reset event. It is duty of application to
handle all synchronization before it calls rte_eth_dev_reset().</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="rte_flow.html" class="btn btn-neutral float-right" title="12. Generic flow API (rte_flow)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="mbuf_lib.html" class="btn btn-neutral float-left" title="10. Mbuf Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>