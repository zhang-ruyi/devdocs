<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.20">
  <title>SPDK: thread.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('thread_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">thread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__io__channel.html">spdk_io_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a per-thread channel for accessing an I/O device.  <a href="structspdk__io__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a17cf88195e46bb118ac03528f7f5eee0"><td class="memItemLeft" align="right" valign="top"><a id="a17cf88195e46bb118ac03528f7f5eee0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_POLLER_REGISTER</b>(fn,  arg,  period_microseconds)&#160;&#160;&#160;	<a class="el" href="thread_8h.html#a4e1086db1bd40b0a1720bd148967d82d">spdk_poller_register_named</a>(fn, arg, period_microseconds, #fn)</td></tr>
<tr class="separator:a17cf88195e46bb118ac03528f7f5eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15064b1cd3d036753e04c5c207ad71d"><td class="memItemLeft" align="right" valign="top"><a id="ac15064b1cd3d036753e04c5c207ad71d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_INTERRUPT_REGISTER</b>(efd,  fn,  arg)&#160;&#160;&#160;	<a class="el" href="thread_8h.html#aae58fe1101803d60c523891e7540a23c">spdk_interrupt_register</a>(efd, fn, arg, #fn)</td></tr>
<tr class="separator:ac15064b1cd3d036753e04c5c207ad71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afab3d4339c5bca4dfde209816a9e560f"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a>) (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:afab3d4339c5bca4dfde209816a9e560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that is called each time a new thread is created.  <a href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">More...</a><br /></td></tr>
<tr class="separator:afab3d4339c5bca4dfde209816a9e560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0ad3a2bcbb6d304401b579ab63aeba"><td class="memItemLeft" align="right" valign="top"><a id="a9f0ad3a2bcbb6d304401b579ab63aeba"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9f0ad3a2bcbb6d304401b579ab63aeba">spdk_thread_op_fn</a>) (struct spdk_thread *thread, enum <a class="el" href="thread_8h.html#aa0d064c5b2e0268ad751a682fa8ed6a6">spdk_thread_op</a> op)</td></tr>
<tr class="memdesc:a9f0ad3a2bcbb6d304401b579ab63aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called for SPDK thread operation. <br /></td></tr>
<tr class="separator:a9f0ad3a2bcbb6d304401b579ab63aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af791c24e496b96c886fe8bad088eb0cb"><td class="memItemLeft" align="right" valign="top"><a id="af791c24e496b96c886fe8bad088eb0cb"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af791c24e496b96c886fe8bad088eb0cb">spdk_thread_op_supported_fn</a>) (enum <a class="el" href="thread_8h.html#aa0d064c5b2e0268ad751a682fa8ed6a6">spdk_thread_op</a> op)</td></tr>
<tr class="memdesc:af791c24e496b96c886fe8bad088eb0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check whether the SPDK thread operation is supported. <br /></td></tr>
<tr class="separator:af791c24e496b96c886fe8bad088eb0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0da6b1b784d4f165dcd48b526d12ad"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:adc0da6b1b784d4f165dcd48b526d12ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that will be called on the target thread.  <a href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">More...</a><br /></td></tr>
<tr class="separator:adc0da6b1b784d4f165dcd48b526d12ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4a0e155fc3fa0150aa4a505dd1801e91">spdk_thread_pass_msg</a>) (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, void *thread_ctx)</td></tr>
<tr class="memdesc:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called to pass a message to a thread.  <a href="thread_8h.html#a4a0e155fc3fa0150aa4a505dd1801e91">More...</a><br /></td></tr>
<tr class="separator:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c421accdc2a0a61bb7be916106293b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:a35c421accdc2a0a61bb7be916106293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for a poller.  <a href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">More...</a><br /></td></tr>
<tr class="separator:a35c421accdc2a0a61bb7be916106293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f70f5e9b4d498e843f81f1a6ada6370"><td class="memItemLeft" align="right" valign="top">typedef struct spdk_poller *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6f70f5e9b4d498e843f81f1a6ada6370">spdk_start_poller</a>) (void *thread_ctx, <a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds)</td></tr>
<tr class="memdesc:a6f70f5e9b4d498e843f81f1a6ada6370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called to start a poller for the thread.  <a href="thread_8h.html#a6f70f5e9b4d498e843f81f1a6ada6370">More...</a><br /></td></tr>
<tr class="separator:a6f70f5e9b4d498e843f81f1a6ada6370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfddbbbb13145f26741106cb8296a05a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adfddbbbb13145f26741106cb8296a05a">spdk_stop_poller</a>) (struct spdk_poller *poller, void *thread_ctx)</td></tr>
<tr class="memdesc:adfddbbbb13145f26741106cb8296a05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called to stop a poller.  <a href="thread_8h.html#adfddbbbb13145f26741106cb8296a05a">More...</a><br /></td></tr>
<tr class="separator:adfddbbbb13145f26741106cb8296a05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1d14292cfee8553d4a1ebb519b210a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a>) (void *io_device, void *ctx_buf)</td></tr>
<tr class="memdesc:aed1d14292cfee8553d4a1ebb519b210a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O channel creation callback.  <a href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">More...</a><br /></td></tr>
<tr class="separator:aed1d14292cfee8553d4a1ebb519b210a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa6a61877f23f79bb75c8fc5e68202"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a>) (void *io_device, void *ctx_buf)</td></tr>
<tr class="memdesc:a75aa6a61877f23f79bb75c8fc5e68202"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O channel destruction callback.  <a href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">More...</a><br /></td></tr>
<tr class="separator:a75aa6a61877f23f79bb75c8fc5e68202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae044f4141737c7f2df49cdfb03fd58ca"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a>) (void *io_device)</td></tr>
<tr class="memdesc:ae044f4141737c7f2df49cdfb03fd58ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O device unregister callback.  <a href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">More...</a><br /></td></tr>
<tr class="separator:ae044f4141737c7f2df49cdfb03fd58ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a>) (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the appropriate thread for each channel associated with io_device.  <a href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">More...</a><br /></td></tr>
<tr class="separator:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f03fe115196f1de03292ed6d86fd46"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a>) (struct spdk_io_channel_iter *i, int status)</td></tr>
<tr class="memdesc:a96f03fe115196f1de03292ed6d86fd46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device.">spdk_for_each_channel()</a> callback.  <a href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">More...</a><br /></td></tr>
<tr class="separator:a96f03fe115196f1de03292ed6d86fd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cfdc77d10970d7f3a8631df71e9588"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a61cfdc77d10970d7f3a8631df71e9588">spdk_interrupt_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:a61cfdc77d10970d7f3a8631df71e9588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function registered for interrupt file descriptor.  <a href="thread_8h.html#a61cfdc77d10970d7f3a8631df71e9588">More...</a><br /></td></tr>
<tr class="separator:a61cfdc77d10970d7f3a8631df71e9588"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9df2d253885de944794d6810ff98fc4e"><td class="memItemLeft" align="right" valign="top"><a id="a9df2d253885de944794d6810ff98fc4e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_thread_poller_rc</b> { <b>SPDK_POLLER_IDLE</b>, 
<b>SPDK_POLLER_BUSY</b>
 }</td></tr>
<tr class="separator:a9df2d253885de944794d6810ff98fc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d064c5b2e0268ad751a682fa8ed6a6"><td class="memItemLeft" align="right" valign="top"><a id="aa0d064c5b2e0268ad751a682fa8ed6a6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa0d064c5b2e0268ad751a682fa8ed6a6">spdk_thread_op</a> { <b>SPDK_THREAD_OP_NEW</b>, 
<b>SPDK_THREAD_OP_RESCHED</b>
 }</td></tr>
<tr class="memdesc:aa0d064c5b2e0268ad751a682fa8ed6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPDK thread operation type. <br /></td></tr>
<tr class="separator:aa0d064c5b2e0268ad751a682fa8ed6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3b860a0c3ec1fb4f1e6743b1d746b6"><td class="memItemLeft" align="right" valign="top"><a id="a9f3b860a0c3ec1fb4f1e6743b1d746b6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_interrupt_event_types</b> { <b>SPDK_INTERRUPT_EVENT_IN</b> = 0x001, 
<b>SPDK_INTERRUPT_EVENT_OUT</b> = 0x004, 
<b>SPDK_INTERRUPT_EVENT_ET</b> = 1u &lt;&lt; 31
 }</td></tr>
<tr class="separator:a9f3b860a0c3ec1fb4f1e6743b1d746b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a96c6e1cadb3b5a83c5723487e3f02c23">spdk_thread_lib_init</a> (<a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a> new_thread_fn, size_t ctx_sz)</td></tr>
<tr class="memdesc:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the threading library.  <a href="thread_8h.html#a96c6e1cadb3b5a83c5723487e3f02c23">More...</a><br /></td></tr>
<tr class="separator:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820faedd428f6e689ecb28d721a8d0bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a820faedd428f6e689ecb28d721a8d0bf">spdk_thread_lib_init_ext</a> (<a class="el" href="thread_8h.html#a9f0ad3a2bcbb6d304401b579ab63aeba">spdk_thread_op_fn</a> thread_op_fn, <a class="el" href="thread_8h.html#af791c24e496b96c886fe8bad088eb0cb">spdk_thread_op_supported_fn</a> thread_op_supported_fn, size_t ctx_sz)</td></tr>
<tr class="memdesc:a820faedd428f6e689ecb28d721a8d0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the threading library.  <a href="thread_8h.html#a820faedd428f6e689ecb28d721a8d0bf">More...</a><br /></td></tr>
<tr class="separator:a820faedd428f6e689ecb28d721a8d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe409bf16664f461daa516b6a6d1682c"><td class="memItemLeft" align="right" valign="top"><a id="afe409bf16664f461daa516b6a6d1682c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#afe409bf16664f461daa516b6a6d1682c">spdk_thread_lib_fini</a> (void)</td></tr>
<tr class="memdesc:afe409bf16664f461daa516b6a6d1682c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all resources associated with this library. <br /></td></tr>
<tr class="separator:afe409bf16664f461daa516b6a6d1682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eada7bac2a5c7ceaea891d57f8d3e21"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4eada7bac2a5c7ceaea891d57f8d3e21">spdk_thread_create</a> (const char *name, struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *cpumask)</td></tr>
<tr class="memdesc:a4eada7bac2a5c7ceaea891d57f8d3e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new SPDK thread object.  <a href="thread_8h.html#a4eada7bac2a5c7ceaea891d57f8d3e21">More...</a><br /></td></tr>
<tr class="separator:a4eada7bac2a5c7ceaea891d57f8d3e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a60dac2a0fc19b23be6fecb1e5b6f8a7a">spdk_set_thread</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the current system thread to act as if executing the given SPDK thread.  <a href="thread_8h.html#a60dac2a0fc19b23be6fecb1e5b6f8a7a">More...</a><br /></td></tr>
<tr class="separator:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5132d2abe39a40a0e14e19bb2bd15489"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5132d2abe39a40a0e14e19bb2bd15489">spdk_thread_exit</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a5132d2abe39a40a0e14e19bb2bd15489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the thread as exited, failing all future <a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec" title="Send a message to the given thread.">spdk_thread_send_msg()</a>, <a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126" title="Register a poller on the current thread.">spdk_poller_register()</a>, and <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread.">spdk_get_io_channel()</a> calls.  <a href="thread_8h.html#a5132d2abe39a40a0e14e19bb2bd15489">More...</a><br /></td></tr>
<tr class="separator:a5132d2abe39a40a0e14e19bb2bd15489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99859eb37714e4ed7c6110ea71ab142"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae99859eb37714e4ed7c6110ea71ab142">spdk_thread_is_exited</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ae99859eb37714e4ed7c6110ea71ab142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread is marked as exited.  <a href="thread_8h.html#ae99859eb37714e4ed7c6110ea71ab142">More...</a><br /></td></tr>
<tr class="separator:ae99859eb37714e4ed7c6110ea71ab142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a10aa5a8ec5228fa87db97f7655f8c0d6">spdk_thread_destroy</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a thread, releasing all of its resources.  <a href="thread_8h.html#a10aa5a8ec5228fa87db97f7655f8c0d6">More...</a><br /></td></tr>
<tr class="separator:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deb97a85a8240119cf46fa8a0b71388"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388">spdk_thread_get_ctx</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a1deb97a85a8240119cf46fa8a0b71388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to this thread's context.  <a href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388">More...</a><br /></td></tr>
<tr class="separator:a1deb97a85a8240119cf46fa8a0b71388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06d559046d570e025d6b67c7e8d507"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9f06d559046d570e025d6b67c7e8d507">spdk_thread_get_cpumask</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a9f06d559046d570e025d6b67c7e8d507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's cpumask.  <a href="thread_8h.html#a9f06d559046d570e025d6b67c7e8d507">More...</a><br /></td></tr>
<tr class="separator:a9f06d559046d570e025d6b67c7e8d507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c27f304a333a80bbdb48f1df12721f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a44c27f304a333a80bbdb48f1df12721f">spdk_thread_set_cpumask</a> (struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *cpumask)</td></tr>
<tr class="memdesc:a44c27f304a333a80bbdb48f1df12721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current thread's cpumask to the specified value.  <a href="thread_8h.html#a44c27f304a333a80bbdb48f1df12721f">More...</a><br /></td></tr>
<tr class="separator:a44c27f304a333a80bbdb48f1df12721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af813fe52c71ec5e254f8671570f57bdc"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af813fe52c71ec5e254f8671570f57bdc">spdk_thread_get_from_ctx</a> (void *ctx)</td></tr>
<tr class="memdesc:af813fe52c71ec5e254f8671570f57bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread object associated with the context handle previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a>.  <a href="thread_8h.html#af813fe52c71ec5e254f8671570f57bdc">More...</a><br /></td></tr>
<tr class="separator:af813fe52c71ec5e254f8671570f57bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e3693e8e9e6c9063ea36414294ae91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91">spdk_thread_poll</a> (struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)</td></tr>
<tr class="memdesc:ad9e3693e8e9e6c9063ea36414294ae91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one iteration worth of processing on the thread.  <a href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91">More...</a><br /></td></tr>
<tr class="separator:ad9e3693e8e9e6c9063ea36414294ae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474fcfc5c14928eda42c684ba2b4cba9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a474fcfc5c14928eda42c684ba2b4cba9">spdk_thread_next_poller_expiration</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a474fcfc5c14928eda42c684ba2b4cba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of ticks until the next timed poller would expire.  <a href="thread_8h.html#a474fcfc5c14928eda42c684ba2b4cba9">More...</a><br /></td></tr>
<tr class="separator:a474fcfc5c14928eda42c684ba2b4cba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5a143ecbc5ce7edcd57e76cffd74bde5">spdk_thread_has_active_pollers</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are any active pollers (pollers for which period_microseconds equals 0) registered to be run on the thread.  <a href="thread_8h.html#a5a143ecbc5ce7edcd57e76cffd74bde5">More...</a><br /></td></tr>
<tr class="separator:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f877dd192ccdd30572941aa4e453c48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9f877dd192ccdd30572941aa4e453c48">spdk_thread_has_pollers</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a9f877dd192ccdd30572941aa4e453c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are any pollers registered to be run on the thread.  <a href="thread_8h.html#a9f877dd192ccdd30572941aa4e453c48">More...</a><br /></td></tr>
<tr class="separator:a9f877dd192ccdd30572941aa4e453c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc45e09bda68d13cfc0ae010738cd658"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adc45e09bda68d13cfc0ae010738cd658">spdk_thread_is_idle</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:adc45e09bda68d13cfc0ae010738cd658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are scheduled operations to be run on the thread.  <a href="thread_8h.html#adc45e09bda68d13cfc0ae010738cd658">More...</a><br /></td></tr>
<tr class="separator:adc45e09bda68d13cfc0ae010738cd658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="memItemLeft" align="right" valign="top"><a id="a1d77f05c2461acb75f333e67e6aeb1ed"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1d77f05c2461acb75f333e67e6aeb1ed">spdk_thread_get_count</a> (void)</td></tr>
<tr class="memdesc:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get count of allocated threads. <br /></td></tr>
<tr class="separator:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34754a98debd5e095bf06889fbaed6aa"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a34754a98debd5e095bf06889fbaed6aa">spdk_get_thread</a> (void)</td></tr>
<tr class="memdesc:a34754a98debd5e095bf06889fbaed6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the current thread.  <a href="thread_8h.html#a34754a98debd5e095bf06889fbaed6aa">More...</a><br /></td></tr>
<tr class="separator:a34754a98debd5e095bf06889fbaed6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae367048fa89366e845d72015064e6f76"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae367048fa89366e845d72015064e6f76">spdk_thread_get_name</a> (const struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ae367048fa89366e845d72015064e6f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's name.  <a href="thread_8h.html#ae367048fa89366e845d72015064e6f76">More...</a><br /></td></tr>
<tr class="separator:ae367048fa89366e845d72015064e6f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead9239fedaf5af9f24b5614f6c0c8fb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aead9239fedaf5af9f24b5614f6c0c8fb">spdk_thread_get_id</a> (const struct spdk_thread *thread)</td></tr>
<tr class="memdesc:aead9239fedaf5af9f24b5614f6c0c8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's ID.  <a href="thread_8h.html#aead9239fedaf5af9f24b5614f6c0c8fb">More...</a><br /></td></tr>
<tr class="separator:aead9239fedaf5af9f24b5614f6c0c8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c90cd523aad947dad7e651074d9f1d"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a24c90cd523aad947dad7e651074d9f1d">spdk_thread_get_by_id</a> (uint64_t id)</td></tr>
<tr class="memdesc:a24c90cd523aad947dad7e651074d9f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread by the ID.  <a href="thread_8h.html#a24c90cd523aad947dad7e651074d9f1d">More...</a><br /></td></tr>
<tr class="separator:a24c90cd523aad947dad7e651074d9f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f07dd00b0b4140155713aca312d46b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab6f07dd00b0b4140155713aca312d46b">spdk_thread_get_stats</a> (struct <a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a> *stats)</td></tr>
<tr class="memdesc:ab6f07dd00b0b4140155713aca312d46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get statistics about the current thread.  <a href="thread_8h.html#ab6f07dd00b0b4140155713aca312d46b">More...</a><br /></td></tr>
<tr class="separator:ab6f07dd00b0b4140155713aca312d46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d7fd3db7cd91ff37c3898e69811f7a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae8d7fd3db7cd91ff37c3898e69811f7a">spdk_thread_get_last_tsc</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ae8d7fd3db7cd91ff37c3898e69811f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the TSC value from the end of the last time this thread was polled.  <a href="thread_8h.html#ae8d7fd3db7cd91ff37c3898e69811f7a">More...</a><br /></td></tr>
<tr class="separator:ae8d7fd3db7cd91ff37c3898e69811f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b662b152c21dad824ad2738d0733ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec">spdk_thread_send_msg</a> (const struct spdk_thread *thread, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx)</td></tr>
<tr class="memdesc:a07b662b152c21dad824ad2738d0733ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the given thread.  <a href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec">More...</a><br /></td></tr>
<tr class="separator:a07b662b152c21dad824ad2738d0733ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a91a7e9d44c2a332dfcea5e23df471c8d">spdk_thread_send_critical_msg</a> (struct spdk_thread *thread, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn)</td></tr>
<tr class="memdesc:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the given thread.  <a href="thread_8h.html#a91a7e9d44c2a332dfcea5e23df471c8d">More...</a><br /></td></tr>
<tr class="separator:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb098e6398d2a63577e805f1423a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a16bb098e6398d2a63577e805f1423a3e">spdk_for_each_thread</a> (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> cpl)</td></tr>
<tr class="memdesc:a16bb098e6398d2a63577e805f1423a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to each thread, serially.  <a href="thread_8h.html#a16bb098e6398d2a63577e805f1423a3e">More...</a><br /></td></tr>
<tr class="separator:a16bb098e6398d2a63577e805f1423a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3e883ddce01ae8d93541304d1e9126"><td class="memItemLeft" align="right" valign="top">struct spdk_poller *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126">spdk_poller_register</a> (<a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds)</td></tr>
<tr class="memdesc:a6b3e883ddce01ae8d93541304d1e9126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a poller on the current thread.  <a href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126">More...</a><br /></td></tr>
<tr class="separator:a6b3e883ddce01ae8d93541304d1e9126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1086db1bd40b0a1720bd148967d82d"><td class="memItemLeft" align="right" valign="top">struct spdk_poller *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4e1086db1bd40b0a1720bd148967d82d">spdk_poller_register_named</a> (<a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds, const char *name)</td></tr>
<tr class="memdesc:a4e1086db1bd40b0a1720bd148967d82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a poller on the current thread with arbitrary name.  <a href="thread_8h.html#a4e1086db1bd40b0a1720bd148967d82d">More...</a><br /></td></tr>
<tr class="separator:a4e1086db1bd40b0a1720bd148967d82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3">spdk_poller_unregister</a> (struct spdk_poller **ppoller)</td></tr>
<tr class="memdesc:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a poller on the current thread.  <a href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3">More...</a><br /></td></tr>
<tr class="separator:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a0f0c05dd1c9cb0b31eee89213b89f3c3">spdk_poller_pause</a> (struct spdk_poller *poller)</td></tr>
<tr class="memdesc:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a poller on the current thread.  <a href="thread_8h.html#a0f0c05dd1c9cb0b31eee89213b89f3c3">More...</a><br /></td></tr>
<tr class="separator:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3de0ffe9dfc29361b092d467d37017e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab3de0ffe9dfc29361b092d467d37017e">spdk_poller_resume</a> (struct spdk_poller *poller)</td></tr>
<tr class="memdesc:ab3de0ffe9dfc29361b092d467d37017e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a poller on the current thread.  <a href="thread_8h.html#ab3de0ffe9dfc29361b092d467d37017e">More...</a><br /></td></tr>
<tr class="separator:ab3de0ffe9dfc29361b092d467d37017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f5c71056d8c39ff05a6610d55edcf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5">spdk_io_device_register</a> (void *io_device, <a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a> create_cb, <a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a> destroy_cb, uint32_t ctx_size, const char *name)</td></tr>
<tr class="memdesc:a75f5c71056d8c39ff05a6610d55edcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the opaque io_device context as an I/O device.  <a href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5">More...</a><br /></td></tr>
<tr class="separator:a75f5c71056d8c39ff05a6610d55edcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6c3df3a611c10c176cb87966c622f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4c6c3df3a611c10c176cb87966c622f0">spdk_io_device_unregister</a> (void *io_device, <a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a> unregister_cb)</td></tr>
<tr class="memdesc:a4c6c3df3a611c10c176cb87966c622f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the opaque io_device context as an I/O device.  <a href="thread_8h.html#a4c6c3df3a611c10c176cb87966c622f0">More...</a><br /></td></tr>
<tr class="separator:a4c6c3df3a611c10c176cb87966c622f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8537c42a7aa203b50578efed509d9ba8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8">spdk_get_io_channel</a> (void *io_device)</td></tr>
<tr class="memdesc:a8537c42a7aa203b50578efed509d9ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an I/O channel for the specified io_device to be used by the calling thread.  <a href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8">More...</a><br /></td></tr>
<tr class="separator:a8537c42a7aa203b50578efed509d9ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717571a5011db0cdd730498146f25f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a717571a5011db0cdd730498146f25f9a">spdk_put_io_channel</a> (struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *ch)</td></tr>
<tr class="memdesc:a717571a5011db0cdd730498146f25f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference to an I/O channel.  <a href="thread_8h.html#a717571a5011db0cdd730498146f25f9a">More...</a><br /></td></tr>
<tr class="separator:a717571a5011db0cdd730498146f25f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf6e22252bc768003c7bbc165fc3c51"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adbf6e22252bc768003c7bbc165fc3c51">spdk_io_channel_get_ctx</a> (struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *ch)</td></tr>
<tr class="memdesc:adbf6e22252bc768003c7bbc165fc3c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context buffer associated with an I/O channel.  <a href="thread_8h.html#adbf6e22252bc768003c7bbc165fc3c51">More...</a><br /></td></tr>
<tr class="separator:adbf6e22252bc768003c7bbc165fc3c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9608b7b0fd448edec6ea5dd38ad04a57">spdk_io_channel_from_ctx</a> (void *ctx)</td></tr>
<tr class="memdesc:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I/O channel from the context buffer.  <a href="thread_8h.html#a9608b7b0fd448edec6ea5dd38ad04a57">More...</a><br /></td></tr>
<tr class="separator:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b">spdk_io_channel_get_thread</a> (struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *ch)</td></tr>
<tr class="memdesc:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread associated with an I/O channel.  <a href="thread_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b">More...</a><br /></td></tr>
<tr class="separator:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1">spdk_for_each_channel</a> (void *io_device, <a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a> fn, void *ctx, <a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a> cpl)</td></tr>
<tr class="memdesc:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call 'fn' on each channel associated with io_device.  <a href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1">More...</a><br /></td></tr>
<tr class="separator:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939935cee4dac6636f2b7c6db0b2fec1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a939935cee4dac6636f2b7c6db0b2fec1">spdk_io_channel_iter_get_io_device</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a939935cee4dac6636f2b7c6db0b2fec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get io_device from the I/O channel iterator.  <a href="thread_8h.html#a939935cee4dac6636f2b7c6db0b2fec1">More...</a><br /></td></tr>
<tr class="separator:a939935cee4dac6636f2b7c6db0b2fec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a83adef6c3df9568bdea346b8e7dcbaa5">spdk_io_channel_iter_get_channel</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I/O channel from the I/O channel iterator.  <a href="thread_8h.html#a83adef6c3df9568bdea346b8e7dcbaa5">More...</a><br /></td></tr>
<tr class="separator:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3ebaac7b55dddb239c720c80d97dea"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#add3ebaac7b55dddb239c720c80d97dea">spdk_io_channel_iter_get_ctx</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:add3ebaac7b55dddb239c720c80d97dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get context buffer from the I/O channel iterator.  <a href="thread_8h.html#add3ebaac7b55dddb239c720c80d97dea">More...</a><br /></td></tr>
<tr class="separator:add3ebaac7b55dddb239c720c80d97dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e87fc8c0fc870769c068a2752cdc359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4e87fc8c0fc870769c068a2752cdc359">spdk_for_each_channel_continue</a> (struct spdk_io_channel_iter *i, int status)</td></tr>
<tr class="memdesc:a4e87fc8c0fc870769c068a2752cdc359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to iterate all channels for <a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device.">spdk_for_each_channel()</a>.  <a href="thread_8h.html#a4e87fc8c0fc870769c068a2752cdc359">More...</a><br /></td></tr>
<tr class="separator:a4e87fc8c0fc870769c068a2752cdc359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae58fe1101803d60c523891e7540a23c"><td class="memItemLeft" align="right" valign="top">struct spdk_interrupt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aae58fe1101803d60c523891e7540a23c">spdk_interrupt_register</a> (int efd, <a class="el" href="thread_8h.html#a61cfdc77d10970d7f3a8631df71e9588">spdk_interrupt_fn</a> fn, void *arg, const char *name)</td></tr>
<tr class="memdesc:aae58fe1101803d60c523891e7540a23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an spdk_interrupt on the current thread.  <a href="thread_8h.html#aae58fe1101803d60c523891e7540a23c">More...</a><br /></td></tr>
<tr class="separator:aae58fe1101803d60c523891e7540a23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f3647a26ba93931beeb1782d39e56e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a45f3647a26ba93931beeb1782d39e56e">spdk_interrupt_unregister</a> (struct spdk_interrupt **pintr)</td></tr>
<tr class="memdesc:a45f3647a26ba93931beeb1782d39e56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an spdk_interrupt on the current thread.  <a href="thread_8h.html#a45f3647a26ba93931beeb1782d39e56e">More...</a><br /></td></tr>
<tr class="separator:a45f3647a26ba93931beeb1782d39e56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6665332ac6d7781f7944f5f471ce1a21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6665332ac6d7781f7944f5f471ce1a21">spdk_interrupt_set_event_types</a> (struct spdk_interrupt *intr, enum spdk_interrupt_event_types event_types)</td></tr>
<tr class="memdesc:a6665332ac6d7781f7944f5f471ce1a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the event_types associated with the spdk_interrupt on the current thread.  <a href="thread_8h.html#a6665332ac6d7781f7944f5f471ce1a21">More...</a><br /></td></tr>
<tr class="separator:a6665332ac6d7781f7944f5f471ce1a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b33abb26c349950555f71a34cf507c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6b33abb26c349950555f71a34cf507c6">spdk_thread_get_interrupt_fd</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a6b33abb26c349950555f71a34cf507c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a file descriptor that becomes ready whenever any of the registered interrupt file descriptors are ready.  <a href="thread_8h.html#a6b33abb26c349950555f71a34cf507c6">More...</a><br /></td></tr>
<tr class="separator:a6b33abb26c349950555f71a34cf507c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cac0f188b5f46ff8bcdd5d4ffa37e84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a0cac0f188b5f46ff8bcdd5d4ffa37e84">spdk_interrupt_mode_enable</a> (void)</td></tr>
<tr class="memdesc:a0cac0f188b5f46ff8bcdd5d4ffa37e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPDK run as event driven mode.  <a href="thread_8h.html#a0cac0f188b5f46ff8bcdd5d4ffa37e84">More...</a><br /></td></tr>
<tr class="separator:a0cac0f188b5f46ff8bcdd5d4ffa37e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8be492b86ceface921634b9a627b7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1f8be492b86ceface921634b9a627b7c">spdk_interrupt_mode_is_enabled</a> (void)</td></tr>
<tr class="memdesc:a1f8be492b86ceface921634b9a627b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether interrupt mode is set.  <a href="thread_8h.html#a1f8be492b86ceface921634b9a627b7c">More...</a><br /></td></tr>
<tr class="separator:a1f8be492b86ceface921634b9a627b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a96f03fe115196f1de03292ed6d86fd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f03fe115196f1de03292ed6d86fd46">&#9670;&nbsp;</a></span>spdk_channel_for_each_cpl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_channel_for_each_cpl) (struct spdk_io_channel_iter *i, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device.">spdk_for_each_channel()</a> callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dd91f3094f8b4cf60f460e3f88bbf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd91f3094f8b4cf60f460e3f88bbf0c">&#9670;&nbsp;</a></span>spdk_channel_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_channel_msg) (struct spdk_io_channel_iter *i)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called on the appropriate thread for each channel associated with io_device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61cfdc77d10970d7f3a8631df71e9588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cfdc77d10970d7f3a8631df71e9588">&#9670;&nbsp;</a></span>spdk_interrupt_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_interrupt_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function registered for interrupt file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed as arg to <a class="el" href="thread_8h.html#aae58fe1101803d60c523891e7540a23c" title="Register an spdk_interrupt on the current thread.">spdk_interrupt_register()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 to indicate that interrupt took place but no events were found; positive to indicate that interrupt took place and some events were processed; negative if no event information is provided. </dd></dl>

</div>
</div>
<a id="aed1d14292cfee8553d4a1ebb519b210a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1d14292cfee8553d4a1ebb519b210a">&#9670;&nbsp;</a></span>spdk_io_channel_create_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_io_channel_create_cb) (void *io_device, void *ctx_buf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O channel creation callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>I/O device associated with this channel. </td></tr>
    <tr><td class="paramname">ctx_buf</td><td>Context for the I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75aa6a61877f23f79bb75c8fc5e68202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa6a61877f23f79bb75c8fc5e68202">&#9670;&nbsp;</a></span>spdk_io_channel_destroy_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_io_channel_destroy_cb) (void *io_device, void *ctx_buf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O channel destruction callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>I/O device associated with this channel. </td></tr>
    <tr><td class="paramname">ctx_buf</td><td>Context for the I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae044f4141737c7f2df49cdfb03fd58ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae044f4141737c7f2df49cdfb03fd58ca">&#9670;&nbsp;</a></span>spdk_io_device_unregister_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_io_device_unregister_cb) (void *io_device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O device unregister callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>Unregistered I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc0da6b1b784d4f165dcd48b526d12ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0da6b1b784d4f165dcd48b526d12ad">&#9670;&nbsp;</a></span>spdk_msg_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_msg_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that will be called on the target thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed as arg to <a class="el" href="thread_8h.html#a4a0e155fc3fa0150aa4a505dd1801e91" title="Function to be called to pass a message to a thread.">spdk_thread_pass_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afab3d4339c5bca4dfde209816a9e560f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab3d4339c5bca4dfde209816a9e560f">&#9670;&nbsp;</a></span>spdk_new_thread_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_new_thread_fn) (struct spdk_thread *thread)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that is called each time a new thread is created. </p>
<p>The implementor of this function should frequently call <a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread.">spdk_thread_poll()</a> on the thread provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The new spdk_thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35c421accdc2a0a61bb7be916106293b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c421accdc2a0a61bb7be916106293b">&#9670;&nbsp;</a></span>spdk_poller_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_poller_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for a poller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed as arg to <a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126" title="Register a poller on the current thread.">spdk_poller_register()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 to indicate that polling took place but no events were found; positive to indicate that polling took place and some events were processed; negative if the poller does not provide spin-wait information. </dd></dl>

</div>
</div>
<a id="a6f70f5e9b4d498e843f81f1a6ada6370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f70f5e9b4d498e843f81f1a6ada6370">&#9670;&nbsp;</a></span>spdk_start_poller</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct spdk_poller*(* spdk_start_poller) (void *thread_ctx, <a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called to start a poller for the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_ctx</td><td>Context for the thread. </td></tr>
    <tr><td class="paramname">fn</td><td>Callback function for a poller. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to callback. </td></tr>
    <tr><td class="paramname">period</td><td>Polling period in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the poller on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="adfddbbbb13145f26741106cb8296a05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfddbbbb13145f26741106cb8296a05a">&#9670;&nbsp;</a></span>spdk_stop_poller</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_stop_poller) (struct spdk_poller *poller, void *thread_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called to stop a poller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>Poller to stop. </td></tr>
    <tr><td class="paramname">thread_ctx</td><td>Context for the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a0e155fc3fa0150aa4a505dd1801e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0e155fc3fa0150aa4a505dd1801e91">&#9670;&nbsp;</a></span>spdk_thread_pass_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_thread_pass_msg) (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, void *thread_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called to pass a message to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>Callback function for a thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>Context passed to fn. </td></tr>
    <tr><td class="paramname">thread_ctx</td><td>Context for the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa7a2ca9bd0497544e852c65fd5263cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a2ca9bd0497544e852c65fd5263cd1">&#9670;&nbsp;</a></span>spdk_for_each_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_channel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a>&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call 'fn' on each channel associated with io_device. </p>
<p>This happens asynchronously, so fn may be called after spdk_for_each_channel returns. 'fn' will be called for each channel serially, such that two calls to 'fn' will not overlap in time. After 'fn' has been called, call <a class="el" href="thread_8h.html#a4e87fc8c0fc870769c068a2752cdc359" title="Helper function to iterate all channels for spdk_for_each_channel().">spdk_for_each_channel_continue()</a> to continue iterating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>'fn' will be called on each channel associated with this io_device. </td></tr>
    <tr><td class="paramname">fn</td><td>Called on the appropriate thread for each channel associated with io_device. </td></tr>
    <tr><td class="paramname">ctx</td><td>Context buffer registered to spdk_io_channel_iter that can be obatined form the function <a class="el" href="thread_8h.html#add3ebaac7b55dddb239c720c80d97dea" title="Get context buffer from the I/O channel iterator.">spdk_io_channel_iter_get_ctx()</a>. </td></tr>
    <tr><td class="paramname">cpl</td><td>Called on the thread that spdk_for_each_channel was initially called from when 'fn' has been called on each channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e87fc8c0fc870769c068a2752cdc359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e87fc8c0fc870769c068a2752cdc359">&#9670;&nbsp;</a></span>spdk_for_each_channel_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_channel_continue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to iterate all channels for <a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device.">spdk_for_each_channel()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
    <tr><td class="paramname">status</td><td>Status for the I/O channel iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16bb098e6398d2a63577e805f1423a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bb098e6398d2a63577e805f1423a3e">&#9670;&nbsp;</a></span>spdk_for_each_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to each thread, serially. </p>
<p>The message is sent asynchronously - i.e. spdk_for_each_thread will return prior to <code>fn</code> being called on each thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>This is the function that will be called on each thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>This context will be passed to fn when called. </td></tr>
    <tr><td class="paramname">cpl</td><td>This will be called on the originating thread after <code>fn</code> has been called on each thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8537c42a7aa203b50578efed509d9ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8537c42a7aa203b50578efed509d9ba8">&#9670;&nbsp;</a></span>spdk_get_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a>* spdk_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an I/O channel for the specified io_device to be used by the calling thread. </p>
<p>The io_device context pointer specified must have previously been registered using <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device.">spdk_io_device_register()</a>. If an existing I/O channel does not exist yet for the given io_device on the calling thread, it will allocate an I/O channel and invoke the create_cb function pointer specified in <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device.">spdk_io_device_register()</a>. If an I/O channel already exists for the given io_device on the calling thread, its reference is returned rather than creating a new I/O channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel for this device on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a34754a98debd5e095bf06889fbaed6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34754a98debd5e095bf06889fbaed6aa">&#9670;&nbsp;</a></span>spdk_get_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_get_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the current thread. </p>
<p>This handle may be passed to other threads and used as the target of <a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec" title="Send a message to the given thread.">spdk_thread_send_msg()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b" title="Get the thread associated with an I/O channel.">spdk_io_channel_get_thread()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a0cac0f188b5f46ff8bcdd5d4ffa37e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cac0f188b5f46ff8bcdd5d4ffa37e84">&#9670;&nbsp;</a></span>spdk_interrupt_mode_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_interrupt_mode_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPDK run as event driven mode. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -errno on failure </dd></dl>

</div>
</div>
<a id="a1f8be492b86ceface921634b9a627b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8be492b86ceface921634b9a627b7c">&#9670;&nbsp;</a></span>spdk_interrupt_mode_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_interrupt_mode_is_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether interrupt mode is set. </p>
<dl class="section return"><dt>Returns</dt><dd>True if interrupt mode is set, false otherwise. </dd></dl>

</div>
</div>
<a id="aae58fe1101803d60c523891e7540a23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae58fe1101803d60c523891e7540a23c">&#9670;&nbsp;</a></span>spdk_interrupt_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_interrupt* spdk_interrupt_register </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>efd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a61cfdc77d10970d7f3a8631df71e9588">spdk_interrupt_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an spdk_interrupt on the current thread. </p>
<p>The provided function will be called any time the associated file descriptor is written to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">efd</td><td>File descriptor of the spdk_interrupt. </td></tr>
    <tr><td class="paramname">fn</td><td>Called each time there are events in spdk_interrupt. </td></tr>
    <tr><td class="paramname">arg</td><td>Function argument for fn. </td></tr>
    <tr><td class="paramname">name</td><td>Human readable name for the spdk_interrupt. Pointer of the spdk_interrupt name is set if NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the spdk_interrupt registered on the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a6665332ac6d7781f7944f5f471ce1a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6665332ac6d7781f7944f5f471ce1a21">&#9670;&nbsp;</a></span>spdk_interrupt_set_event_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_interrupt_set_event_types </td>
          <td>(</td>
          <td class="paramtype">struct spdk_interrupt *&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum spdk_interrupt_event_types&#160;</td>
          <td class="paramname"><em>event_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the event_types associated with the spdk_interrupt on the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The pointer to the spdk_interrupt registered on the current thread. </td></tr>
    <tr><td class="paramname">event_types</td><td>New event_types for the spdk_interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success or -errno if failed. </dd></dl>

</div>
</div>
<a id="a45f3647a26ba93931beeb1782d39e56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f3647a26ba93931beeb1782d39e56e">&#9670;&nbsp;</a></span>spdk_interrupt_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_interrupt_unregister </td>
          <td>(</td>
          <td class="paramtype">struct spdk_interrupt **&#160;</td>
          <td class="paramname"><em>pintr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an spdk_interrupt on the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pintr</td><td>The spdk_interrupt to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9608b7b0fd448edec6ea5dd38ad04a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9608b7b0fd448edec6ea5dd38ad04a57">&#9670;&nbsp;</a></span>spdk_io_channel_from_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a>* spdk_io_channel_from_ctx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I/O channel from the context buffer. </p>
<p>This is the inverse of <a class="el" href="thread_8h.html#adbf6e22252bc768003c7bbc165fc3c51" title="Get the context buffer associated with an I/O channel.">spdk_io_channel_get_ctx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The pointer to the context buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel associated with the context buffer. </dd></dl>

</div>
</div>
<a id="adbf6e22252bc768003c7bbc165fc3c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf6e22252bc768003c7bbc165fc3c51">&#9670;&nbsp;</a></span>spdk_io_channel_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* spdk_io_channel_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the context buffer associated with an I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the context buffer. </dd></dl>

</div>
</div>
<a id="a8ff9537d26ac923a7a93cd55ba315b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9537d26ac923a7a93cd55ba315b5b">&#9670;&nbsp;</a></span>spdk_io_channel_get_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_io_channel_get_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread associated with an I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the thread associated with the I/O channel </dd></dl>

</div>
</div>
<a id="a83adef6c3df9568bdea346b8e7dcbaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83adef6c3df9568bdea346b8e7dcbaa5">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a>* spdk_io_channel_iter_get_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I/O channel from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel. </dd></dl>

</div>
</div>
<a id="add3ebaac7b55dddb239c720c80d97dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3ebaac7b55dddb239c720c80d97dea">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_io_channel_iter_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get context buffer from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the context buffer. </dd></dl>

</div>
</div>
<a id="a939935cee4dac6636f2b7c6db0b2fec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939935cee4dac6636f2b7c6db0b2fec1">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_io_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_io_channel_iter_get_io_device </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get io_device from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the io_device. </dd></dl>

</div>
</div>
<a id="a75f5c71056d8c39ff05a6610d55edcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f5c71056d8c39ff05a6610d55edcf5">&#9670;&nbsp;</a></span>spdk_io_device_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_io_device_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a>&#160;</td>
          <td class="paramname"><em>create_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a>&#160;</td>
          <td class="paramname"><em>destroy_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctx_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the opaque io_device context as an I/O device. </p>
<p>After an I/O device is registered, it can return I/O channels using the <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread.">spdk_get_io_channel()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context. </td></tr>
    <tr><td class="paramname">create_cb</td><td>Callback function invoked to allocate any resources required for a new I/O channel. </td></tr>
    <tr><td class="paramname">destroy_cb</td><td>Callback function invoked to release the resources for an I/O channel. </td></tr>
    <tr><td class="paramname">ctx_size</td><td>The size of the context buffer allocated to store references to allocated I/O channel resources. </td></tr>
    <tr><td class="paramname">name</td><td>A string name for the device used only for debugging. Optional - may be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6c3df3a611c10c176cb87966c622f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6c3df3a611c10c176cb87966c622f0">&#9670;&nbsp;</a></span>spdk_io_device_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_io_device_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a>&#160;</td>
          <td class="paramname"><em>unregister_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the opaque io_device context as an I/O device. </p>
<p>The actual unregistration might be deferred until all active I/O channels are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context. </td></tr>
    <tr><td class="paramname">unregister_cb</td><td>An optional callback function invoked to release any references to this I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f0c05dd1c9cb0b31eee89213b89f3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0c05dd1c9cb0b31eee89213b89f3c3">&#9670;&nbsp;</a></span>spdk_poller_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_pause </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller *&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause a poller on the current thread. </p>
<p>The poller is not run until it is resumed with <a class="el" href="thread_8h.html#ab3de0ffe9dfc29361b092d467d37017e" title="Resume a poller on the current thread.">spdk_poller_resume()</a>. It is perfectly fine to pause an already paused poller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>The poller to pause. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b3e883ddce01ae8d93541304d1e9126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3e883ddce01ae8d93541304d1e9126">&#9670;&nbsp;</a></span>spdk_poller_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_poller* spdk_poller_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>period_microseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a poller on the current thread. </p>
<p>The poller can be unregistered by calling <a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3" title="Unregister a poller on the current thread.">spdk_poller_unregister()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>This function will be called every <code>period_microseconds</code>. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to fn. </td></tr>
    <tr><td class="paramname">period_microseconds</td><td>How often to call <code>fn</code>. If 0, call <code>fn</code> as often as possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the poller registered on the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a4e1086db1bd40b0a1720bd148967d82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1086db1bd40b0a1720bd148967d82d">&#9670;&nbsp;</a></span>spdk_poller_register_named()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_poller* spdk_poller_register_named </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>period_microseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a poller on the current thread with arbitrary name. </p>
<p>The poller can be unregistered by calling <a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3" title="Unregister a poller on the current thread.">spdk_poller_unregister()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>This function will be called every <code>period_microseconds</code>. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to fn. </td></tr>
    <tr><td class="paramname">period_microseconds</td><td>How often to call <code>fn</code>. If 0, call <code>fn</code> as often as possible. </td></tr>
    <tr><td class="paramname">name</td><td>Human readable name for the poller. Pointer of the poller function name is set if NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the poller registered on the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="ab3de0ffe9dfc29361b092d467d37017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3de0ffe9dfc29361b092d467d37017e">&#9670;&nbsp;</a></span>spdk_poller_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_resume </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller *&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a poller on the current thread. </p>
<p>Resumes a poller paused with <a class="el" href="thread_8h.html#a0f0c05dd1c9cb0b31eee89213b89f3c3" title="Pause a poller on the current thread.">spdk_poller_pause()</a>. It is perfectly fine to resume an unpaused poller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>The poller to resume. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c26cbd781063f5ee627d6aba2c73fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c26cbd781063f5ee627d6aba2c73fe3">&#9670;&nbsp;</a></span>spdk_poller_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_unregister </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller **&#160;</td>
          <td class="paramname"><em>ppoller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a poller on the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoller</td><td>The poller to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717571a5011db0cdd730498146f25f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717571a5011db0cdd730498146f25f9a">&#9670;&nbsp;</a></span>spdk_put_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_put_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference to an I/O channel. </p>
<p>This happens asynchronously.</p>
<p>This must be called on the same thread that called <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread.">spdk_get_io_channel()</a> for the specified I/O channel. If this releases the last reference to the I/O channel, The destroy_cb function specified in <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device.">spdk_io_device_register()</a> will be invoked to release any associated resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel to release a reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60dac2a0fc19b23be6fecb1e5b6f8a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dac2a0fc19b23be6fecb1e5b6f8a7a">&#9670;&nbsp;</a></span>spdk_set_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_set_thread </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the current system thread to act as if executing the given SPDK thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4eada7bac2a5c7ceaea891d57f8d3e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eada7bac2a5c7ceaea891d57f8d3e21">&#9670;&nbsp;</a></span>spdk_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td>
          <td class="paramname"><em>cpumask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new SPDK thread object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Human-readable name for the thread; can be retrieved with <a class="el" href="thread_8h.html#ae367048fa89366e845d72015064e6f76" title="Get a thread&#39;s name.">spdk_thread_get_name()</a>. The string is copied, so the pointed-to data only needs to be valid during the <a class="el" href="thread_8h.html#a4eada7bac2a5c7ceaea891d57f8d3e21" title="Creates a new SPDK thread object.">spdk_thread_create()</a> call. May be NULL to specify no name. </td></tr>
    <tr><td class="paramname">cpumask</td><td>Optional mask of CPU cores on which to schedule this thread. This is only a suggestion to the scheduler. The value is copied, so cpumask may be released when this function returns. May be NULL if no mask is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated thread on success or NULL on failure.. </dd></dl>

</div>
</div>
<a id="a10aa5a8ec5228fa87db97f7655f8c0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa5a8ec5228fa87db97f7655f8c0d6">&#9670;&nbsp;</a></span>spdk_thread_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_thread_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a thread, releasing all of its resources. </p>
<p>May only be called on a thread previously marked as exited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5132d2abe39a40a0e14e19bb2bd15489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5132d2abe39a40a0e14e19bb2bd15489">&#9670;&nbsp;</a></span>spdk_thread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_exit </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the thread as exited, failing all future <a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec" title="Send a message to the given thread.">spdk_thread_send_msg()</a>, <a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126" title="Register a poller on the current thread.">spdk_poller_register()</a>, and <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread.">spdk_get_io_channel()</a> calls. </p>
<p>May only be called within an spdk poller or message.</p>
<p>All I/O channel references associated with the thread must be released using <a class="el" href="thread_8h.html#a717571a5011db0cdd730498146f25f9a" title="Release a reference to an I/O channel.">spdk_put_io_channel()</a>, and all active pollers associated with the thread should be unregistered using <a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3" title="Unregister a poller on the current thread.">spdk_poller_unregister()</a>, prior to calling this function. This function will complete these processing. The completion can be queried by <a class="el" href="thread_8h.html#ae99859eb37714e4ed7c6110ea71ab142" title="Returns whether the thread is marked as exited.">spdk_thread_is_exited()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>always 0. (return value was deprecated but keep it for ABI compatibility.) </dd></dl>

</div>
</div>
<a id="a24c90cd523aad947dad7e651074d9f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c90cd523aad947dad7e651074d9f1d">&#9670;&nbsp;</a></span>spdk_thread_get_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_get_by_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread by the ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Thread whose ID matches or NULL otherwise. </dd></dl>

</div>
</div>
<a id="a9f06d559046d570e025d6b67c7e8d507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f06d559046d570e025d6b67c7e8d507">&#9670;&nbsp;</a></span>spdk_thread_get_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a>* spdk_thread_get_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread's cpumask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to get the cpumask for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cpuset pointer </dd></dl>

</div>
</div>
<a id="a1deb97a85a8240119cf46fa8a0b71388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deb97a85a8240119cf46fa8a0b71388">&#9670;&nbsp;</a></span>spdk_thread_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_thread_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to this thread's context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread on which to get the context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the per-thread context, or NULL if there is no per-thread context. </dd></dl>

</div>
</div>
<a id="af813fe52c71ec5e254f8671570f57bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af813fe52c71ec5e254f8671570f57bdc">&#9670;&nbsp;</a></span>spdk_thread_get_from_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_get_from_ctx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread object associated with the context handle previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>A context previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated thread. </dd></dl>

</div>
</div>
<a id="aead9239fedaf5af9f24b5614f6c0c8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead9239fedaf5af9f24b5614f6c0c8fb">&#9670;&nbsp;</a></span>spdk_thread_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_thread_get_id </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a thread's ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the thread.. </dd></dl>

</div>
</div>
<a id="a6b33abb26c349950555f71a34cf507c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b33abb26c349950555f71a34cf507c6">&#9670;&nbsp;</a></span>spdk_thread_get_interrupt_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_get_interrupt_fd </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a file descriptor that becomes ready whenever any of the registered interrupt file descriptors are ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The spdk_interrupt fd of thread itself. </dd></dl>

</div>
</div>
<a id="ae8d7fd3db7cd91ff37c3898e69811f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d7fd3db7cd91ff37c3898e69811f7a">&#9670;&nbsp;</a></span>spdk_thread_get_last_tsc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_thread_get_last_tsc </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the TSC value from the end of the last time this thread was polled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TSC value from the end of the last time this thread was polled. </dd></dl>

</div>
</div>
<a id="ae367048fa89366e845d72015064e6f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae367048fa89366e845d72015064e6f76">&#9670;&nbsp;</a></span>spdk_thread_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_thread_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a thread's name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the thread. </dd></dl>

</div>
</div>
<a id="ab6f07dd00b0b4140155713aca312d46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f07dd00b0b4140155713aca312d46b">&#9670;&nbsp;</a></span>spdk_thread_get_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_get_stats </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get statistics about the current thread. </p>
<p>Copy cumulative thread stats values to the provided thread stats structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stats</td><td>User's thread_stats structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a143ecbc5ce7edcd57e76cffd74bde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a143ecbc5ce7edcd57e76cffd74bde5">&#9670;&nbsp;</a></span>spdk_thread_has_active_pollers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_has_active_pollers </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are any active pollers (pollers for which period_microseconds equals 0) registered to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is at least one active poller, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a9f877dd192ccdd30572941aa4e453c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f877dd192ccdd30572941aa4e453c48">&#9670;&nbsp;</a></span>spdk_thread_has_pollers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_has_pollers </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are any pollers registered to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is any active poller, false otherwise. </dd></dl>

</div>
</div>
<a id="ae99859eb37714e4ed7c6110ea71ab142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99859eb37714e4ed7c6110ea71ab142">&#9670;&nbsp;</a></span>spdk_thread_is_exited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_is_exited </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the thread is marked as exited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if marked as exited, false otherwise. </dd></dl>

</div>
</div>
<a id="adc45e09bda68d13cfc0ae010738cd658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc45e09bda68d13cfc0ae010738cd658">&#9670;&nbsp;</a></span>spdk_thread_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_is_idle </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are scheduled operations to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are no scheduled operations, false otherwise. </dd></dl>

</div>
</div>
<a id="a96c6e1cadb3b5a83c5723487e3f02c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6e1cadb3b5a83c5723487e3f02c23">&#9670;&nbsp;</a></span>spdk_thread_lib_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_lib_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a>&#160;</td>
          <td class="paramname"><em>new_thread_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ctx_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the threading library. </p>
<p>Must be called once prior to allocating any threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_thread_fn</td><td>Called each time a new SPDK thread is created. The implementor is expected to frequently call <a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread.">spdk_thread_poll()</a> on the provided thread. </td></tr>
    <tr><td class="paramname">ctx_sz</td><td>For each thread allocated, an additional region of memory of size ctx_size will also be allocated, for use by the thread scheduler. A pointer to this region may be obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="a820faedd428f6e689ecb28d721a8d0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820faedd428f6e689ecb28d721a8d0bf">&#9670;&nbsp;</a></span>spdk_thread_lib_init_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_lib_init_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a9f0ad3a2bcbb6d304401b579ab63aeba">spdk_thread_op_fn</a>&#160;</td>
          <td class="paramname"><em>thread_op_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#af791c24e496b96c886fe8bad088eb0cb">spdk_thread_op_supported_fn</a>&#160;</td>
          <td class="paramname"><em>thread_op_supported_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ctx_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the threading library. </p>
<p>Must be called once prior to allocating any threads</p>
<p>Both thread_op_fn and thread_op_type_supported_fn have to be specified or not specified together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_op_fn</td><td>Called for SPDK thread operation. </td></tr>
    <tr><td class="paramname">thread_op_supported_fn</td><td>Called to check whether the SPDK thread operation is supported. </td></tr>
    <tr><td class="paramname">ctx_sz</td><td>For each thread allocated, for use by the thread scheduler. A pointer to this region may be obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="a474fcfc5c14928eda42c684ba2b4cba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474fcfc5c14928eda42c684ba2b4cba9">&#9670;&nbsp;</a></span>spdk_thread_next_poller_expiration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_thread_next_poller_expiration </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of ticks until the next timed poller would expire. </p>
<p>Timed pollers are pollers for which period_microseconds is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check poller expiration times on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of ticks. If no timed pollers, return 0. </dd></dl>

</div>
</div>
<a id="ad9e3693e8e9e6c9063ea36414294ae91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e3693e8e9e6c9063ea36414294ae91">&#9670;&nbsp;</a></span>spdk_thread_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_poll </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform one iteration worth of processing on the thread. </p>
<p>This includes both expired and continuous pollers as well as messages. If the thread has exited, return immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to process </td></tr>
    <tr><td class="paramname">max_msgs</td><td>The maximum number of messages that will be processed. Use 0 to process the default number of messages (8). </td></tr>
    <tr><td class="paramname">now</td><td>The current time, in ticks. Optional. If 0 is passed, this function will call <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter.">spdk_get_ticks()</a> to get the current time. The current time is used as start time and this function will call <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter.">spdk_get_ticks()</a> at its end to know end time to measure run time of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if work was done. 0 if no work was done. </dd></dl>

</div>
</div>
<a id="a91a7e9d44c2a332dfcea5e23df471c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a7e9d44c2a332dfcea5e23df471c8d">&#9670;&nbsp;</a></span>spdk_thread_send_critical_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_send_critical_msg </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the given thread. </p>
<p>Only one critical message can be outstanding at the same time. It's intended to use this function in any cases that might interrupt the execution of the application, such as signal handlers.</p>
<p>The message will be sent asynchronously - i.e. spdk_thread_send_critical_msg will always return prior to <code>fn</code> being called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread. </td></tr>
    <tr><td class="paramname">fn</td><td>This function will be called on the given thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EIO if the message could not be sent to the destination thread, due to an already outstanding critical message </dd></dl>

</div>
</div>
<a id="a07b662b152c21dad824ad2738d0733ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b662b152c21dad824ad2738d0733ec">&#9670;&nbsp;</a></span>spdk_thread_send_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_send_msg </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the given thread. </p>
<p>The message will be sent asynchronously - i.e. spdk_thread_send_msg will always return prior to <code>fn</code> being called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread. </td></tr>
    <tr><td class="paramname">fn</td><td>This function will be called on the given thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>This context will be passed to fn when called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-ENOMEM if the message could not be allocated </dd>
<dd>
-EIO if the message could not be sent to the destination thread </dd></dl>

</div>
</div>
<a id="a44c27f304a333a80bbdb48f1df12721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c27f304a333a80bbdb48f1df12721f">&#9670;&nbsp;</a></span>spdk_thread_set_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_set_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td>
          <td class="paramname"><em>cpumask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current thread's cpumask to the specified value. </p>
<p>The thread may be rescheduled to one of the CPUs specified in the cpumask.</p>
<p>This API requires SPDK thread operation supports SPDK_THREAD_OP_RESCHED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpumask</td><td>The new cpumask for the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
