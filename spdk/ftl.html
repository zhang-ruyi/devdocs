<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.20">
  <title>SPDK: Flash Translation Layer</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ftl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Flash Translation Layer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_ftl"></a> The Flash Translation Layer library provides block device access on top of devices implementing bdev_zone interface. It handles the logical to physical address mapping, responds to the asynchronous media management events, and manages the defragmentation process.</p>
<h1><a class="anchor" id="ftl_terminology"></a>
Terminology</h1>
<h2>Logical to physical address map</h2>
<ul>
<li>Shorthand: L2P</li>
</ul>
<p>Contains the mapping of the logical addresses (LBA) to their on-disk physical location. The LBAs are contiguous and in range from 0 to the number of surfaced blocks (the number of spare blocks are calculated during device formation and are subtracted from the available address space). The spare blocks account for zones going offline throughout the lifespan of the device as well as provide necessary buffer for data <a href="#ftl_reloc">defragmentation</a>.</p>
<h2><a class="anchor" id="ftl_band"></a>
Band</h2>
<p>A band describes a collection of zones, each belonging to a different parallel unit. All writes to a band follow the same pattern - a batch of logical blocks is written to one zone, another batch to the next one and so on. This ensures the parallelism of the write operations, as they can be executed independently on different zones. Each band keeps track of the LBAs it consists of, as well as their validity, as some of the data will be invalidated by subsequent writes to the same logical address. The L2P mapping can be restored from the SSD by reading this information in order from the oldest band to the youngest. </p><pre class="fragment">         +--------------+        +--------------+                        +--------------+
band 1   |   zone 1     +--------+    zone 1    +---- --- --- --- --- ---+     zone 1   |
         +--------------+        +--------------+                        +--------------+
band 2   |   zone 2     +--------+     zone 2   +---- --- --- --- --- ---+     zone 2   |
         +--------------+        +--------------+                        +--------------+
band 3   |   zone 3     +--------+     zone 3   +---- --- --- --- --- ---+     zone 3   |
         +--------------+        +--------------+                        +--------------+
         |     ...      |        |     ...      |                        |     ...      |
         +--------------+        +--------------+                        +--------------+
band m   |   zone m     +--------+     zone m   +---- --- --- --- --- ---+     zone m   |
         +--------------+        +--------------+                        +--------------+
         |     ...      |        |     ...      |                        |     ...      |
         +--------------+        +--------------+                        +--------------+

          parallel unit 1              pu 2                                    pu n
</pre><p>The address map and valid map are, along with a several other things (e.g. UUID of the device it's part of, number of surfaced LBAs, band's sequence number, etc.), parts of the band's metadata. The metadata is split in two parts: </p><pre class="fragment">   head metadata               band's data               tail metadata
+-------------------+-------------------------------+------------------------+
|zone 1 |...|zone n |...|...|zone 1 |...|           | ... |zone  m-1 |zone  m|
|block 1|   |block 1|   |   |block x|   |           |     |block y   |block y|
+-------------------+-------------+-----------------+------------------------+
</pre><ul>
<li>the head part, containing information already known when opening the band (device's UUID, band's sequence number, etc.), located at the beginning blocks of the band,</li>
<li>the tail part, containing the address map and the valid map, located at the end of the band.</li>
</ul>
<p>Bands are written sequentially (in a way that was described earlier). Before a band can be written to, all of its zones need to be erased. During that time, the band is considered to be in a <code>PREP</code> state. After that is done, the band transitions to the <code>OPENING</code> state, in which head metadata is being written. Then the band moves to the <code>OPEN</code> state and actual user data can be written to the band. Once the whole available space is filled, tail metadata is written and the band transitions to <code>CLOSING</code> state. When that finishes the band becomes <code>CLOSED</code>.</p>
<h2><a class="anchor" id="ftl_rwb"></a>
Ring write buffer</h2>
<ul>
<li>Shorthand: RWB</li>
</ul>
<p>Because the smallest write size the SSD may support can be a multiple of block size, in order to support writes to a single block, the data needs to be buffered. The write buffer is the solution to this problem. It consists of a number of pre-allocated buffers called batches, each of size allowing for a single transfer to the SSD. A single batch is divided into block-sized buffer entries. </p><pre class="fragment">             write buffer
+-----------------------------------+
|batch 1                            |
|   +-----------------------------+ |
|   |rwb    |rwb    | ... |rwb    | |
|   |entry 1|entry 2|     |entry n| |
|   +-----------------------------+ |
+-----------------------------------+
| ...                               |
+-----------------------------------+
|batch m                            |
|   +-----------------------------+ |
|   |rwb    |rwb    | ... |rwb    | |
|   |entry 1|entry 2|     |entry n| |
|   +-----------------------------+ |
+-----------------------------------+
</pre><p>When a write is scheduled, it needs to acquire an entry for each of its blocks and copy the data onto this buffer. Once all blocks are copied, the write can be signalled as completed to the user. In the meantime, the <code>rwb</code> is polled for filled batches and, if one is found, it's sent to the SSD. After that operation is completed the whole batch can be freed. For the whole time the data is in the <code>rwb</code>, the L2P points at the buffer entry instead of a location on the SSD. This allows for servicing read requests from the buffer.</p>
<h2><a class="anchor" id="ftl_reloc"></a>
Defragmentation and relocation</h2>
<ul>
<li>Shorthand: defrag, reloc</li>
</ul>
<p>Since a write to the same LBA invalidates its previous physical location, some of the blocks on a band might contain old data that basically wastes space. As there is no way to overwrite an already written block, this data will stay there until the whole zone is reset. This might create a situation in which all of the bands contain some valid data and no band can be erased, so no writes can be executed anymore. Therefore a mechanism is needed to move valid data and invalidate whole bands, so that they can be reused. </p><pre class="fragment">                band                                             band
+-----------------------------------+            +-----------------------------------+
| ** *    * ***      *    *** * *   |            |                                   |
|**  *       *    *    * *     *   *|   +----&gt;   |                                   |
|*     ***  *      *            *   |            |                                   |
+-----------------------------------+            +-----------------------------------+
</pre><p>Valid blocks are marked with an asterisk '*'.</p>
<p>Another reason for data relocation might be an event from the SSD telling us that the data might become corrupt if it's not relocated. This might happen due to its old age (if it was written a long time ago) or due to read disturb (media characteristic, that causes corruption of neighbouring blocks during a read operation).</p>
<p>Module responsible for data relocation is called <code>reloc</code>. When a band is chosen for defragmentation or a media management event is received, the appropriate blocks are marked as required to be moved. The <code>reloc</code> module takes a band that has some of such blocks marked, checks their validity and, if they're still valid, copies them.</p>
<p>Choosing a band for defragmentation depends on several factors: its valid ratio (1) (proportion of valid blocks to all user blocks), its age (2) (when was it written) and its write count / wear level index of its zones (3) (how many times the band was written to). The lower the ratio (1), the higher its age (2) and the lower its write count (3), the higher the chance the band will be chosen for defrag.</p>
<h1><a class="anchor" id="ftl_usage"></a>
Usage</h1>
<h2><a class="anchor" id="ftl_prereq"></a>
Prerequisites</h2>
<p>In order to use the FTL module, a device capable of zoned interface is required e.g. <code>zone_block</code> bdev or OCSSD <code>nvme</code> bdev.</p>
<h2><a class="anchor" id="ftl_create"></a>
FTL bdev creation</h2>
<p>Similar to other bdevs, the FTL bdevs can be created either based on JSON config files or via RPC. Both interfaces require the same arguments which are described by the <code>--help</code> option of the <code>bdev_ftl_create</code> RPC call, which are:</p>
<ul>
<li>bdev's name</li>
<li>base bdev's name (base bdev must implement bdev_zone API)</li>
<li>UUID of the FTL device (if the FTL is to be restored from the SSD)</li>
</ul>
<h2><a class="anchor" id="ftl_ocssd"></a>
FTL usage with OCSSD nvme bdev</h2>
<p>This option requires an Open Channel SSD, which can be emulated using QEMU.</p>
<p>The QEMU with the patches providing Open Channel support can be found on the SPDK's QEMU fork on <a href="https://github.com/spdk/qemu/tree/spdk-3.0.0">spdk-3.0.0</a> branch.</p>
<h2><a class="anchor" id="ftl_qemu_config"></a>
Configuring QEMU</h2>
<p>To emulate an Open Channel device, QEMU expects parameters describing the characteristics and geometry of the SSD:</p>
<ul>
<li><code>serial</code> - serial number,</li>
<li><code>lver</code> - version of the OCSSD standard (0 - disabled, 1 - "1.2", 2 - "2.0"), libftl only supports 2.0,</li>
<li><code>lba_index</code> - default LBA format. Possible values can be found in the table below (libftl only supports lba_index &gt;= 3):</li>
<li><code>lnum_ch</code> - number of groups,</li>
<li><code>lnum_lun</code> - number of parallel units</li>
<li><code>lnum_pln</code> - number of planes (logical blocks from all planes constitute a chunk)</li>
<li><code>lpgs_per_blk</code> - number of pages (smallest programmable unit) per chunk</li>
<li><code>lsecs_per_pg</code> - number of sectors in a page</li>
<li><code>lblks_per_pln</code> - number of chunks in a parallel unit</li>
<li><code>laer_thread_sleep</code> - timeout in ms between asynchronous events requesting the host to relocate the data based on media feedback</li>
<li><code>lmetadata</code> - metadata file <pre class="fragment"> |lba_index| data| metadata|
 |---------|-----|---------|
 |    0    | 512B|    0B   |
 |    1    | 512B|    8B   |
 |    2    | 512B|   16B   |
 |    3    |4096B|    0B   |
 |    4    |4096B|   64B   |
 |    5    |4096B|  128B   |
 |    6    |4096B|   16B   |
</pre></li>
</ul>
<p>For more detailed description of the available options, consult the <code>hw/block/nvme.c</code> file in the QEMU repository.</p>
<p>Example:</p>
<div class="fragment"><div class="line">$ /path/to/qemu [OTHER PARAMETERS] -drive format=raw,file=/path/to/data/file,if=none,id=myocssd0</div>
<div class="line">        -device nvme,drive=myocssd0,serial=deadbeef,lver=2,lba_index=3,lnum_ch=1,lnum_lun=8,lnum_pln=4,</div>
<div class="line">        lpgs_per_blk=1536,lsecs_per_pg=4,lblks_per_pln=512,lmetadata=/path/to/md/file</div>
</div><!-- fragment --><p>In the above example, a device is created with 1 channel, 8 parallel units, 512 chunks per parallel unit, 24576 (<code>lnum_pln</code> * <code>lpgs_per_blk</code> * <code>lsecs_per_pg</code>) logical blocks in each chunk with logical block being 4096B. Therefore the data file needs to be at least 384G (8 * 512 * 24576 * 4096B) of size and can be created with the following command:</p>
<div class="fragment"><div class="line">fallocate -l 384G /path/to/data/file</div>
</div><!-- fragment --><h2><a class="anchor" id="ftl_spdk_config"></a>
Configuring SPDK</h2>
<p>To verify that the drive is emulated correctly, one can check the output of the NVMe identify app (assuming that <code>scripts/setup.sh</code> was called before and the driver has been changed for that device):</p>
<div class="fragment"><div class="line">$ build/examples/identify</div>
<div class="line">=====================================================</div>
<div class="line">NVMe Controller at 0000:00:0a.0 [1d1d:1f1f]</div>
<div class="line">=====================================================</div>
<div class="line">Controller Capabilities/Features</div>
<div class="line">================================</div>
<div class="line">Vendor ID:                             1d1d</div>
<div class="line">Subsystem Vendor ID:                   1af4</div>
<div class="line">Serial Number:                         deadbeef</div>
<div class="line">Model Number:                          QEMU NVMe Ctrl</div>
<div class="line"> </div>
<div class="line">... other info ...</div>
<div class="line"> </div>
<div class="line">Namespace OCSSD Geometry</div>
<div class="line">=======================</div>
<div class="line">OC version: maj:2 min:0</div>
<div class="line"> </div>
<div class="line">... other info ...</div>
<div class="line"> </div>
<div class="line">Groups (channels): 1</div>
<div class="line">PUs (LUNs) per group: 8</div>
<div class="line">Chunks per LUN: 512</div>
<div class="line">Logical blks per chunk: 24576</div>
<div class="line"> </div>
<div class="line">... other info ...</div>
</div><!-- fragment --><p>In order to create FTL on top Open Channel SSD, the following steps are required:</p>
<p>1) Attach OCSSD NVMe controller 2) Create OCSSD bdev on the controller attached in step 1 (user could specify parallel unit range and create multiple OCSSD bdevs on single OCSSD NVMe controller) 3) Create FTL bdev on top of bdev created in step 2</p>
<p>Example: </p><div class="fragment"><div class="line">$ scripts/rpc.py bdev_nvme_attach_controller -b nvme0 -a 00:0a.0 -t pcie</div>
<div class="line"> </div>
<div class="line">$ scripts/rpc.py bdev_ocssd_create -c nvme0 -b nvme0n1</div>
<div class="line">        nvme0n1</div>
<div class="line"> </div>
<div class="line">$ scripts/rpc.py bdev_ftl_create -b ftl0 -d nvme0n1</div>
<div class="line">{</div>
<div class="line">        &quot;name&quot;: &quot;ftl0&quot;,</div>
<div class="line">        &quot;uuid&quot;: &quot;3b469565-1fa5-4bfb-8341-747ec9fca9b9&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="ftl_zone_block"></a>
FTL usage with zone block bdev</h2>
<p>Zone block bdev is a bdev adapter between regular <code>bdev</code> and <code>bdev_zone</code>. It emulates a zoned interface on top of a regular block device.</p>
<p>In order to create FTL on top of a regular bdev: 1) Create regular bdev e.g. <code>bdev_nvme</code>, <code>bdev_null</code>, <code>bdev_malloc</code> 2) Create zone block bdev on top of a regular bdev created in step 1 (user could specify zone capacity and optimal number of open zones) 3) Create FTL bdev on top of bdev created in step 2</p>
<p>Example: </p><div class="fragment"><div class="line">$ scripts/rpc.py bdev_nvme_attach_controller -b nvme0 -a 00:05.0 -t pcie</div>
<div class="line">        nvme0n1</div>
<div class="line"> </div>
<div class="line">$ scripts/rpc.py bdev_zone_block_create -b zone1 -n nvme0n1 -z 4096 -o 32</div>
<div class="line">        zone1</div>
<div class="line"> </div>
<div class="line">$ scripts/rpc.py bdev_ftl_create -b ftl0 -d zone1</div>
<div class="line">{</div>
<div class="line">        &quot;name&quot;: &quot;ftl0&quot;,</div>
<div class="line">        &quot;uuid&quot;: &quot;3b469565-1fa5-4bfb-8341-747ec9f3a9b9&quot;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
</div>
