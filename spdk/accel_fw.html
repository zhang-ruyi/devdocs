<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.20">
  <title>SPDK: Acceleration Framework</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('accel_fw.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Acceleration Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_accel_fw"></a> SPDK provides a framework for abstracting general acceleration capabilities that can be implemented through plug-in modules and low-level libraries. These plug-in modules include support for hardware acceleration engines such as the Intel(R) I/O Acceleration Technology (IOAT) engine and the Intel(R) Data Streaming Accelerator (DSA) engine. Additionally, a software plug-in module exists to enable use of the framework in environments without hardware acceleration capabilities. ISA/L is used for optimized CRC32C calculation within the software module.</p>
<p>The framework includes an API for getting the current capabilities of the selected module. See <a href="https://spdk.io/doc/accel__engine_8h.html"><code>spdk_accel_get_capabilities</code></a> for more details. For the software module, all capabilities will be reported as supported. For the hardware modules, only functions accelerated by hardware will be reported however any function can still be called, it will just be backed by software if it is not reported as a supported capability.</p>
<h1><a class="anchor" id="accel_functions"></a>
Acceleration Framework Functions</h1>
<p>Functions implemented via the framework can be found in the DoxyGen documentation of the framework public header file here <a href="https://spdk.io/doc/accel__engine_8h.html">accel_engine.h</a></p>
<h1><a class="anchor" id="accel_dc"></a>
Acceleration Framework Design Considerations</h1>
<p>The general interface is defined by <code>/include/accel_engine.h</code> and implemented in <code>/lib/accel</code>. These functions may be called by an SPDK application and in most cases, except where otherwise documented, are asynchronous and follow the standard SPDK model for callbacks with a callback argument.</p>
<p>If the acceleration framework is started without initializing a hardware module, optimized software implementations of the functions will back the public API. Additionally, if any hardware module does not support a specific function and that hardware module is initialized, the specific function will fallback to a software optimized implementation. For example, IOAT does not support the dualcast function in hardware but if the IOAT module has been initialized and the public dualcast API is called, it will actually be done via software behind the scenes.</p>
<h1><a class="anchor" id="accel_libs"></a>
Acceleration Low Level Libraries</h1>
<p>Low level libraries provide only the most basic functions that are specific to the hardware. Low level libraries are located in the '/lib' directory with the exception of the software implementation which is implemented as part of the framework itself. The software low level library does not expose a public API. Applications may choose to interact directly with a low level library if there are specific needs/considerations not met via accessing the library through the framework/module. Note that when using the low level libraries directly, the framework abstracted interface is bypassed as the application will call the public functions exposed by the individual low level libraries. Thus, code written this way needs to be certain that the underlying hardware exists everywhere that it runs.</p>
<p>The low level library for IOAT is located in <code>/lib/ioat</code>. The low level library for DSA is in <code>/liv/idxd</code> (IDXD stands for Intel(R) Data Acceleration Driver).</p>
<h1><a class="anchor" id="accel_modules"></a>
Acceleration Plug-In Modules</h1>
<p>Plug-in modules depend on low level libraries to interact with the hardware and add additional functionality such as queueing during busy conditions or flow control in some cases. The framework in turn depends on the modules to provide the complete implementation of the acceleration component. A module must be selected via startup RPC when the application is started. Otherwise, if no startup RPC is provided, the framework is available and will use the software plug-in module.</p>
<h2><a class="anchor" id="accel_ioat"></a>
IOAT Module</h2>
<p>To use the IOAT engine, use the RPC <a href="https://spdk.io/doc/jsonrpc.html"><code>ioat_scan_accel_engine</code></a> before starting the application.</p>
<h2><a class="anchor" id="accel_idxd"></a>
IDXD Module</h2>
<p>To use the DSA engine, use the RPC <a href="https://spdk.io/doc/jsonrpc.html"><code>idxd_scan_accel_engine</code></a> with an optional parameter of <code>-c</code> and provide a configuration number of either 0 or 1. These pre-defined configurations determine how the DSA engine will be setup in terms of work queues and engines. The DSA engine is very flexible allowing for various configurations of these elements to either account for different quality of service requirements or to isolate hardware paths where the back end media is of varying latency (i.e. persistent memory vs DRAM). The pre-defined configurations are as follows:</p>
<p>0: Four separate work queues each backed with one DSA engine. This is a generic configuration that provides 4 portals to submit operations to each with a single engine behind it providing some level of isolation as operations are submitted round-robin.</p>
<p>1: Two separate work queues each backed with two DSA engines. This is another generic configuration that provides 2 portals to submit operations to and lets the DSA hardware decide which engine to select based on loading.</p>
<p>There are several other configurations that are possible that include quality of service parameters on the work queues that are not currently utilized by the module. Specialized use of DSA may require different configurations that can be added to the module as needed.</p>
<h2><a class="anchor" id="accel_sw"></a>
Software Module</h2>
<p>The software module is enabled by default. If no hardware engine is explicitly enabled via startup RPC as discussed earlier, the software module will use ISA-L if available for functions such as CRC32C. Otherwise, standard glibc calls are used to back the framework API.</p>
<h2><a class="anchor" id="batching"></a>
Batching</h2>
<p>Batching is exposed by the acceleration framework and provides an interface to batch sets of commands up and then submit them with a single command. The public API is consistent with the implementation however each plug-in module behaves differently depending on its capabilities.</p>
<p>The DSA engine has complete support for batching all supported commands together into one submission. This is advantageous as it reduces the overhead incurred in the submission process to the hardware.</p>
<p>The software engine supports batching only to be consistent with the framework API. In software there is no savings by batching sets of commands versus submitting them individually.</p>
<p>The IOAT engine supports batching but it is only beneficial for <code>memmove</code> and <code>memfill</code> as these are supported by the hardware. All other commands can be batched and the framework will manage all other commands via software. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
</div>
