<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.20">
  <title>SPDK: Message Passing and Concurrency</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('concurrency.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Message Passing and Concurrency </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_concurrency"></a> </p><h1>Theory</h1>
<p>One of the primary aims of SPDK is to scale linearly with the addition of hardware. This can mean many things in practice. For instance, moving from one SSD to two should double the number of I/O's per second. Or doubling the number of CPU cores should double the amount of computation possible. Or even doubling the number of NICs should double the network throughput. To achieve this, the software's threads of execution must be independent from one another as much as possible. In practice, that means avoiding software locks and even atomic instructions.</p>
<p>Traditionally, software achieves concurrency by placing some shared data onto the heap, protecting it with a lock, and then having all threads of execution acquire the lock only when accessing the data. This model has many great properties:</p>
<ul>
<li>It's easy to convert single-threaded programs to multi-threaded programs because you don't have to change the data model from the single-threaded version. You add a lock around the data.</li>
<li>You can write your program as a synchronous, imperative list of statements that you read from top to bottom.</li>
<li>The scheduler can interrupt threads, allowing for efficient time-sharing of CPU resources.</li>
</ul>
<p>Unfortunately, as the number of threads scales up, contention on the lock around the shared data does too. More granular locking helps, but then also increases the complexity of the program. Even then, beyond a certain number of contended locks, threads will spend most of their time attempting to acquire the locks and the program will not benefit from more CPU cores.</p>
<p>SPDK takes a different approach altogether. Instead of placing shared data in a global location that all threads access after acquiring a lock, SPDK will often assign that data to a single thread. When other threads want to access the data, they pass a message to the owning thread to perform the operation on their behalf. This strategy, of course, is not at all new. For instance, it is one of the core design principles of <a href="http://erlang.org/download/armstrong_thesis_2003.pdf">Erlang</a> and is the main concurrency mechanism in <a href="https://tour.golang.org/concurrency/2">Go</a>. A message in SPDK consists of a function pointer and a pointer to some context. Messages are passed between threads using a <a href="http://dpdk.org/doc/guides/prog_guide/ring_lib.html">lockless ring</a>. Message passing is often much faster than most software developer's intuition leads them to believe due to caching effects. If a single core is accessing the same data (on behalf of all of the other cores), then that data is far more likely to be in a cache closer to that core. It's often most efficient to have each core work on a small set of data sitting in its local cache and then hand off a small message to the next core when done.</p>
<p>In more extreme cases where even message passing may be too costly, each thread may make a local copy of the data. The thread will then only reference its local copy. To mutate the data, threads will send a message to each other thread telling them to perform the update on their local copy. This is great when the data isn't mutated very often, but is read very frequently, and is often employed in the I/O path. This of course trades memory size for computational efficiency, so it is used in only the most critical code paths.</p>
<h1>Message Passing Infrastructure</h1>
<p>SPDK provides several layers of message passing infrastructure. The most fundamental libraries in SPDK, for instance, don't do any message passing on their own and instead enumerate rules about when functions may be called in their documentation (e.g. <a class="el" href="nvme.html">NVMe Driver</a>). Most libraries, however, depend on SPDK's <a href="http://www.spdk.io/doc/thread_8h.html">thread</a> abstraction, located in <code>libspdk_thread.a</code>. The thread abstraction provides a basic message passing framework and defines a few key primitives.</p>
<p>First, <code>spdk_thread</code> is an abstraction for a lightweight, stackless thread of execution. A lower level framework can execute an <code>spdk_thread</code> for a single timeslice by calling <code><a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread.">spdk_thread_poll()</a></code>. A lower level framework is allowed to move an <code>spdk_thread</code> between system threads at any time, as long as there is only a single system thread executing <code><a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread.">spdk_thread_poll()</a></code> on that <code>spdk_thread</code> at any given time. New lightweight threads may be created at any time by calling <code><a class="el" href="thread_8h.html#a4eada7bac2a5c7ceaea891d57f8d3e21" title="Creates a new SPDK thread object.">spdk_thread_create()</a></code> and destroyed by calling <code><a class="el" href="thread_8h.html#a10aa5a8ec5228fa87db97f7655f8c0d6" title="Destroy a thread, releasing all of its resources.">spdk_thread_destroy()</a></code>. The lightweight thread is the foundational abstraction for threading in SPDK.</p>
<p>There are then a few additional abstractions layered on top of the <code>spdk_thread</code>. One is the <code>spdk_poller</code>, which is an abstraction for a function that should be repeatedly called on the given thread. Another is an <code>spdk_msg_fn</code>, which is a function pointer and a context pointer, that can be sent to a thread for execution via <code><a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec" title="Send a message to the given thread.">spdk_thread_send_msg()</a></code>.</p>
<p>The library also defines two additional abstractions: <code>spdk_io_device</code> and <code><a class="el" href="structspdk__io__channel.html" title="Represents a per-thread channel for accessing an I/O device.">spdk_io_channel</a></code>. In the course of implementing SPDK we noticed the same pattern emerging in a number of different libraries. In order to implement a message passing strategy, the code would describe some object with global state and also some per-thread context associated with that object that was accessed in the I/O path to avoid locking on the global state. The pattern was clearest in the lowest layers where I/O was being submitted to block devices. These devices often expose multiple queues that can be assigned to threads and then accessed without a lock to submit I/O. To abstract that, we generalized the device to <code>spdk_io_device</code> and the thread-specific queue to <code><a class="el" href="structspdk__io__channel.html" title="Represents a per-thread channel for accessing an I/O device.">spdk_io_channel</a></code>. Over time, however, the pattern has appeared in a huge number of places that don't fit quite so nicely with the names we originally chose. In today's code <code>spdk_io_device</code> is any pointer, whose uniqueness is predicated only on its memory address, and <code><a class="el" href="structspdk__io__channel.html" title="Represents a per-thread channel for accessing an I/O device.">spdk_io_channel</a></code> is the per-thread context associated with a particular <code>spdk_io_device</code>.</p>
<p>The threading abstraction provides functions to send a message to any other thread, to send a message to all threads one by one, and to send a message to all threads for which there is an io_channel for a given io_device.</p>
<p>Most critically, the thread abstraction does not actually spawn any system level threads of its own. Instead, it relies on the existence of some lower level framework that spawns system threads and sets up event loops. Inside those event loops, the threading abstraction simply requires the lower level framework to repeatedly call <code><a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread.">spdk_thread_poll()</a></code> on each <code>spdk_thread()</code> that exists. This makes SPDK very portable to a wide variety of asynchronous, event-based frameworks such as <a href="https://www.seastar.io">Seastar</a> or <a href="https://libuv.org/">libuv</a>.</p>
<h1>The event Framework</h1>
<p>The SPDK project didn't want to officially pick an asynchronous, event-based framework for all of the example applications it shipped with, in the interest of supporting the widest variety of frameworks possible. But the applications do of course require something that implements an asynchronous event loop in order to run, so enter the <code>event</code> framework located in <code>lib/event</code>. This framework includes things like polling and scheduling the lightweight threads, installing signal handlers to cleanly shutdown, and basic command line option parsing. Only established applications should consider directly integrating the lower level libraries.</p>
<h1>Limitations of the C Language</h1>
<p>Message passing is efficient, but it results in asynchronous code. Unfortunately, asynchronous code is a challenge in C. It's often implemented by passing function pointers that are called when an operation completes. This chops up the code so that it isn't easy to follow, especially through logic branches. The best solution is to use a language with support for <a href="https://en.wikipedia.org/wiki/Futures_and_promises">futures and promises</a>, such as C++, Rust, Go, or almost any other higher level language. However, SPDK is a low level library and requires very wide compatibility and portability, so we've elected to stay with plain old C.</p>
<p>We do have a few recommendations to share, though. For <em>simple</em> callback chains, it's easiest if you write the functions from bottom to top. By that we mean if function <code>foo</code> performs some asynchronous operation and when that completes function <code>bar</code> is called, then function <code>bar</code> performs some operation that calls function <code>baz</code> on completion, a good way to write it is as such: </p><pre class="fragment">void baz(void *ctx) {
        ...
}

void bar(void *ctx) {
        async_op(baz, ctx);
}

void foo(void *ctx) {
        async_op(bar, ctx);
}
</pre><p>Don't split these functions up - keep them as a nice unit that can be read from bottom to top.</p>
<p>For more complex callback chains, especially ones that have logical branches or loops, it's best to write out a state machine. It turns out that higher level languages that support futures and promises are just generating state machines at compile time, so even though we don't have the ability to generate them in C we can still write them out by hand. As an example, here's a callback chain that performs <code>foo</code> 5 times and then calls <code>bar</code> - effectively an asynchronous for loop. </p><pre class="fragment">enum states {
        FOO_START = 0,
        FOO_END,
        BAR_START,
        BAR_END
};

struct state_machine {
        enum states state;

        int count;
};

static void
foo_complete(void *ctx)
{
    struct state_machine *sm = ctx;

    sm-&gt;state = FOO_END;
    run_state_machine(sm);
}

static void
foo(struct state_machine *sm)
{
    do_async_op(foo_complete, sm);
}

static void
bar_complete(void *ctx)
{
    struct state_machine *sm = ctx;

    sm-&gt;state = BAR_END;
    run_state_machine(sm);
}

static void
bar(struct state_machine *sm)
{
    do_async_op(bar_complete, sm);
}

static void
run_state_machine(struct state_machine *sm)
{
    enum states prev_state;

    do {
        prev_state = sm-&gt;state;

        switch (sm-&gt;state) {
            case FOO_START:
                foo(sm);
                break;
            case FOO_END:
                /* This is the loop condition */
                if (sm-&gt;count++ &lt; 5) {
                    sm-&gt;state = FOO_START;
                } else {
                    sm-&gt;state = BAR_START;
                }
                break;
            case BAR_START:
                bar(sm);
                break;
            case BAR_END:
                break;
        }
    } while (prev_state != sm-&gt;state);
}

void do_async_for(void)
{
        struct state_machine *sm;

        sm = malloc(sizeof(*sm));
        sm-&gt;state = FOO_START;
        sm-&gt;count = 0;

        run_state_machine(sm);
}
</pre><p>This is complex, of course, but the <code>run_state_machine</code> function can be read from top to bottom to get a clear overview of what's happening in the code without having to chase through each of the callbacks. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
</div>
