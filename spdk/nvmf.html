<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.20">
  <title>SPDK: NVMe over Fabrics Target</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('nvmf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">NVMe over Fabrics Target </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_nvmf"></a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme.html#nvme_fabrics_host">NVMe over Fabrics Host Support</a> </dd>
<dd>
<a class="el" href="nvmf_tgt_tracepoints.html">NVMe-oF Target Tracepoints</a></dd></dl>
<h1><a class="anchor" id="nvmf_getting_started"></a>
NVMe-oF Target Getting Started Guide</h1>
<p>The SPDK NVMe over Fabrics target is a user space application that presents block devices over a fabrics such as Ethernet, Infiniband or Fibre Channel. SPDK currently supports RDMA and TCP transports.</p>
<p>The NVMe over Fabrics specification defines subsystems that can be exported over different transports. SPDK has chosen to call the software that exports these subsystems a "target", which is the term used for iSCSI. The specification refers to the "client" that connects to the target as a "host". Many people will also refer to the host as an "initiator", which is the equivalent thing in iSCSI parlance. SPDK will try to stick to the terms "target" and "host" to match the specification.</p>
<p>The Linux kernel also implements an NVMe-oF target and host, and SPDK is tested for interoperability with the Linux kernel implementations.</p>
<p>If you want to kill the application using signal, make sure use the SIGTERM, then the application will release all the share memory resource before exit, the SIGKILL will make the share memory resource have no chance to be released by application, you may need to release the resource manually.</p>
<h2><a class="anchor" id="nvmf_rdma_transport"></a>
RDMA transport support</h2>
<p>It requires an RDMA-capable NIC with its corresponding OFED (OpenFabrics Enterprise Distribution) software package installed to run. Maybe OS distributions provide packages, but OFED is also available <a href="https://downloads.openfabrics.org/OFED/">here</a>.</p>
<h3><a class="anchor" id="nvmf_prereqs"></a>
Prerequisites</h3>
<p>To build nvmf_tgt with the RDMA transport, there are some additional dependencies, which can be install using pkgdep.sh script.</p>
<div class="fragment"><div class="line">sudo scripts/pkgdep.sh --rdma</div>
</div><!-- fragment --><p>Then build SPDK with RDMA enabled:</p>
<div class="fragment"><div class="line">./configure --with-rdma &lt;other config parameters&gt;</div>
<div class="line">make</div>
</div><!-- fragment --><p>Once built, the binary will be in <code>build/bin</code>.</p>
<h3><a class="anchor" id="nvmf_prereqs_verbs"></a>
Prerequisites for InfiniBand/RDMA Verbs</h3>
<p>Before starting our NVMe-oF target with the RDMA transport we must load the InfiniBand and RDMA modules that allow userspace processes to use InfiniBand/RDMA verbs directly.</p>
<div class="fragment"><div class="line">modprobe ib_cm</div>
<div class="line">modprobe ib_core</div>
<div class="line"># Please note that ib_ucm does not exist in newer versions of the kernel and is not required.</div>
<div class="line">modprobe ib_ucm || true</div>
<div class="line">modprobe ib_umad</div>
<div class="line">modprobe ib_uverbs</div>
<div class="line">modprobe iw_cm</div>
<div class="line">modprobe rdma_cm</div>
<div class="line">modprobe rdma_ucm</div>
</div><!-- fragment --><h3><a class="anchor" id="nvmf_prereqs_rdma_nics"></a>
Prerequisites for RDMA NICs</h3>
<p>Before starting our NVMe-oF target we must detect RDMA NICs and assign them IP addresses.</p>
<h3>Finding RDMA NICs and associated network interfaces</h3>
<div class="fragment"><div class="line">ls /sys/class/infiniband/*/device/net</div>
</div><!-- fragment --><h4>Mellanox ConnectX-3 RDMA NICs</h4>
<div class="fragment"><div class="line">modprobe mlx4_core</div>
<div class="line">modprobe mlx4_ib</div>
<div class="line">modprobe mlx4_en</div>
</div><!-- fragment --><h4>Mellanox ConnectX-4 RDMA NICs</h4>
<div class="fragment"><div class="line">modprobe mlx5_core</div>
<div class="line">modprobe mlx5_ib</div>
</div><!-- fragment --><h4>Assigning IP addresses to RDMA NICs</h4>
<div class="fragment"><div class="line">ifconfig eth1 192.168.100.8 netmask 255.255.255.0 up</div>
<div class="line">ifconfig eth2 192.168.100.9 netmask 255.255.255.0 up</div>
</div><!-- fragment --><h3><a class="anchor" id="nvmf_rdma_limitations"></a>
RDMA Limitations</h3>
<p>As RDMA NICs put a limitation on the number of memory regions registered, the SPDK NVMe-oF target application may eventually start failing to allocate more DMA-able memory. This is an imperfection of the DPDK dynamic memory management and is most likely to occur with too many 2MB hugepages reserved at runtime. One type of memory bottleneck is the number of NIC memory regions, e.g., some NICs report as many as 2048 for the maximum number of memory regions. This gives us a 4GB memory limit with 2MB hugepages for the total memory regions. It can be overcome by using 1GB hugepages or by pre-reserving memory at application startup with <code>--mem-size</code> or <code>-s</code> option. All pre-reserved memory will be registered as a single region, but won't be returned to the system until the SPDK application is terminated.</p>
<h2><a class="anchor" id="nvmf_tcp_transport"></a>
TCP transport support</h2>
<p>The transport is built into the nvmf_tgt by default, and it does not need any special libraries.</p>
<h2><a class="anchor" id="nvmf_config"></a>
Configuring the SPDK NVMe over Fabrics Target</h2>
<p>An NVMe over Fabrics target can be configured using JSON RPCs. The basic RPCs needed to configure the NVMe-oF subsystem are detailed below. More information about working with NVMe over Fabrics specific RPCs can be found on the <a class="el" href="jsonrpc.html#jsonrpc_components_nvmf_tgt">NVMe-oF Target</a> RPC page.</p>
<p>Using .ini style configuration files for configuration of the NVMe-oF target is deprecated and should be replaced with JSON based RPCs. .ini style configuration files can be converted to json format by way of the new script <code>scripts/config_converter.py</code>.</p>
<h2><a class="anchor" id="nvmf_fc_transport"></a>
FC transport support</h2>
<p>To build nvmf_tgt with the FC transport, there is an additional FC LLD (Low Level Driver) code dependency. Please contact your FC vendor for instructions to obtain FC driver module.</p>
<h3>Broadcom FC LLD code</h3>
<p>FC LLD driver for Broadcom FC NVMe capable adapters can be obtained from, <a href="https://github.com/ecdufcdrvr/bcmufctdrvr">https://github.com/ecdufcdrvr/bcmufctdrvr</a>.</p>
<h3>Fetch FC LLD module and then build SPDK with FC enabled</h3>
<p>After cloning SPDK repo and initialize submodules, FC LLD library is built which then can be linked with the fc transport.</p>
<div class="fragment"><div class="line">git clone https://github.com/spdk/spdk spdk</div>
<div class="line">git clone https://github.com/ecdufcdrvr/bcmufctdrvr fc</div>
<div class="line">cd spdk</div>
<div class="line">git submodule update --init</div>
<div class="line">cd ../fc</div>
<div class="line">make DPDK_DIR=../spdk/dpdk/build SPDK_DIR=../spdk</div>
<div class="line">cd ../spdk</div>
<div class="line">./configure --with-fc=../fc/build</div>
<div class="line">make</div>
</div><!-- fragment --><h3><a class="anchor" id="nvmf_config_rpc"></a>
Using RPCs</h3>
<p>Start the nvmf_tgt application with elevated privileges. Once the target is started, the nvmf_create_transport rpc can be used to initialize a given transport. Below is an example where the target is started and configured with two different transports. The RDMA transport is configured with an I/O unit size of 8192 bytes, 4 max qpairs per controller, and an in capsule data size of 0 bytes. The TCP transport is configured with an I/O unit size of 16384 bytes, 8 max qpairs per controller, and an in capsule data size of 8192 bytes.</p>
<div class="fragment"><div class="line">build/bin/nvmf_tgt</div>
<div class="line">scripts/rpc.py nvmf_create_transport -t RDMA -u 8192 -m 4 -c 0</div>
<div class="line">scripts/rpc.py nvmf_create_transport -t TCP -u 16384 -m 8 -c 8192</div>
</div><!-- fragment --><p>Below is an example of creating a malloc bdev and assigning it to a subsystem. Adjust the bdevs, NQN, serial number, and IP address with RDMA transport to your own circumstances. If you replace "rdma" with "TCP", then the subsystem will add a listener with TCP transport.</p>
<div class="fragment"><div class="line">scripts/rpc.py bdev_malloc_create -b Malloc0 512 512</div>
<div class="line">scripts/rpc.py nvmf_create_subsystem nqn.2016-06.io.spdk:cnode1 -a -s SPDK00000000000001 -d SPDK_Controller1</div>
<div class="line">scripts/rpc.py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 Malloc0</div>
<div class="line">scripts/rpc.py nvmf_subsystem_add_listener nqn.2016-06.io.spdk:cnode1 -t rdma -a 192.168.100.8 -s 4420</div>
</div><!-- fragment --><h3>NQN Formal Definition</h3>
<p>NVMe qualified names or NQNs are defined in section 7.9 of the <a href="http://nvmexpress.org/wp-content/uploads/NVM_Express_Revision_1.3.pdf">NVMe specification</a>. SPDK has attempted to formalize that definition using <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended Backus-Naur form</a>. SPDK modules use this formal definition (provided below) when validating NQNs.</p>
<div class="fragment"><div class="line">Basic Types</div>
<div class="line">year = 4 * digit ;</div>
<div class="line">month = &#39;01&#39; | &#39;02&#39; | &#39;03&#39; | &#39;04&#39; | &#39;05&#39; | &#39;06&#39; | &#39;07&#39; | &#39;08&#39; | &#39;09&#39; | &#39;10&#39; | &#39;11&#39; | &#39;12&#39; ;</div>
<div class="line">digit = &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39; ;</div>
<div class="line">hex digit = &#39;A&#39; | &#39;B&#39; | &#39;C&#39; | &#39;D&#39; | &#39;E&#39; | &#39;F&#39; | &#39;a&#39; | &#39;b&#39; | &#39;c&#39; | &#39;d&#39; | &#39;e&#39; | &#39;f&#39; | &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39; ;</div>
<div class="line"> </div>
<div class="line">NQN Definition</div>
<div class="line">NVMe Qualified Name = ( NVMe-oF Discovery NQN | NVMe UUID NQN | NVMe Domain NQN ), &#39;\0&#39; ;</div>
<div class="line">NVMe-oF Discovery NQN = &quot;nqn.2014-08.org.nvmexpress.discovery&quot; ;</div>
<div class="line">NVMe UUID NQN = &quot;nqn.2014-08.org.nvmexpress:uuid:&quot;, string UUID ;</div>
<div class="line">string UUID = 8 * hex digit, &#39;-&#39;, 3 * (4 * hex digit, &#39;-&#39;), 12 * hex digit ;</div>
<div class="line">NVMe Domain NQN = &quot;nqn.&quot;, year, &#39;-&#39;, month, &#39;.&#39;, reverse domain, &#39;:&#39;, utf-8 string ;</div>
</div><!-- fragment --><p>Please note that the following types from the definition above are defined elsewhere:</p>
<ol type="1">
<li>utf-8 string: Defined in <a href="https://tools.ietf.org/html/rfc3629">rfc 3629</a>.</li>
<li>reverse domain: Equivalent to domain name as defined in <a href="https://tools.ietf.org/html/rfc1034">rfc 1034</a>.</li>
</ol>
<p>While not stated in the formal definition, SPDK enforces the requirement from the spec that the "maximum name is 223 bytes in length". SPDK does not include the null terminating character when defining the length of an nqn, and will accept an nqn containing up to 223 valid bytes with an additional null terminator. To be precise, SPDK follows the same conventions as the c standard library function <a href="http://man7.org/linux/man-pages/man3/strlen.3.html">strlen()</a>.</p>
<h4>NQN Comparisons</h4>
<p>SPDK compares NQNs byte for byte without case matching or unicode normalization. This has specific implications for uuid based NQNs. The following pair of NQNs, for example, would not match when compared in the SPDK NVMe-oF Target:</p>
<p>nqn.2014-08.org.nvmexpress:uuid:11111111-aaaa-bbdd-ffee-123456789abc nqn.2014-08.org.nvmexpress:uuid:11111111-AAAA-BBDD-FFEE-123456789ABC</p>
<p>In order to ensure the consistency of uuid based NQNs while using SPDK, users should use lowercase when representing alphabetic hex digits in their NQNs.</p>
<h3><a class="anchor" id="nvmf_config_lcore"></a>
Assigning CPU Cores to the NVMe over Fabrics Target</h3>
<p>SPDK uses the <a href="http://dpdk.org/doc/guides/prog_guide/env_abstraction_layer.html">DPDK Environment Abstraction Layer</a> to gain access to hardware resources such as huge memory pages and CPU core(s). DPDK EAL provides functions to assign threads to specific cores. To ensure the SPDK NVMe-oF target has the best performance, configure the NICs and NVMe devices to be located on the same NUMA node.</p>
<p>The <code>-m</code> core mask option specifies a bit mask of the CPU cores that SPDK is allowed to execute work items on. For example, to allow SPDK to use cores 24, 25, 26 and 27: </p><div class="fragment"><div class="line">build/bin/nvmf_tgt -m 0xF000000</div>
</div><!-- fragment --><h2><a class="anchor" id="nvmf_host"></a>
Configuring the Linux NVMe over Fabrics Host</h2>
<p>Both the Linux kernel and SPDK implement an NVMe over Fabrics host. The Linux kernel NVMe-oF RDMA host support is provided by the <code>nvme-rdma</code> driver (to support RDMA transport) and <code>nvme-tcp</code> (to support TCP transport). And the following shows two different commands for loading the driver.</p>
<div class="fragment"><div class="line">modprobe nvme-rdma</div>
<div class="line">modprobe nvme-tcp</div>
</div><!-- fragment --><p>The nvme-cli tool may be used to interface with the Linux kernel NVMe over Fabrics host. See below for examples of the discover, connect and disconnect commands. In all three instances, the transport can be changed to TCP by interchanging 'rdma' for 'tcp'.</p>
<p>Discovery: </p><div class="fragment"><div class="line">nvme discover -t rdma -a 192.168.100.8 -s 4420</div>
</div><!-- fragment --><p>Connect: </p><div class="fragment"><div class="line">nvme connect -t rdma -n &quot;nqn.2016-06.io.spdk:cnode1&quot; -a 192.168.100.8 -s 4420</div>
</div><!-- fragment --><p>Disconnect: </p><div class="fragment"><div class="line">nvme disconnect -n &quot;nqn.2016-06.io.spdk:cnode1&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="nvmf_trace"></a>
Enabling NVMe-oF target tracepoints for offline analysis and debug</h2>
<p>SPDK has a tracing framework for capturing low-level event information at runtime. <a class="el" href="nvmf_tgt_tracepoints.html">NVMe-oF Target Tracepoints</a> enable analysis of both performance and application crashes. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
</div>
